
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Chapter
 * 
 */
export type Chapter = $Result.DefaultSelection<Prisma.$ChapterPayload>
/**
 * Model Quiz
 * 
 */
export type Quiz = $Result.DefaultSelection<Prisma.$QuizPayload>
/**
 * Model QuizAttempt
 * 
 */
export type QuizAttempt = $Result.DefaultSelection<Prisma.$QuizAttemptPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model BlockProgress
 * 
 */
export type BlockProgress = $Result.DefaultSelection<Prisma.$BlockProgressPayload>
/**
 * Model Classroom
 * 
 */
export type Classroom = $Result.DefaultSelection<Prisma.$ClassroomPayload>
/**
 * Model ClassroomMembership
 * 
 */
export type ClassroomMembership = $Result.DefaultSelection<Prisma.$ClassroomMembershipPayload>
/**
 * Model ClassroomPost
 * 
 */
export type ClassroomPost = $Result.DefaultSelection<Prisma.$ClassroomPostPayload>
/**
 * Model ClassroomComment
 * 
 */
export type ClassroomComment = $Result.DefaultSelection<Prisma.$ClassroomCommentPayload>
/**
 * Model ClassroomResource
 * 
 */
export type ClassroomResource = $Result.DefaultSelection<Prisma.$ClassroomResourcePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.chapter`: Exposes CRUD operations for the **Chapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapter.findMany()
    * ```
    */
  get chapter(): Prisma.ChapterDelegate<ExtArgs>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **Quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.QuizDelegate<ExtArgs>;

  /**
   * `prisma.quizAttempt`: Exposes CRUD operations for the **QuizAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizAttempts
    * const quizAttempts = await prisma.quizAttempt.findMany()
    * ```
    */
  get quizAttempt(): Prisma.QuizAttemptDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs>;

  /**
   * `prisma.blockProgress`: Exposes CRUD operations for the **BlockProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockProgresses
    * const blockProgresses = await prisma.blockProgress.findMany()
    * ```
    */
  get blockProgress(): Prisma.BlockProgressDelegate<ExtArgs>;

  /**
   * `prisma.classroom`: Exposes CRUD operations for the **Classroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classrooms
    * const classrooms = await prisma.classroom.findMany()
    * ```
    */
  get classroom(): Prisma.ClassroomDelegate<ExtArgs>;

  /**
   * `prisma.classroomMembership`: Exposes CRUD operations for the **ClassroomMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassroomMemberships
    * const classroomMemberships = await prisma.classroomMembership.findMany()
    * ```
    */
  get classroomMembership(): Prisma.ClassroomMembershipDelegate<ExtArgs>;

  /**
   * `prisma.classroomPost`: Exposes CRUD operations for the **ClassroomPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassroomPosts
    * const classroomPosts = await prisma.classroomPost.findMany()
    * ```
    */
  get classroomPost(): Prisma.ClassroomPostDelegate<ExtArgs>;

  /**
   * `prisma.classroomComment`: Exposes CRUD operations for the **ClassroomComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassroomComments
    * const classroomComments = await prisma.classroomComment.findMany()
    * ```
    */
  get classroomComment(): Prisma.ClassroomCommentDelegate<ExtArgs>;

  /**
   * `prisma.classroomResource`: Exposes CRUD operations for the **ClassroomResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassroomResources
    * const classroomResources = await prisma.classroomResource.findMany()
    * ```
    */
  get classroomResource(): Prisma.ClassroomResourceDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Course: 'Course',
    Chapter: 'Chapter',
    Quiz: 'Quiz',
    QuizAttempt: 'QuizAttempt',
    Profile: 'Profile',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    PasswordResetToken: 'PasswordResetToken',
    BlockProgress: 'BlockProgress',
    Classroom: 'Classroom',
    ClassroomMembership: 'ClassroomMembership',
    ClassroomPost: 'ClassroomPost',
    ClassroomComment: 'ClassroomComment',
    ClassroomResource: 'ClassroomResource'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "course" | "chapter" | "quiz" | "quizAttempt" | "profile" | "account" | "session" | "verificationToken" | "passwordResetToken" | "blockProgress" | "classroom" | "classroomMembership" | "classroomPost" | "classroomComment" | "classroomResource"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Chapter: {
        payload: Prisma.$ChapterPayload<ExtArgs>
        fields: Prisma.ChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findFirst: {
            args: Prisma.ChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findMany: {
            args: Prisma.ChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          create: {
            args: Prisma.ChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          createMany: {
            args: Prisma.ChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          delete: {
            args: Prisma.ChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          update: {
            args: Prisma.ChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          deleteMany: {
            args: Prisma.ChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          aggregate: {
            args: Prisma.ChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapter>
          }
          groupBy: {
            args: Prisma.ChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterCountAggregateOutputType> | number
          }
        }
      }
      Quiz: {
        payload: Prisma.$QuizPayload<ExtArgs>
        fields: Prisma.QuizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findFirst: {
            args: Prisma.QuizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findMany: {
            args: Prisma.QuizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          create: {
            args: Prisma.QuizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          createMany: {
            args: Prisma.QuizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          delete: {
            args: Prisma.QuizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          update: {
            args: Prisma.QuizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          deleteMany: {
            args: Prisma.QuizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          aggregate: {
            args: Prisma.QuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz>
          }
          groupBy: {
            args: Prisma.QuizGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizCountArgs<ExtArgs>
            result: $Utils.Optional<QuizCountAggregateOutputType> | number
          }
        }
      }
      QuizAttempt: {
        payload: Prisma.$QuizAttemptPayload<ExtArgs>
        fields: Prisma.QuizAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findFirst: {
            args: Prisma.QuizAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findMany: {
            args: Prisma.QuizAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          create: {
            args: Prisma.QuizAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          createMany: {
            args: Prisma.QuizAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          delete: {
            args: Prisma.QuizAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          update: {
            args: Prisma.QuizAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          deleteMany: {
            args: Prisma.QuizAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuizAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          aggregate: {
            args: Prisma.QuizAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizAttempt>
          }
          groupBy: {
            args: Prisma.QuizAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      BlockProgress: {
        payload: Prisma.$BlockProgressPayload<ExtArgs>
        fields: Prisma.BlockProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressPayload>
          }
          findFirst: {
            args: Prisma.BlockProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressPayload>
          }
          findMany: {
            args: Prisma.BlockProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressPayload>[]
          }
          create: {
            args: Prisma.BlockProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressPayload>
          }
          createMany: {
            args: Prisma.BlockProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressPayload>[]
          }
          delete: {
            args: Prisma.BlockProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressPayload>
          }
          update: {
            args: Prisma.BlockProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressPayload>
          }
          deleteMany: {
            args: Prisma.BlockProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockProgressPayload>
          }
          aggregate: {
            args: Prisma.BlockProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockProgress>
          }
          groupBy: {
            args: Prisma.BlockProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockProgressCountArgs<ExtArgs>
            result: $Utils.Optional<BlockProgressCountAggregateOutputType> | number
          }
        }
      }
      Classroom: {
        payload: Prisma.$ClassroomPayload<ExtArgs>
        fields: Prisma.ClassroomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassroomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassroomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          findFirst: {
            args: Prisma.ClassroomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassroomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          findMany: {
            args: Prisma.ClassroomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>[]
          }
          create: {
            args: Prisma.ClassroomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          createMany: {
            args: Prisma.ClassroomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassroomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>[]
          }
          delete: {
            args: Prisma.ClassroomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          update: {
            args: Prisma.ClassroomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          deleteMany: {
            args: Prisma.ClassroomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassroomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassroomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          aggregate: {
            args: Prisma.ClassroomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassroom>
          }
          groupBy: {
            args: Prisma.ClassroomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassroomGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassroomCountArgs<ExtArgs>
            result: $Utils.Optional<ClassroomCountAggregateOutputType> | number
          }
        }
      }
      ClassroomMembership: {
        payload: Prisma.$ClassroomMembershipPayload<ExtArgs>
        fields: Prisma.ClassroomMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassroomMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassroomMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomMembershipPayload>
          }
          findFirst: {
            args: Prisma.ClassroomMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassroomMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomMembershipPayload>
          }
          findMany: {
            args: Prisma.ClassroomMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomMembershipPayload>[]
          }
          create: {
            args: Prisma.ClassroomMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomMembershipPayload>
          }
          createMany: {
            args: Prisma.ClassroomMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassroomMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomMembershipPayload>[]
          }
          delete: {
            args: Prisma.ClassroomMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomMembershipPayload>
          }
          update: {
            args: Prisma.ClassroomMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomMembershipPayload>
          }
          deleteMany: {
            args: Prisma.ClassroomMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassroomMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassroomMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomMembershipPayload>
          }
          aggregate: {
            args: Prisma.ClassroomMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassroomMembership>
          }
          groupBy: {
            args: Prisma.ClassroomMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassroomMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassroomMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<ClassroomMembershipCountAggregateOutputType> | number
          }
        }
      }
      ClassroomPost: {
        payload: Prisma.$ClassroomPostPayload<ExtArgs>
        fields: Prisma.ClassroomPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassroomPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassroomPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPostPayload>
          }
          findFirst: {
            args: Prisma.ClassroomPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassroomPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPostPayload>
          }
          findMany: {
            args: Prisma.ClassroomPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPostPayload>[]
          }
          create: {
            args: Prisma.ClassroomPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPostPayload>
          }
          createMany: {
            args: Prisma.ClassroomPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassroomPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPostPayload>[]
          }
          delete: {
            args: Prisma.ClassroomPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPostPayload>
          }
          update: {
            args: Prisma.ClassroomPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPostPayload>
          }
          deleteMany: {
            args: Prisma.ClassroomPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassroomPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassroomPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPostPayload>
          }
          aggregate: {
            args: Prisma.ClassroomPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassroomPost>
          }
          groupBy: {
            args: Prisma.ClassroomPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassroomPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassroomPostCountArgs<ExtArgs>
            result: $Utils.Optional<ClassroomPostCountAggregateOutputType> | number
          }
        }
      }
      ClassroomComment: {
        payload: Prisma.$ClassroomCommentPayload<ExtArgs>
        fields: Prisma.ClassroomCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassroomCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassroomCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomCommentPayload>
          }
          findFirst: {
            args: Prisma.ClassroomCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassroomCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomCommentPayload>
          }
          findMany: {
            args: Prisma.ClassroomCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomCommentPayload>[]
          }
          create: {
            args: Prisma.ClassroomCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomCommentPayload>
          }
          createMany: {
            args: Prisma.ClassroomCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassroomCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomCommentPayload>[]
          }
          delete: {
            args: Prisma.ClassroomCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomCommentPayload>
          }
          update: {
            args: Prisma.ClassroomCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomCommentPayload>
          }
          deleteMany: {
            args: Prisma.ClassroomCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassroomCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassroomCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomCommentPayload>
          }
          aggregate: {
            args: Prisma.ClassroomCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassroomComment>
          }
          groupBy: {
            args: Prisma.ClassroomCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassroomCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassroomCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ClassroomCommentCountAggregateOutputType> | number
          }
        }
      }
      ClassroomResource: {
        payload: Prisma.$ClassroomResourcePayload<ExtArgs>
        fields: Prisma.ClassroomResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassroomResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassroomResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomResourcePayload>
          }
          findFirst: {
            args: Prisma.ClassroomResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassroomResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomResourcePayload>
          }
          findMany: {
            args: Prisma.ClassroomResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomResourcePayload>[]
          }
          create: {
            args: Prisma.ClassroomResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomResourcePayload>
          }
          createMany: {
            args: Prisma.ClassroomResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassroomResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomResourcePayload>[]
          }
          delete: {
            args: Prisma.ClassroomResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomResourcePayload>
          }
          update: {
            args: Prisma.ClassroomResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomResourcePayload>
          }
          deleteMany: {
            args: Prisma.ClassroomResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassroomResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassroomResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomResourcePayload>
          }
          aggregate: {
            args: Prisma.ClassroomResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassroomResource>
          }
          groupBy: {
            args: Prisma.ClassroomResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassroomResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassroomResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ClassroomResourceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    courses: number
    attempts: number
    blockProgress: number
    accounts: number
    sessions: number
    passwordResetTokens: number
    classroomsCreated: number
    classroomMemberships: number
    classroomPosts: number
    classroomComments: number
    classroomResourcesAdded: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | UserCountOutputTypeCountCoursesArgs
    attempts?: boolean | UserCountOutputTypeCountAttemptsArgs
    blockProgress?: boolean | UserCountOutputTypeCountBlockProgressArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
    classroomsCreated?: boolean | UserCountOutputTypeCountClassroomsCreatedArgs
    classroomMemberships?: boolean | UserCountOutputTypeCountClassroomMembershipsArgs
    classroomPosts?: boolean | UserCountOutputTypeCountClassroomPostsArgs
    classroomComments?: boolean | UserCountOutputTypeCountClassroomCommentsArgs
    classroomResourcesAdded?: boolean | UserCountOutputTypeCountClassroomResourcesAddedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlockProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClassroomsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClassroomMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomMembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClassroomPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClassroomCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClassroomResourcesAddedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomResourceWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    chapters: number
    quizzes: number
    classroomResources: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | CourseCountOutputTypeCountChaptersArgs
    quizzes?: boolean | CourseCountOutputTypeCountQuizzesArgs
    classroomResources?: boolean | CourseCountOutputTypeCountClassroomResourcesArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountClassroomResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomResourceWhereInput
  }


  /**
   * Count Type ChapterCountOutputType
   */

  export type ChapterCountOutputType = {
    quizzes: number
    blockProgress: number
  }

  export type ChapterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizzes?: boolean | ChapterCountOutputTypeCountQuizzesArgs
    blockProgress?: boolean | ChapterCountOutputTypeCountBlockProgressArgs
  }

  // Custom InputTypes
  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterCountOutputType
     */
    select?: ChapterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountBlockProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockProgressWhereInput
  }


  /**
   * Count Type QuizCountOutputType
   */

  export type QuizCountOutputType = {
    attempts: number
    classroomResources: number
  }

  export type QuizCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempts?: boolean | QuizCountOutputTypeCountAttemptsArgs
    classroomResources?: boolean | QuizCountOutputTypeCountClassroomResourcesArgs
  }

  // Custom InputTypes
  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountClassroomResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomResourceWhereInput
  }


  /**
   * Count Type ClassroomCountOutputType
   */

  export type ClassroomCountOutputType = {
    memberships: number
    posts: number
    resources: number
  }

  export type ClassroomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | ClassroomCountOutputTypeCountMembershipsArgs
    posts?: boolean | ClassroomCountOutputTypeCountPostsArgs
    resources?: boolean | ClassroomCountOutputTypeCountResourcesArgs
  }

  // Custom InputTypes
  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomCountOutputType
     */
    select?: ClassroomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomMembershipWhereInput
  }

  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomPostWhereInput
  }

  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomResourceWhereInput
  }


  /**
   * Count Type ClassroomPostCountOutputType
   */

  export type ClassroomPostCountOutputType = {
    comments: number
  }

  export type ClassroomPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ClassroomPostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ClassroomPostCountOutputType without action
   */
  export type ClassroomPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPostCountOutputType
     */
    select?: ClassroomPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassroomPostCountOutputType without action
   */
  export type ClassroomPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomCommentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    image: string | null
    emailVerified: Date | null
    role: string | null
    apiKey: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    image: string | null
    emailVerified: Date | null
    role: string | null
    apiKey: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    image: number
    emailVerified: number
    role: number
    apiKey: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    image?: true
    emailVerified?: true
    role?: true
    apiKey?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    image?: true
    emailVerified?: true
    role?: true
    apiKey?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    image?: true
    emailVerified?: true
    role?: true
    apiKey?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string | null
    name: string | null
    image: string | null
    emailVerified: Date | null
    role: string
    apiKey: string | null
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    image?: boolean
    emailVerified?: boolean
    role?: boolean
    apiKey?: boolean
    createdAt?: boolean
    courses?: boolean | User$coursesArgs<ExtArgs>
    attempts?: boolean | User$attemptsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    blockProgress?: boolean | User$blockProgressArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    classroomsCreated?: boolean | User$classroomsCreatedArgs<ExtArgs>
    classroomMemberships?: boolean | User$classroomMembershipsArgs<ExtArgs>
    classroomPosts?: boolean | User$classroomPostsArgs<ExtArgs>
    classroomComments?: boolean | User$classroomCommentsArgs<ExtArgs>
    classroomResourcesAdded?: boolean | User$classroomResourcesAddedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    image?: boolean
    emailVerified?: boolean
    role?: boolean
    apiKey?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    image?: boolean
    emailVerified?: boolean
    role?: boolean
    apiKey?: boolean
    createdAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | User$coursesArgs<ExtArgs>
    attempts?: boolean | User$attemptsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    blockProgress?: boolean | User$blockProgressArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    classroomsCreated?: boolean | User$classroomsCreatedArgs<ExtArgs>
    classroomMemberships?: boolean | User$classroomMembershipsArgs<ExtArgs>
    classroomPosts?: boolean | User$classroomPostsArgs<ExtArgs>
    classroomComments?: boolean | User$classroomCommentsArgs<ExtArgs>
    classroomResourcesAdded?: boolean | User$classroomResourcesAddedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      courses: Prisma.$CoursePayload<ExtArgs>[]
      attempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      blockProgress: Prisma.$BlockProgressPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      classroomsCreated: Prisma.$ClassroomPayload<ExtArgs>[]
      classroomMemberships: Prisma.$ClassroomMembershipPayload<ExtArgs>[]
      classroomPosts: Prisma.$ClassroomPostPayload<ExtArgs>[]
      classroomComments: Prisma.$ClassroomCommentPayload<ExtArgs>[]
      classroomResourcesAdded: Prisma.$ClassroomResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string | null
      name: string | null
      image: string | null
      emailVerified: Date | null
      role: string
      apiKey: string | null
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends User$coursesArgs<ExtArgs> = {}>(args?: Subset<T, User$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    attempts<T extends User$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    blockProgress<T extends User$blockProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$blockProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockProgressPayload<ExtArgs>, T, "findMany"> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany"> | Null>
    classroomsCreated<T extends User$classroomsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$classroomsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findMany"> | Null>
    classroomMemberships<T extends User$classroomMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$classroomMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomMembershipPayload<ExtArgs>, T, "findMany"> | Null>
    classroomPosts<T extends User$classroomPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$classroomPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPostPayload<ExtArgs>, T, "findMany"> | Null>
    classroomComments<T extends User$classroomCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$classroomCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomCommentPayload<ExtArgs>, T, "findMany"> | Null>
    classroomResourcesAdded<T extends User$classroomResourcesAddedArgs<ExtArgs> = {}>(args?: Subset<T, User$classroomResourcesAddedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'String'>
    readonly apiKey: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.courses
   */
  export type User$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.attempts
   */
  export type User$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.blockProgress
   */
  export type User$blockProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgress
     */
    select?: BlockProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressInclude<ExtArgs> | null
    where?: BlockProgressWhereInput
    orderBy?: BlockProgressOrderByWithRelationInput | BlockProgressOrderByWithRelationInput[]
    cursor?: BlockProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockProgressScalarFieldEnum | BlockProgressScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.classroomsCreated
   */
  export type User$classroomsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    where?: ClassroomWhereInput
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    cursor?: ClassroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * User.classroomMemberships
   */
  export type User$classroomMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomMembership
     */
    select?: ClassroomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomMembershipInclude<ExtArgs> | null
    where?: ClassroomMembershipWhereInput
    orderBy?: ClassroomMembershipOrderByWithRelationInput | ClassroomMembershipOrderByWithRelationInput[]
    cursor?: ClassroomMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomMembershipScalarFieldEnum | ClassroomMembershipScalarFieldEnum[]
  }

  /**
   * User.classroomPosts
   */
  export type User$classroomPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPost
     */
    select?: ClassroomPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomPostInclude<ExtArgs> | null
    where?: ClassroomPostWhereInput
    orderBy?: ClassroomPostOrderByWithRelationInput | ClassroomPostOrderByWithRelationInput[]
    cursor?: ClassroomPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomPostScalarFieldEnum | ClassroomPostScalarFieldEnum[]
  }

  /**
   * User.classroomComments
   */
  export type User$classroomCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomComment
     */
    select?: ClassroomCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomCommentInclude<ExtArgs> | null
    where?: ClassroomCommentWhereInput
    orderBy?: ClassroomCommentOrderByWithRelationInput | ClassroomCommentOrderByWithRelationInput[]
    cursor?: ClassroomCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomCommentScalarFieldEnum | ClassroomCommentScalarFieldEnum[]
  }

  /**
   * User.classroomResourcesAdded
   */
  export type User$classroomResourcesAddedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
    where?: ClassroomResourceWhereInput
    orderBy?: ClassroomResourceOrderByWithRelationInput | ClassroomResourceOrderByWithRelationInput[]
    cursor?: ClassroomResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomResourceScalarFieldEnum | ClassroomResourceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type CourseSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    slug: string | null
    visibility: string | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    slug: string | null
    visibility: string | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    description: number
    slug: number
    visibility: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type CourseSumAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    slug?: true
    visibility?: true
    createdBy?: true
    createdAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    slug?: true
    visibility?: true
    createdBy?: true
    createdAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    slug?: true
    visibility?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: number
    title: string
    description: string | null
    slug: string
    visibility: string
    createdBy: number
    createdAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    visibility?: boolean
    createdBy?: boolean
    createdAt?: boolean
    chapters?: boolean | Course$chaptersArgs<ExtArgs>
    quizzes?: boolean | Course$quizzesArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    classroomResources?: boolean | Course$classroomResourcesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    visibility?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    visibility?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | Course$chaptersArgs<ExtArgs>
    quizzes?: boolean | Course$quizzesArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    classroomResources?: boolean | Course$classroomResourcesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      chapters: Prisma.$ChapterPayload<ExtArgs>[]
      quizzes: Prisma.$QuizPayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs>
      classroomResources: Prisma.$ClassroomResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      slug: string
      visibility: string
      createdBy: number
      createdAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapters<T extends Course$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, Course$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany"> | Null>
    quizzes<T extends Course$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, Course$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany"> | Null>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    classroomResources<T extends Course$classroomResourcesArgs<ExtArgs> = {}>(args?: Subset<T, Course$classroomResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'Int'>
    readonly title: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly slug: FieldRef<"Course", 'String'>
    readonly visibility: FieldRef<"Course", 'String'>
    readonly createdBy: FieldRef<"Course", 'Int'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }

  /**
   * Course.chapters
   */
  export type Course$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    cursor?: ChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Course.quizzes
   */
  export type Course$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Course.classroomResources
   */
  export type Course$classroomResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
    where?: ClassroomResourceWhereInput
    orderBy?: ClassroomResourceOrderByWithRelationInput | ClassroomResourceOrderByWithRelationInput[]
    cursor?: ClassroomResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomResourceScalarFieldEnum | ClassroomResourceScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Chapter
   */

  export type AggregateChapter = {
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  export type ChapterAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    order: number | null
  }

  export type ChapterSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    order: number | null
  }

  export type ChapterMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    order: number | null
    content: string | null
    blocks: string | null
  }

  export type ChapterMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    order: number | null
    content: string | null
    blocks: string | null
  }

  export type ChapterCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    order: number
    content: number
    blocks: number
    _all: number
  }


  export type ChapterAvgAggregateInputType = {
    id?: true
    courseId?: true
    order?: true
  }

  export type ChapterSumAggregateInputType = {
    id?: true
    courseId?: true
    order?: true
  }

  export type ChapterMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    order?: true
    content?: true
    blocks?: true
  }

  export type ChapterMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    order?: true
    content?: true
    blocks?: true
  }

  export type ChapterCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    order?: true
    content?: true
    blocks?: true
    _all?: true
  }

  export type ChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapter to aggregate.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chapters
    **/
    _count?: true | ChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterMaxAggregateInputType
  }

  export type GetChapterAggregateType<T extends ChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter[P]>
      : GetScalarType<T[P], AggregateChapter[P]>
  }




  export type ChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithAggregationInput | ChapterOrderByWithAggregationInput[]
    by: ChapterScalarFieldEnum[] | ChapterScalarFieldEnum
    having?: ChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterCountAggregateInputType | true
    _avg?: ChapterAvgAggregateInputType
    _sum?: ChapterSumAggregateInputType
    _min?: ChapterMinAggregateInputType
    _max?: ChapterMaxAggregateInputType
  }

  export type ChapterGroupByOutputType = {
    id: number
    courseId: number
    title: string
    order: number
    content: string | null
    blocks: string | null
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  type GetChapterGroupByPayload<T extends ChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterGroupByOutputType[P]>
        }
      >
    >


  export type ChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    order?: boolean
    content?: boolean
    blocks?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    quizzes?: boolean | Chapter$quizzesArgs<ExtArgs>
    blockProgress?: boolean | Chapter$blockProgressArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    order?: boolean
    content?: boolean
    blocks?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    order?: boolean
    content?: boolean
    blocks?: boolean
  }

  export type ChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    quizzes?: boolean | Chapter$quizzesArgs<ExtArgs>
    blockProgress?: boolean | Chapter$blockProgressArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $ChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chapter"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      quizzes: Prisma.$QuizPayload<ExtArgs>[]
      blockProgress: Prisma.$BlockProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      title: string
      order: number
      content: string | null
      blocks: string | null
    }, ExtArgs["result"]["chapter"]>
    composites: {}
  }

  type ChapterGetPayload<S extends boolean | null | undefined | ChapterDefaultArgs> = $Result.GetResult<Prisma.$ChapterPayload, S>

  type ChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChapterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChapterCountAggregateInputType | true
    }

  export interface ChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chapter'], meta: { name: 'Chapter' } }
    /**
     * Find zero or one Chapter that matches the filter.
     * @param {ChapterFindUniqueArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterFindUniqueArgs>(args: SelectSubset<T, ChapterFindUniqueArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chapter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChapterFindUniqueOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterFindFirstArgs>(args?: SelectSubset<T, ChapterFindFirstArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapter.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterWithIdOnly = await prisma.chapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterFindManyArgs>(args?: SelectSubset<T, ChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chapter.
     * @param {ChapterCreateArgs} args - Arguments to create a Chapter.
     * @example
     * // Create one Chapter
     * const Chapter = await prisma.chapter.create({
     *   data: {
     *     // ... data to create a Chapter
     *   }
     * })
     * 
     */
    create<T extends ChapterCreateArgs>(args: SelectSubset<T, ChapterCreateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chapters.
     * @param {ChapterCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterCreateManyArgs>(args?: SelectSubset<T, ChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chapters and returns the data saved in the database.
     * @param {ChapterCreateManyAndReturnArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chapter.
     * @param {ChapterDeleteArgs} args - Arguments to delete one Chapter.
     * @example
     * // Delete one Chapter
     * const Chapter = await prisma.chapter.delete({
     *   where: {
     *     // ... filter to delete one Chapter
     *   }
     * })
     * 
     */
    delete<T extends ChapterDeleteArgs>(args: SelectSubset<T, ChapterDeleteArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chapter.
     * @param {ChapterUpdateArgs} args - Arguments to update one Chapter.
     * @example
     * // Update one Chapter
     * const chapter = await prisma.chapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterUpdateArgs>(args: SelectSubset<T, ChapterUpdateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chapters.
     * @param {ChapterDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterDeleteManyArgs>(args?: SelectSubset<T, ChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterUpdateManyArgs>(args: SelectSubset<T, ChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chapter.
     * @param {ChapterUpsertArgs} args - Arguments to update or create a Chapter.
     * @example
     * // Update or create a Chapter
     * const chapter = await prisma.chapter.upsert({
     *   create: {
     *     // ... data to create a Chapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter we want to update
     *   }
     * })
     */
    upsert<T extends ChapterUpsertArgs>(args: SelectSubset<T, ChapterUpsertArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapter.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends ChapterCountArgs>(
      args?: Subset<T, ChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterAggregateArgs>(args: Subset<T, ChapterAggregateArgs>): Prisma.PrismaPromise<GetChapterAggregateType<T>>

    /**
     * Group by Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterGroupByArgs['orderBy'] }
        : { orderBy?: ChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chapter model
   */
  readonly fields: ChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    quizzes<T extends Chapter$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany"> | Null>
    blockProgress<T extends Chapter$blockProgressArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$blockProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockProgressPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chapter model
   */ 
  interface ChapterFieldRefs {
    readonly id: FieldRef<"Chapter", 'Int'>
    readonly courseId: FieldRef<"Chapter", 'Int'>
    readonly title: FieldRef<"Chapter", 'String'>
    readonly order: FieldRef<"Chapter", 'Int'>
    readonly content: FieldRef<"Chapter", 'String'>
    readonly blocks: FieldRef<"Chapter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chapter findUnique
   */
  export type ChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findUniqueOrThrow
   */
  export type ChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findFirst
   */
  export type ChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findFirstOrThrow
   */
  export type ChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findMany
   */
  export type ChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter create
   */
  export type ChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a Chapter.
     */
    data: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
  }

  /**
   * Chapter createMany
   */
  export type ChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chapter createManyAndReturn
   */
  export type ChapterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter update
   */
  export type ChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a Chapter.
     */
    data: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
    /**
     * Choose, which Chapter to update.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter updateMany
   */
  export type ChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
  }

  /**
   * Chapter upsert
   */
  export type ChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the Chapter to update in case it exists.
     */
    where: ChapterWhereUniqueInput
    /**
     * In case the Chapter found by the `where` argument doesn't exist, create a new Chapter with this data.
     */
    create: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
    /**
     * In case the Chapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
  }

  /**
   * Chapter delete
   */
  export type ChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter which Chapter to delete.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter deleteMany
   */
  export type ChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to delete
     */
    where?: ChapterWhereInput
  }

  /**
   * Chapter.quizzes
   */
  export type Chapter$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Chapter.blockProgress
   */
  export type Chapter$blockProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgress
     */
    select?: BlockProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressInclude<ExtArgs> | null
    where?: BlockProgressWhereInput
    orderBy?: BlockProgressOrderByWithRelationInput | BlockProgressOrderByWithRelationInput[]
    cursor?: BlockProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockProgressScalarFieldEnum | BlockProgressScalarFieldEnum[]
  }

  /**
   * Chapter without action
   */
  export type ChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
  }


  /**
   * Model Quiz
   */

  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    chapterId: number | null
    attemptLimit: number | null
  }

  export type QuizSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    chapterId: number | null
    attemptLimit: number | null
  }

  export type QuizMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    chapterId: number | null
    title: string | null
    visibility: string | null
    questions: string | null
    settings: string | null
    quizType: string | null
    attemptLimit: number | null
    scoreReleaseMode: string | null
    createdAt: Date | null
  }

  export type QuizMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    chapterId: number | null
    title: string | null
    visibility: string | null
    questions: string | null
    settings: string | null
    quizType: string | null
    attemptLimit: number | null
    scoreReleaseMode: string | null
    createdAt: Date | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    courseId: number
    chapterId: number
    title: number
    visibility: number
    questions: number
    settings: number
    quizType: number
    attemptLimit: number
    scoreReleaseMode: number
    createdAt: number
    _all: number
  }


  export type QuizAvgAggregateInputType = {
    id?: true
    courseId?: true
    chapterId?: true
    attemptLimit?: true
  }

  export type QuizSumAggregateInputType = {
    id?: true
    courseId?: true
    chapterId?: true
    attemptLimit?: true
  }

  export type QuizMinAggregateInputType = {
    id?: true
    courseId?: true
    chapterId?: true
    title?: true
    visibility?: true
    questions?: true
    settings?: true
    quizType?: true
    attemptLimit?: true
    scoreReleaseMode?: true
    createdAt?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    courseId?: true
    chapterId?: true
    title?: true
    visibility?: true
    questions?: true
    settings?: true
    quizType?: true
    attemptLimit?: true
    scoreReleaseMode?: true
    createdAt?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    courseId?: true
    chapterId?: true
    title?: true
    visibility?: true
    questions?: true
    settings?: true
    quizType?: true
    attemptLimit?: true
    scoreReleaseMode?: true
    createdAt?: true
    _all?: true
  }

  export type QuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quiz to aggregate.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithAggregationInput | QuizOrderByWithAggregationInput[]
    by: QuizScalarFieldEnum[] | QuizScalarFieldEnum
    having?: QuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _avg?: QuizAvgAggregateInputType
    _sum?: QuizSumAggregateInputType
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }

  export type QuizGroupByOutputType = {
    id: number
    courseId: number | null
    chapterId: number | null
    title: string
    visibility: string
    questions: string
    settings: string | null
    quizType: string
    attemptLimit: number | null
    scoreReleaseMode: string
    createdAt: Date
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type QuizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    chapterId?: boolean
    title?: boolean
    visibility?: boolean
    questions?: boolean
    settings?: boolean
    quizType?: boolean
    attemptLimit?: boolean
    scoreReleaseMode?: boolean
    createdAt?: boolean
    course?: boolean | Quiz$courseArgs<ExtArgs>
    chapter?: boolean | Quiz$chapterArgs<ExtArgs>
    attempts?: boolean | Quiz$attemptsArgs<ExtArgs>
    classroomResources?: boolean | Quiz$classroomResourcesArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    chapterId?: boolean
    title?: boolean
    visibility?: boolean
    questions?: boolean
    settings?: boolean
    quizType?: boolean
    attemptLimit?: boolean
    scoreReleaseMode?: boolean
    createdAt?: boolean
    course?: boolean | Quiz$courseArgs<ExtArgs>
    chapter?: boolean | Quiz$chapterArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectScalar = {
    id?: boolean
    courseId?: boolean
    chapterId?: boolean
    title?: boolean
    visibility?: boolean
    questions?: boolean
    settings?: boolean
    quizType?: boolean
    attemptLimit?: boolean
    scoreReleaseMode?: boolean
    createdAt?: boolean
  }

  export type QuizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Quiz$courseArgs<ExtArgs>
    chapter?: boolean | Quiz$chapterArgs<ExtArgs>
    attempts?: boolean | Quiz$attemptsArgs<ExtArgs>
    classroomResources?: boolean | Quiz$classroomResourcesArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Quiz$courseArgs<ExtArgs>
    chapter?: boolean | Quiz$chapterArgs<ExtArgs>
  }

  export type $QuizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quiz"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs> | null
      chapter: Prisma.$ChapterPayload<ExtArgs> | null
      attempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
      classroomResources: Prisma.$ClassroomResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number | null
      chapterId: number | null
      title: string
      visibility: string
      questions: string
      settings: string | null
      quizType: string
      attemptLimit: number | null
      scoreReleaseMode: string
      createdAt: Date
    }, ExtArgs["result"]["quiz"]>
    composites: {}
  }

  type QuizGetPayload<S extends boolean | null | undefined | QuizDefaultArgs> = $Result.GetResult<Prisma.$QuizPayload, S>

  type QuizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuizFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface QuizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quiz'], meta: { name: 'Quiz' } }
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {QuizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizFindUniqueArgs>(args: SelectSubset<T, QuizFindUniqueArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Quiz that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizFindFirstArgs>(args?: SelectSubset<T, QuizFindFirstArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Quiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizFindManyArgs>(args?: SelectSubset<T, QuizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Quiz.
     * @param {QuizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
     */
    create<T extends QuizCreateArgs>(args: SelectSubset<T, QuizCreateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Quizzes.
     * @param {QuizCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizCreateManyArgs>(args?: SelectSubset<T, QuizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quizzes and returns the data saved in the database.
     * @param {QuizCreateManyAndReturnArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Quiz.
     * @param {QuizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
     */
    delete<T extends QuizDeleteArgs>(args: SelectSubset<T, QuizDeleteArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Quiz.
     * @param {QuizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizUpdateArgs>(args: SelectSubset<T, QuizUpdateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizDeleteManyArgs>(args?: SelectSubset<T, QuizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizUpdateManyArgs>(args: SelectSubset<T, QuizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quiz.
     * @param {QuizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
     */
    upsert<T extends QuizUpsertArgs>(args: SelectSubset<T, QuizUpsertArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizCountArgs>(
      args?: Subset<T, QuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quiz model
   */
  readonly fields: QuizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends Quiz$courseArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    chapter<T extends Quiz$chapterArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$chapterArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    attempts<T extends Quiz$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    classroomResources<T extends Quiz$classroomResourcesArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$classroomResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quiz model
   */ 
  interface QuizFieldRefs {
    readonly id: FieldRef<"Quiz", 'Int'>
    readonly courseId: FieldRef<"Quiz", 'Int'>
    readonly chapterId: FieldRef<"Quiz", 'Int'>
    readonly title: FieldRef<"Quiz", 'String'>
    readonly visibility: FieldRef<"Quiz", 'String'>
    readonly questions: FieldRef<"Quiz", 'String'>
    readonly settings: FieldRef<"Quiz", 'String'>
    readonly quizType: FieldRef<"Quiz", 'String'>
    readonly attemptLimit: FieldRef<"Quiz", 'Int'>
    readonly scoreReleaseMode: FieldRef<"Quiz", 'String'>
    readonly createdAt: FieldRef<"Quiz", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quiz findUnique
   */
  export type QuizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findUniqueOrThrow
   */
  export type QuizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findFirst
   */
  export type QuizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findFirstOrThrow
   */
  export type QuizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findMany
   */
  export type QuizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz create
   */
  export type QuizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to create a Quiz.
     */
    data: XOR<QuizCreateInput, QuizUncheckedCreateInput>
  }

  /**
   * Quiz createMany
   */
  export type QuizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quiz createManyAndReturn
   */
  export type QuizCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz update
   */
  export type QuizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to update a Quiz.
     */
    data: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
    /**
     * Choose, which Quiz to update.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz updateMany
   */
  export type QuizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
  }

  /**
   * Quiz upsert
   */
  export type QuizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The filter to search for the Quiz to update in case it exists.
     */
    where: QuizWhereUniqueInput
    /**
     * In case the Quiz found by the `where` argument doesn't exist, create a new Quiz with this data.
     */
    create: XOR<QuizCreateInput, QuizUncheckedCreateInput>
    /**
     * In case the Quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
  }

  /**
   * Quiz delete
   */
  export type QuizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter which Quiz to delete.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz deleteMany
   */
  export type QuizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizWhereInput
  }

  /**
   * Quiz.course
   */
  export type Quiz$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * Quiz.chapter
   */
  export type Quiz$chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
  }

  /**
   * Quiz.attempts
   */
  export type Quiz$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * Quiz.classroomResources
   */
  export type Quiz$classroomResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
    where?: ClassroomResourceWhereInput
    orderBy?: ClassroomResourceOrderByWithRelationInput | ClassroomResourceOrderByWithRelationInput[]
    cursor?: ClassroomResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomResourceScalarFieldEnum | ClassroomResourceScalarFieldEnum[]
  }

  /**
   * Quiz without action
   */
  export type QuizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
  }


  /**
   * Model QuizAttempt
   */

  export type AggregateQuizAttempt = {
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  export type QuizAttemptAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    quizId: number | null
    score: number | null
    totalQuestions: number | null
    correctAnswers: number | null
    percentage: number | null
    timeSpent: number | null
  }

  export type QuizAttemptSumAggregateOutputType = {
    id: number | null
    userId: number | null
    quizId: number | null
    score: number | null
    totalQuestions: number | null
    correctAnswers: number | null
    percentage: number | null
    timeSpent: number | null
  }

  export type QuizAttemptMinAggregateOutputType = {
    id: number | null
    userId: number | null
    quizId: number | null
    answers: string | null
    score: number | null
    totalQuestions: number | null
    correctAnswers: number | null
    percentage: number | null
    timeSpent: number | null
    detailedResults: string | null
    completedAt: Date | null
    scoreReleasedAt: Date | null
    endReason: string | null
  }

  export type QuizAttemptMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    quizId: number | null
    answers: string | null
    score: number | null
    totalQuestions: number | null
    correctAnswers: number | null
    percentage: number | null
    timeSpent: number | null
    detailedResults: string | null
    completedAt: Date | null
    scoreReleasedAt: Date | null
    endReason: string | null
  }

  export type QuizAttemptCountAggregateOutputType = {
    id: number
    userId: number
    quizId: number
    answers: number
    score: number
    totalQuestions: number
    correctAnswers: number
    percentage: number
    timeSpent: number
    detailedResults: number
    completedAt: number
    scoreReleasedAt: number
    endReason: number
    _all: number
  }


  export type QuizAttemptAvgAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    score?: true
    totalQuestions?: true
    correctAnswers?: true
    percentage?: true
    timeSpent?: true
  }

  export type QuizAttemptSumAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    score?: true
    totalQuestions?: true
    correctAnswers?: true
    percentage?: true
    timeSpent?: true
  }

  export type QuizAttemptMinAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    answers?: true
    score?: true
    totalQuestions?: true
    correctAnswers?: true
    percentage?: true
    timeSpent?: true
    detailedResults?: true
    completedAt?: true
    scoreReleasedAt?: true
    endReason?: true
  }

  export type QuizAttemptMaxAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    answers?: true
    score?: true
    totalQuestions?: true
    correctAnswers?: true
    percentage?: true
    timeSpent?: true
    detailedResults?: true
    completedAt?: true
    scoreReleasedAt?: true
    endReason?: true
  }

  export type QuizAttemptCountAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    answers?: true
    score?: true
    totalQuestions?: true
    correctAnswers?: true
    percentage?: true
    timeSpent?: true
    detailedResults?: true
    completedAt?: true
    scoreReleasedAt?: true
    endReason?: true
    _all?: true
  }

  export type QuizAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempt to aggregate.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizAttempts
    **/
    _count?: true | QuizAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type GetQuizAttemptAggregateType<T extends QuizAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizAttempt[P]>
      : GetScalarType<T[P], AggregateQuizAttempt[P]>
  }




  export type QuizAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithAggregationInput | QuizAttemptOrderByWithAggregationInput[]
    by: QuizAttemptScalarFieldEnum[] | QuizAttemptScalarFieldEnum
    having?: QuizAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizAttemptCountAggregateInputType | true
    _avg?: QuizAttemptAvgAggregateInputType
    _sum?: QuizAttemptSumAggregateInputType
    _min?: QuizAttemptMinAggregateInputType
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type QuizAttemptGroupByOutputType = {
    id: number
    userId: number
    quizId: number
    answers: string
    score: number
    totalQuestions: number
    correctAnswers: number
    percentage: number
    timeSpent: number
    detailedResults: string
    completedAt: Date
    scoreReleasedAt: Date | null
    endReason: string
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  type GetQuizAttemptGroupByPayload<T extends QuizAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
        }
      >
    >


  export type QuizAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    quizId?: boolean
    answers?: boolean
    score?: boolean
    totalQuestions?: boolean
    correctAnswers?: boolean
    percentage?: boolean
    timeSpent?: boolean
    detailedResults?: boolean
    completedAt?: boolean
    scoreReleasedAt?: boolean
    endReason?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    quizId?: boolean
    answers?: boolean
    score?: boolean
    totalQuestions?: boolean
    correctAnswers?: boolean
    percentage?: boolean
    timeSpent?: boolean
    detailedResults?: boolean
    completedAt?: boolean
    scoreReleasedAt?: boolean
    endReason?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectScalar = {
    id?: boolean
    userId?: boolean
    quizId?: boolean
    answers?: boolean
    score?: boolean
    totalQuestions?: boolean
    correctAnswers?: boolean
    percentage?: boolean
    timeSpent?: boolean
    detailedResults?: boolean
    completedAt?: boolean
    scoreReleasedAt?: boolean
    endReason?: boolean
  }

  export type QuizAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuizAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }

  export type $QuizAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizAttempt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      quiz: Prisma.$QuizPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      quizId: number
      answers: string
      score: number
      totalQuestions: number
      correctAnswers: number
      percentage: number
      timeSpent: number
      detailedResults: string
      completedAt: Date
      scoreReleasedAt: Date | null
      endReason: string
    }, ExtArgs["result"]["quizAttempt"]>
    composites: {}
  }

  type QuizAttemptGetPayload<S extends boolean | null | undefined | QuizAttemptDefaultArgs> = $Result.GetResult<Prisma.$QuizAttemptPayload, S>

  type QuizAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuizAttemptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuizAttemptCountAggregateInputType | true
    }

  export interface QuizAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizAttempt'], meta: { name: 'QuizAttempt' } }
    /**
     * Find zero or one QuizAttempt that matches the filter.
     * @param {QuizAttemptFindUniqueArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizAttemptFindUniqueArgs>(args: SelectSubset<T, QuizAttemptFindUniqueArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuizAttempt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuizAttemptFindUniqueOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuizAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizAttemptFindFirstArgs>(args?: SelectSubset<T, QuizAttemptFindFirstArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuizAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuizAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany()
     * 
     * // Get first 10 QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizAttemptFindManyArgs>(args?: SelectSubset<T, QuizAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuizAttempt.
     * @param {QuizAttemptCreateArgs} args - Arguments to create a QuizAttempt.
     * @example
     * // Create one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.create({
     *   data: {
     *     // ... data to create a QuizAttempt
     *   }
     * })
     * 
     */
    create<T extends QuizAttemptCreateArgs>(args: SelectSubset<T, QuizAttemptCreateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuizAttempts.
     * @param {QuizAttemptCreateManyArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizAttemptCreateManyArgs>(args?: SelectSubset<T, QuizAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizAttempts and returns the data saved in the database.
     * @param {QuizAttemptCreateManyAndReturnArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizAttempts and only return the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuizAttempt.
     * @param {QuizAttemptDeleteArgs} args - Arguments to delete one QuizAttempt.
     * @example
     * // Delete one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.delete({
     *   where: {
     *     // ... filter to delete one QuizAttempt
     *   }
     * })
     * 
     */
    delete<T extends QuizAttemptDeleteArgs>(args: SelectSubset<T, QuizAttemptDeleteArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuizAttempt.
     * @param {QuizAttemptUpdateArgs} args - Arguments to update one QuizAttempt.
     * @example
     * // Update one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizAttemptUpdateArgs>(args: SelectSubset<T, QuizAttemptUpdateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuizAttempts.
     * @param {QuizAttemptDeleteManyArgs} args - Arguments to filter QuizAttempts to delete.
     * @example
     * // Delete a few QuizAttempts
     * const { count } = await prisma.quizAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizAttemptDeleteManyArgs>(args?: SelectSubset<T, QuizAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizAttemptUpdateManyArgs>(args: SelectSubset<T, QuizAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizAttempt.
     * @param {QuizAttemptUpsertArgs} args - Arguments to update or create a QuizAttempt.
     * @example
     * // Update or create a QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.upsert({
     *   create: {
     *     // ... data to create a QuizAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizAttempt we want to update
     *   }
     * })
     */
    upsert<T extends QuizAttemptUpsertArgs>(args: SelectSubset<T, QuizAttemptUpsertArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptCountArgs} args - Arguments to filter QuizAttempts to count.
     * @example
     * // Count the number of QuizAttempts
     * const count = await prisma.quizAttempt.count({
     *   where: {
     *     // ... the filter for the QuizAttempts we want to count
     *   }
     * })
    **/
    count<T extends QuizAttemptCountArgs>(
      args?: Subset<T, QuizAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAttemptAggregateArgs>(args: Subset<T, QuizAttemptAggregateArgs>): Prisma.PrismaPromise<GetQuizAttemptAggregateType<T>>

    /**
     * Group by QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizAttemptGroupByArgs['orderBy'] }
        : { orderBy?: QuizAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizAttempt model
   */
  readonly fields: QuizAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizAttempt model
   */ 
  interface QuizAttemptFieldRefs {
    readonly id: FieldRef<"QuizAttempt", 'Int'>
    readonly userId: FieldRef<"QuizAttempt", 'Int'>
    readonly quizId: FieldRef<"QuizAttempt", 'Int'>
    readonly answers: FieldRef<"QuizAttempt", 'String'>
    readonly score: FieldRef<"QuizAttempt", 'Int'>
    readonly totalQuestions: FieldRef<"QuizAttempt", 'Int'>
    readonly correctAnswers: FieldRef<"QuizAttempt", 'Int'>
    readonly percentage: FieldRef<"QuizAttempt", 'Int'>
    readonly timeSpent: FieldRef<"QuizAttempt", 'Int'>
    readonly detailedResults: FieldRef<"QuizAttempt", 'String'>
    readonly completedAt: FieldRef<"QuizAttempt", 'DateTime'>
    readonly scoreReleasedAt: FieldRef<"QuizAttempt", 'DateTime'>
    readonly endReason: FieldRef<"QuizAttempt", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuizAttempt findUnique
   */
  export type QuizAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findUniqueOrThrow
   */
  export type QuizAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findFirst
   */
  export type QuizAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findFirstOrThrow
   */
  export type QuizAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findMany
   */
  export type QuizAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempts to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt create
   */
  export type QuizAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizAttempt.
     */
    data: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
  }

  /**
   * QuizAttempt createMany
   */
  export type QuizAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizAttempt createManyAndReturn
   */
  export type QuizAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAttempt update
   */
  export type QuizAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizAttempt.
     */
    data: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
    /**
     * Choose, which QuizAttempt to update.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt updateMany
   */
  export type QuizAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizAttempts.
     */
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuizAttempts to update
     */
    where?: QuizAttemptWhereInput
  }

  /**
   * QuizAttempt upsert
   */
  export type QuizAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizAttempt to update in case it exists.
     */
    where: QuizAttemptWhereUniqueInput
    /**
     * In case the QuizAttempt found by the `where` argument doesn't exist, create a new QuizAttempt with this data.
     */
    create: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
    /**
     * In case the QuizAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
  }

  /**
   * QuizAttempt delete
   */
  export type QuizAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter which QuizAttempt to delete.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt deleteMany
   */
  export type QuizAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempts to delete
     */
    where?: QuizAttemptWhereInput
  }

  /**
   * QuizAttempt without action
   */
  export type QuizAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: number | null
    userId: number | null
    fullName: string | null
    firstName: string | null
    lastName: string | null
    nickname: string | null
    headline: string | null
    jobTitle: string | null
    company: string | null
    grade: string | null
    school: string | null
    bio: string | null
    avatar: string | null
    website: string | null
    location: string | null
    phone: string | null
    linkedin: string | null
    github: string | null
    twitter: string | null
    preferences: string | null
    learningGoals: string | null
    timezone: string | null
    language: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    fullName: string | null
    firstName: string | null
    lastName: string | null
    nickname: string | null
    headline: string | null
    jobTitle: string | null
    company: string | null
    grade: string | null
    school: string | null
    bio: string | null
    avatar: string | null
    website: string | null
    location: string | null
    phone: string | null
    linkedin: string | null
    github: string | null
    twitter: string | null
    preferences: string | null
    learningGoals: string | null
    timezone: string | null
    language: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    fullName: number
    firstName: number
    lastName: number
    nickname: number
    headline: number
    jobTitle: number
    company: number
    grade: number
    school: number
    bio: number
    avatar: number
    website: number
    location: number
    phone: number
    linkedin: number
    github: number
    twitter: number
    preferences: number
    learningGoals: number
    timezone: number
    language: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProfileSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    firstName?: true
    lastName?: true
    nickname?: true
    headline?: true
    jobTitle?: true
    company?: true
    grade?: true
    school?: true
    bio?: true
    avatar?: true
    website?: true
    location?: true
    phone?: true
    linkedin?: true
    github?: true
    twitter?: true
    preferences?: true
    learningGoals?: true
    timezone?: true
    language?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    firstName?: true
    lastName?: true
    nickname?: true
    headline?: true
    jobTitle?: true
    company?: true
    grade?: true
    school?: true
    bio?: true
    avatar?: true
    website?: true
    location?: true
    phone?: true
    linkedin?: true
    github?: true
    twitter?: true
    preferences?: true
    learningGoals?: true
    timezone?: true
    language?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    firstName?: true
    lastName?: true
    nickname?: true
    headline?: true
    jobTitle?: true
    company?: true
    grade?: true
    school?: true
    bio?: true
    avatar?: true
    website?: true
    location?: true
    phone?: true
    linkedin?: true
    github?: true
    twitter?: true
    preferences?: true
    learningGoals?: true
    timezone?: true
    language?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: number
    userId: number
    fullName: string | null
    firstName: string | null
    lastName: string | null
    nickname: string | null
    headline: string | null
    jobTitle: string | null
    company: string | null
    grade: string | null
    school: string | null
    bio: string | null
    avatar: string | null
    website: string | null
    location: string | null
    phone: string | null
    linkedin: string | null
    github: string | null
    twitter: string | null
    preferences: string | null
    learningGoals: string | null
    timezone: string | null
    language: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    firstName?: boolean
    lastName?: boolean
    nickname?: boolean
    headline?: boolean
    jobTitle?: boolean
    company?: boolean
    grade?: boolean
    school?: boolean
    bio?: boolean
    avatar?: boolean
    website?: boolean
    location?: boolean
    phone?: boolean
    linkedin?: boolean
    github?: boolean
    twitter?: boolean
    preferences?: boolean
    learningGoals?: boolean
    timezone?: boolean
    language?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    firstName?: boolean
    lastName?: boolean
    nickname?: boolean
    headline?: boolean
    jobTitle?: boolean
    company?: boolean
    grade?: boolean
    school?: boolean
    bio?: boolean
    avatar?: boolean
    website?: boolean
    location?: boolean
    phone?: boolean
    linkedin?: boolean
    github?: boolean
    twitter?: boolean
    preferences?: boolean
    learningGoals?: boolean
    timezone?: boolean
    language?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    fullName?: boolean
    firstName?: boolean
    lastName?: boolean
    nickname?: boolean
    headline?: boolean
    jobTitle?: boolean
    company?: boolean
    grade?: boolean
    school?: boolean
    bio?: boolean
    avatar?: boolean
    website?: boolean
    location?: boolean
    phone?: boolean
    linkedin?: boolean
    github?: boolean
    twitter?: boolean
    preferences?: boolean
    learningGoals?: boolean
    timezone?: boolean
    language?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      fullName: string | null
      firstName: string | null
      lastName: string | null
      nickname: string | null
      headline: string | null
      jobTitle: string | null
      company: string | null
      grade: string | null
      school: string | null
      bio: string | null
      avatar: string | null
      website: string | null
      location: string | null
      phone: string | null
      linkedin: string | null
      github: string | null
      twitter: string | null
      preferences: string | null
      learningGoals: string | null
      timezone: string | null
      language: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'Int'>
    readonly userId: FieldRef<"Profile", 'Int'>
    readonly fullName: FieldRef<"Profile", 'String'>
    readonly firstName: FieldRef<"Profile", 'String'>
    readonly lastName: FieldRef<"Profile", 'String'>
    readonly nickname: FieldRef<"Profile", 'String'>
    readonly headline: FieldRef<"Profile", 'String'>
    readonly jobTitle: FieldRef<"Profile", 'String'>
    readonly company: FieldRef<"Profile", 'String'>
    readonly grade: FieldRef<"Profile", 'String'>
    readonly school: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly avatar: FieldRef<"Profile", 'String'>
    readonly website: FieldRef<"Profile", 'String'>
    readonly location: FieldRef<"Profile", 'String'>
    readonly phone: FieldRef<"Profile", 'String'>
    readonly linkedin: FieldRef<"Profile", 'String'>
    readonly github: FieldRef<"Profile", 'String'>
    readonly twitter: FieldRef<"Profile", 'String'>
    readonly preferences: FieldRef<"Profile", 'String'>
    readonly learningGoals: FieldRef<"Profile", 'String'>
    readonly timezone: FieldRef<"Profile", 'String'>
    readonly language: FieldRef<"Profile", 'String'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    id: number | null
    userId: number | null
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    id?: true
    userId?: true
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    id?: true
    userId?: true
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: number
    userId: number
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'Int'>
    readonly userId: FieldRef<"Account", 'Int'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    sessionToken: string | null
    userId: number | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    sessionToken: string | null
    userId: number | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: number
    sessionToken: string
    userId: number
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionToken: string
      userId: number
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'Int'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({ 
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    usedAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    usedAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    usedAt: number
    _all: number
  }


  export type PasswordResetTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    usedAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    usedAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    usedAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordResetTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordResetTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _avg?: PasswordResetTokenAvgAggregateInputType
    _sum?: PasswordResetTokenSumAggregateInputType
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: number
    userId: number
    token: string
    expiresAt: Date
    usedAt: Date | null
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    usedAt?: boolean
  }

  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      expiresAt: Date
      usedAt: Date | null
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */ 
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'Int'>
    readonly userId: FieldRef<"PasswordResetToken", 'Int'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly usedAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model BlockProgress
   */

  export type AggregateBlockProgress = {
    _count: BlockProgressCountAggregateOutputType | null
    _avg: BlockProgressAvgAggregateOutputType | null
    _sum: BlockProgressSumAggregateOutputType | null
    _min: BlockProgressMinAggregateOutputType | null
    _max: BlockProgressMaxAggregateOutputType | null
  }

  export type BlockProgressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    chapterId: number | null
    score: number | null
    attempts: number | null
  }

  export type BlockProgressSumAggregateOutputType = {
    id: number | null
    userId: number | null
    chapterId: number | null
    score: number | null
    attempts: number | null
  }

  export type BlockProgressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    chapterId: number | null
    blockId: string | null
    blockType: string | null
    completed: boolean | null
    score: number | null
    attempts: number | null
    data: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockProgressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    chapterId: number | null
    blockId: string | null
    blockType: string | null
    completed: boolean | null
    score: number | null
    attempts: number | null
    data: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockProgressCountAggregateOutputType = {
    id: number
    userId: number
    chapterId: number
    blockId: number
    blockType: number
    completed: number
    score: number
    attempts: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlockProgressAvgAggregateInputType = {
    id?: true
    userId?: true
    chapterId?: true
    score?: true
    attempts?: true
  }

  export type BlockProgressSumAggregateInputType = {
    id?: true
    userId?: true
    chapterId?: true
    score?: true
    attempts?: true
  }

  export type BlockProgressMinAggregateInputType = {
    id?: true
    userId?: true
    chapterId?: true
    blockId?: true
    blockType?: true
    completed?: true
    score?: true
    attempts?: true
    data?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    chapterId?: true
    blockId?: true
    blockType?: true
    completed?: true
    score?: true
    attempts?: true
    data?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockProgressCountAggregateInputType = {
    id?: true
    userId?: true
    chapterId?: true
    blockId?: true
    blockType?: true
    completed?: true
    score?: true
    attempts?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlockProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockProgress to aggregate.
     */
    where?: BlockProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockProgresses to fetch.
     */
    orderBy?: BlockProgressOrderByWithRelationInput | BlockProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockProgresses
    **/
    _count?: true | BlockProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockProgressMaxAggregateInputType
  }

  export type GetBlockProgressAggregateType<T extends BlockProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockProgress[P]>
      : GetScalarType<T[P], AggregateBlockProgress[P]>
  }




  export type BlockProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockProgressWhereInput
    orderBy?: BlockProgressOrderByWithAggregationInput | BlockProgressOrderByWithAggregationInput[]
    by: BlockProgressScalarFieldEnum[] | BlockProgressScalarFieldEnum
    having?: BlockProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockProgressCountAggregateInputType | true
    _avg?: BlockProgressAvgAggregateInputType
    _sum?: BlockProgressSumAggregateInputType
    _min?: BlockProgressMinAggregateInputType
    _max?: BlockProgressMaxAggregateInputType
  }

  export type BlockProgressGroupByOutputType = {
    id: number
    userId: number
    chapterId: number
    blockId: string
    blockType: string
    completed: boolean
    score: number | null
    attempts: number
    data: string | null
    createdAt: Date
    updatedAt: Date
    _count: BlockProgressCountAggregateOutputType | null
    _avg: BlockProgressAvgAggregateOutputType | null
    _sum: BlockProgressSumAggregateOutputType | null
    _min: BlockProgressMinAggregateOutputType | null
    _max: BlockProgressMaxAggregateOutputType | null
  }

  type GetBlockProgressGroupByPayload<T extends BlockProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockProgressGroupByOutputType[P]>
            : GetScalarType<T[P], BlockProgressGroupByOutputType[P]>
        }
      >
    >


  export type BlockProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    chapterId?: boolean
    blockId?: boolean
    blockType?: boolean
    completed?: boolean
    score?: boolean
    attempts?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockProgress"]>

  export type BlockProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    chapterId?: boolean
    blockId?: boolean
    blockType?: boolean
    completed?: boolean
    score?: boolean
    attempts?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockProgress"]>

  export type BlockProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    chapterId?: boolean
    blockId?: boolean
    blockType?: boolean
    completed?: boolean
    score?: boolean
    attempts?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlockProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type BlockProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }

  export type $BlockProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      chapter: Prisma.$ChapterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      chapterId: number
      blockId: string
      blockType: string
      completed: boolean
      score: number | null
      attempts: number
      data: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blockProgress"]>
    composites: {}
  }

  type BlockProgressGetPayload<S extends boolean | null | undefined | BlockProgressDefaultArgs> = $Result.GetResult<Prisma.$BlockProgressPayload, S>

  type BlockProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockProgressCountAggregateInputType | true
    }

  export interface BlockProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockProgress'], meta: { name: 'BlockProgress' } }
    /**
     * Find zero or one BlockProgress that matches the filter.
     * @param {BlockProgressFindUniqueArgs} args - Arguments to find a BlockProgress
     * @example
     * // Get one BlockProgress
     * const blockProgress = await prisma.blockProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockProgressFindUniqueArgs>(args: SelectSubset<T, BlockProgressFindUniqueArgs<ExtArgs>>): Prisma__BlockProgressClient<$Result.GetResult<Prisma.$BlockProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlockProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockProgressFindUniqueOrThrowArgs} args - Arguments to find a BlockProgress
     * @example
     * // Get one BlockProgress
     * const blockProgress = await prisma.blockProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockProgressClient<$Result.GetResult<Prisma.$BlockProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlockProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressFindFirstArgs} args - Arguments to find a BlockProgress
     * @example
     * // Get one BlockProgress
     * const blockProgress = await prisma.blockProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockProgressFindFirstArgs>(args?: SelectSubset<T, BlockProgressFindFirstArgs<ExtArgs>>): Prisma__BlockProgressClient<$Result.GetResult<Prisma.$BlockProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlockProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressFindFirstOrThrowArgs} args - Arguments to find a BlockProgress
     * @example
     * // Get one BlockProgress
     * const blockProgress = await prisma.blockProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockProgressClient<$Result.GetResult<Prisma.$BlockProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlockProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockProgresses
     * const blockProgresses = await prisma.blockProgress.findMany()
     * 
     * // Get first 10 BlockProgresses
     * const blockProgresses = await prisma.blockProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockProgressWithIdOnly = await prisma.blockProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockProgressFindManyArgs>(args?: SelectSubset<T, BlockProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlockProgress.
     * @param {BlockProgressCreateArgs} args - Arguments to create a BlockProgress.
     * @example
     * // Create one BlockProgress
     * const BlockProgress = await prisma.blockProgress.create({
     *   data: {
     *     // ... data to create a BlockProgress
     *   }
     * })
     * 
     */
    create<T extends BlockProgressCreateArgs>(args: SelectSubset<T, BlockProgressCreateArgs<ExtArgs>>): Prisma__BlockProgressClient<$Result.GetResult<Prisma.$BlockProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlockProgresses.
     * @param {BlockProgressCreateManyArgs} args - Arguments to create many BlockProgresses.
     * @example
     * // Create many BlockProgresses
     * const blockProgress = await prisma.blockProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockProgressCreateManyArgs>(args?: SelectSubset<T, BlockProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockProgresses and returns the data saved in the database.
     * @param {BlockProgressCreateManyAndReturnArgs} args - Arguments to create many BlockProgresses.
     * @example
     * // Create many BlockProgresses
     * const blockProgress = await prisma.blockProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockProgresses and only return the `id`
     * const blockProgressWithIdOnly = await prisma.blockProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlockProgress.
     * @param {BlockProgressDeleteArgs} args - Arguments to delete one BlockProgress.
     * @example
     * // Delete one BlockProgress
     * const BlockProgress = await prisma.blockProgress.delete({
     *   where: {
     *     // ... filter to delete one BlockProgress
     *   }
     * })
     * 
     */
    delete<T extends BlockProgressDeleteArgs>(args: SelectSubset<T, BlockProgressDeleteArgs<ExtArgs>>): Prisma__BlockProgressClient<$Result.GetResult<Prisma.$BlockProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlockProgress.
     * @param {BlockProgressUpdateArgs} args - Arguments to update one BlockProgress.
     * @example
     * // Update one BlockProgress
     * const blockProgress = await prisma.blockProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockProgressUpdateArgs>(args: SelectSubset<T, BlockProgressUpdateArgs<ExtArgs>>): Prisma__BlockProgressClient<$Result.GetResult<Prisma.$BlockProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlockProgresses.
     * @param {BlockProgressDeleteManyArgs} args - Arguments to filter BlockProgresses to delete.
     * @example
     * // Delete a few BlockProgresses
     * const { count } = await prisma.blockProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockProgressDeleteManyArgs>(args?: SelectSubset<T, BlockProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockProgresses
     * const blockProgress = await prisma.blockProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockProgressUpdateManyArgs>(args: SelectSubset<T, BlockProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockProgress.
     * @param {BlockProgressUpsertArgs} args - Arguments to update or create a BlockProgress.
     * @example
     * // Update or create a BlockProgress
     * const blockProgress = await prisma.blockProgress.upsert({
     *   create: {
     *     // ... data to create a BlockProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockProgress we want to update
     *   }
     * })
     */
    upsert<T extends BlockProgressUpsertArgs>(args: SelectSubset<T, BlockProgressUpsertArgs<ExtArgs>>): Prisma__BlockProgressClient<$Result.GetResult<Prisma.$BlockProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlockProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressCountArgs} args - Arguments to filter BlockProgresses to count.
     * @example
     * // Count the number of BlockProgresses
     * const count = await prisma.blockProgress.count({
     *   where: {
     *     // ... the filter for the BlockProgresses we want to count
     *   }
     * })
    **/
    count<T extends BlockProgressCountArgs>(
      args?: Subset<T, BlockProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockProgressAggregateArgs>(args: Subset<T, BlockProgressAggregateArgs>): Prisma.PrismaPromise<GetBlockProgressAggregateType<T>>

    /**
     * Group by BlockProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockProgressGroupByArgs['orderBy'] }
        : { orderBy?: BlockProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockProgress model
   */
  readonly fields: BlockProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockProgress model
   */ 
  interface BlockProgressFieldRefs {
    readonly id: FieldRef<"BlockProgress", 'Int'>
    readonly userId: FieldRef<"BlockProgress", 'Int'>
    readonly chapterId: FieldRef<"BlockProgress", 'Int'>
    readonly blockId: FieldRef<"BlockProgress", 'String'>
    readonly blockType: FieldRef<"BlockProgress", 'String'>
    readonly completed: FieldRef<"BlockProgress", 'Boolean'>
    readonly score: FieldRef<"BlockProgress", 'Float'>
    readonly attempts: FieldRef<"BlockProgress", 'Int'>
    readonly data: FieldRef<"BlockProgress", 'String'>
    readonly createdAt: FieldRef<"BlockProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"BlockProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockProgress findUnique
   */
  export type BlockProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgress
     */
    select?: BlockProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressInclude<ExtArgs> | null
    /**
     * Filter, which BlockProgress to fetch.
     */
    where: BlockProgressWhereUniqueInput
  }

  /**
   * BlockProgress findUniqueOrThrow
   */
  export type BlockProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgress
     */
    select?: BlockProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressInclude<ExtArgs> | null
    /**
     * Filter, which BlockProgress to fetch.
     */
    where: BlockProgressWhereUniqueInput
  }

  /**
   * BlockProgress findFirst
   */
  export type BlockProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgress
     */
    select?: BlockProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressInclude<ExtArgs> | null
    /**
     * Filter, which BlockProgress to fetch.
     */
    where?: BlockProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockProgresses to fetch.
     */
    orderBy?: BlockProgressOrderByWithRelationInput | BlockProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockProgresses.
     */
    cursor?: BlockProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockProgresses.
     */
    distinct?: BlockProgressScalarFieldEnum | BlockProgressScalarFieldEnum[]
  }

  /**
   * BlockProgress findFirstOrThrow
   */
  export type BlockProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgress
     */
    select?: BlockProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressInclude<ExtArgs> | null
    /**
     * Filter, which BlockProgress to fetch.
     */
    where?: BlockProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockProgresses to fetch.
     */
    orderBy?: BlockProgressOrderByWithRelationInput | BlockProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockProgresses.
     */
    cursor?: BlockProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockProgresses.
     */
    distinct?: BlockProgressScalarFieldEnum | BlockProgressScalarFieldEnum[]
  }

  /**
   * BlockProgress findMany
   */
  export type BlockProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgress
     */
    select?: BlockProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressInclude<ExtArgs> | null
    /**
     * Filter, which BlockProgresses to fetch.
     */
    where?: BlockProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockProgresses to fetch.
     */
    orderBy?: BlockProgressOrderByWithRelationInput | BlockProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockProgresses.
     */
    cursor?: BlockProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockProgresses.
     */
    skip?: number
    distinct?: BlockProgressScalarFieldEnum | BlockProgressScalarFieldEnum[]
  }

  /**
   * BlockProgress create
   */
  export type BlockProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgress
     */
    select?: BlockProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockProgress.
     */
    data: XOR<BlockProgressCreateInput, BlockProgressUncheckedCreateInput>
  }

  /**
   * BlockProgress createMany
   */
  export type BlockProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockProgresses.
     */
    data: BlockProgressCreateManyInput | BlockProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockProgress createManyAndReturn
   */
  export type BlockProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgress
     */
    select?: BlockProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlockProgresses.
     */
    data: BlockProgressCreateManyInput | BlockProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockProgress update
   */
  export type BlockProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgress
     */
    select?: BlockProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockProgress.
     */
    data: XOR<BlockProgressUpdateInput, BlockProgressUncheckedUpdateInput>
    /**
     * Choose, which BlockProgress to update.
     */
    where: BlockProgressWhereUniqueInput
  }

  /**
   * BlockProgress updateMany
   */
  export type BlockProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockProgresses.
     */
    data: XOR<BlockProgressUpdateManyMutationInput, BlockProgressUncheckedUpdateManyInput>
    /**
     * Filter which BlockProgresses to update
     */
    where?: BlockProgressWhereInput
  }

  /**
   * BlockProgress upsert
   */
  export type BlockProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgress
     */
    select?: BlockProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockProgress to update in case it exists.
     */
    where: BlockProgressWhereUniqueInput
    /**
     * In case the BlockProgress found by the `where` argument doesn't exist, create a new BlockProgress with this data.
     */
    create: XOR<BlockProgressCreateInput, BlockProgressUncheckedCreateInput>
    /**
     * In case the BlockProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockProgressUpdateInput, BlockProgressUncheckedUpdateInput>
  }

  /**
   * BlockProgress delete
   */
  export type BlockProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgress
     */
    select?: BlockProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressInclude<ExtArgs> | null
    /**
     * Filter which BlockProgress to delete.
     */
    where: BlockProgressWhereUniqueInput
  }

  /**
   * BlockProgress deleteMany
   */
  export type BlockProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockProgresses to delete
     */
    where?: BlockProgressWhereInput
  }

  /**
   * BlockProgress without action
   */
  export type BlockProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockProgress
     */
    select?: BlockProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockProgressInclude<ExtArgs> | null
  }


  /**
   * Model Classroom
   */

  export type AggregateClassroom = {
    _count: ClassroomCountAggregateOutputType | null
    _avg: ClassroomAvgAggregateOutputType | null
    _sum: ClassroomSumAggregateOutputType | null
    _min: ClassroomMinAggregateOutputType | null
    _max: ClassroomMaxAggregateOutputType | null
  }

  export type ClassroomAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type ClassroomSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type ClassroomMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    isPrivate: boolean | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassroomMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    isPrivate: boolean | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassroomCountAggregateOutputType = {
    id: number
    title: number
    description: number
    isPrivate: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassroomAvgAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type ClassroomSumAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type ClassroomMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isPrivate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassroomMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isPrivate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassroomCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isPrivate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassroomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classroom to aggregate.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classrooms
    **/
    _count?: true | ClassroomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassroomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassroomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassroomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassroomMaxAggregateInputType
  }

  export type GetClassroomAggregateType<T extends ClassroomAggregateArgs> = {
        [P in keyof T & keyof AggregateClassroom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassroom[P]>
      : GetScalarType<T[P], AggregateClassroom[P]>
  }




  export type ClassroomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomWhereInput
    orderBy?: ClassroomOrderByWithAggregationInput | ClassroomOrderByWithAggregationInput[]
    by: ClassroomScalarFieldEnum[] | ClassroomScalarFieldEnum
    having?: ClassroomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassroomCountAggregateInputType | true
    _avg?: ClassroomAvgAggregateInputType
    _sum?: ClassroomSumAggregateInputType
    _min?: ClassroomMinAggregateInputType
    _max?: ClassroomMaxAggregateInputType
  }

  export type ClassroomGroupByOutputType = {
    id: number
    title: string
    description: string | null
    isPrivate: boolean
    createdBy: number
    createdAt: Date
    updatedAt: Date
    _count: ClassroomCountAggregateOutputType | null
    _avg: ClassroomAvgAggregateOutputType | null
    _sum: ClassroomSumAggregateOutputType | null
    _min: ClassroomMinAggregateOutputType | null
    _max: ClassroomMaxAggregateOutputType | null
  }

  type GetClassroomGroupByPayload<T extends ClassroomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassroomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassroomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassroomGroupByOutputType[P]>
            : GetScalarType<T[P], ClassroomGroupByOutputType[P]>
        }
      >
    >


  export type ClassroomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isPrivate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    memberships?: boolean | Classroom$membershipsArgs<ExtArgs>
    posts?: boolean | Classroom$postsArgs<ExtArgs>
    resources?: boolean | Classroom$resourcesArgs<ExtArgs>
    _count?: boolean | ClassroomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroom"]>

  export type ClassroomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isPrivate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroom"]>

  export type ClassroomSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    isPrivate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassroomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    memberships?: boolean | Classroom$membershipsArgs<ExtArgs>
    posts?: boolean | Classroom$postsArgs<ExtArgs>
    resources?: boolean | Classroom$resourcesArgs<ExtArgs>
    _count?: boolean | ClassroomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassroomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClassroomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Classroom"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      memberships: Prisma.$ClassroomMembershipPayload<ExtArgs>[]
      posts: Prisma.$ClassroomPostPayload<ExtArgs>[]
      resources: Prisma.$ClassroomResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      isPrivate: boolean
      createdBy: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["classroom"]>
    composites: {}
  }

  type ClassroomGetPayload<S extends boolean | null | undefined | ClassroomDefaultArgs> = $Result.GetResult<Prisma.$ClassroomPayload, S>

  type ClassroomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassroomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassroomCountAggregateInputType | true
    }

  export interface ClassroomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Classroom'], meta: { name: 'Classroom' } }
    /**
     * Find zero or one Classroom that matches the filter.
     * @param {ClassroomFindUniqueArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassroomFindUniqueArgs>(args: SelectSubset<T, ClassroomFindUniqueArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Classroom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassroomFindUniqueOrThrowArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassroomFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassroomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Classroom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomFindFirstArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassroomFindFirstArgs>(args?: SelectSubset<T, ClassroomFindFirstArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Classroom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomFindFirstOrThrowArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassroomFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassroomFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Classrooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classrooms
     * const classrooms = await prisma.classroom.findMany()
     * 
     * // Get first 10 Classrooms
     * const classrooms = await prisma.classroom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classroomWithIdOnly = await prisma.classroom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassroomFindManyArgs>(args?: SelectSubset<T, ClassroomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Classroom.
     * @param {ClassroomCreateArgs} args - Arguments to create a Classroom.
     * @example
     * // Create one Classroom
     * const Classroom = await prisma.classroom.create({
     *   data: {
     *     // ... data to create a Classroom
     *   }
     * })
     * 
     */
    create<T extends ClassroomCreateArgs>(args: SelectSubset<T, ClassroomCreateArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Classrooms.
     * @param {ClassroomCreateManyArgs} args - Arguments to create many Classrooms.
     * @example
     * // Create many Classrooms
     * const classroom = await prisma.classroom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassroomCreateManyArgs>(args?: SelectSubset<T, ClassroomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classrooms and returns the data saved in the database.
     * @param {ClassroomCreateManyAndReturnArgs} args - Arguments to create many Classrooms.
     * @example
     * // Create many Classrooms
     * const classroom = await prisma.classroom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classrooms and only return the `id`
     * const classroomWithIdOnly = await prisma.classroom.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassroomCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassroomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Classroom.
     * @param {ClassroomDeleteArgs} args - Arguments to delete one Classroom.
     * @example
     * // Delete one Classroom
     * const Classroom = await prisma.classroom.delete({
     *   where: {
     *     // ... filter to delete one Classroom
     *   }
     * })
     * 
     */
    delete<T extends ClassroomDeleteArgs>(args: SelectSubset<T, ClassroomDeleteArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Classroom.
     * @param {ClassroomUpdateArgs} args - Arguments to update one Classroom.
     * @example
     * // Update one Classroom
     * const classroom = await prisma.classroom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassroomUpdateArgs>(args: SelectSubset<T, ClassroomUpdateArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Classrooms.
     * @param {ClassroomDeleteManyArgs} args - Arguments to filter Classrooms to delete.
     * @example
     * // Delete a few Classrooms
     * const { count } = await prisma.classroom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassroomDeleteManyArgs>(args?: SelectSubset<T, ClassroomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classrooms
     * const classroom = await prisma.classroom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassroomUpdateManyArgs>(args: SelectSubset<T, ClassroomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Classroom.
     * @param {ClassroomUpsertArgs} args - Arguments to update or create a Classroom.
     * @example
     * // Update or create a Classroom
     * const classroom = await prisma.classroom.upsert({
     *   create: {
     *     // ... data to create a Classroom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classroom we want to update
     *   }
     * })
     */
    upsert<T extends ClassroomUpsertArgs>(args: SelectSubset<T, ClassroomUpsertArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomCountArgs} args - Arguments to filter Classrooms to count.
     * @example
     * // Count the number of Classrooms
     * const count = await prisma.classroom.count({
     *   where: {
     *     // ... the filter for the Classrooms we want to count
     *   }
     * })
    **/
    count<T extends ClassroomCountArgs>(
      args?: Subset<T, ClassroomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassroomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassroomAggregateArgs>(args: Subset<T, ClassroomAggregateArgs>): Prisma.PrismaPromise<GetClassroomAggregateType<T>>

    /**
     * Group by Classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassroomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassroomGroupByArgs['orderBy'] }
        : { orderBy?: ClassroomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassroomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassroomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Classroom model
   */
  readonly fields: ClassroomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Classroom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassroomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    memberships<T extends Classroom$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Classroom$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomMembershipPayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends Classroom$postsArgs<ExtArgs> = {}>(args?: Subset<T, Classroom$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPostPayload<ExtArgs>, T, "findMany"> | Null>
    resources<T extends Classroom$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, Classroom$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Classroom model
   */ 
  interface ClassroomFieldRefs {
    readonly id: FieldRef<"Classroom", 'Int'>
    readonly title: FieldRef<"Classroom", 'String'>
    readonly description: FieldRef<"Classroom", 'String'>
    readonly isPrivate: FieldRef<"Classroom", 'Boolean'>
    readonly createdBy: FieldRef<"Classroom", 'Int'>
    readonly createdAt: FieldRef<"Classroom", 'DateTime'>
    readonly updatedAt: FieldRef<"Classroom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Classroom findUnique
   */
  export type ClassroomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where: ClassroomWhereUniqueInput
  }

  /**
   * Classroom findUniqueOrThrow
   */
  export type ClassroomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where: ClassroomWhereUniqueInput
  }

  /**
   * Classroom findFirst
   */
  export type ClassroomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classrooms.
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classrooms.
     */
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * Classroom findFirstOrThrow
   */
  export type ClassroomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classrooms.
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classrooms.
     */
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * Classroom findMany
   */
  export type ClassroomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classrooms to fetch.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classrooms.
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * Classroom create
   */
  export type ClassroomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * The data needed to create a Classroom.
     */
    data: XOR<ClassroomCreateInput, ClassroomUncheckedCreateInput>
  }

  /**
   * Classroom createMany
   */
  export type ClassroomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classrooms.
     */
    data: ClassroomCreateManyInput | ClassroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Classroom createManyAndReturn
   */
  export type ClassroomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Classrooms.
     */
    data: ClassroomCreateManyInput | ClassroomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Classroom update
   */
  export type ClassroomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * The data needed to update a Classroom.
     */
    data: XOR<ClassroomUpdateInput, ClassroomUncheckedUpdateInput>
    /**
     * Choose, which Classroom to update.
     */
    where: ClassroomWhereUniqueInput
  }

  /**
   * Classroom updateMany
   */
  export type ClassroomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classrooms.
     */
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyInput>
    /**
     * Filter which Classrooms to update
     */
    where?: ClassroomWhereInput
  }

  /**
   * Classroom upsert
   */
  export type ClassroomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * The filter to search for the Classroom to update in case it exists.
     */
    where: ClassroomWhereUniqueInput
    /**
     * In case the Classroom found by the `where` argument doesn't exist, create a new Classroom with this data.
     */
    create: XOR<ClassroomCreateInput, ClassroomUncheckedCreateInput>
    /**
     * In case the Classroom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassroomUpdateInput, ClassroomUncheckedUpdateInput>
  }

  /**
   * Classroom delete
   */
  export type ClassroomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter which Classroom to delete.
     */
    where: ClassroomWhereUniqueInput
  }

  /**
   * Classroom deleteMany
   */
  export type ClassroomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classrooms to delete
     */
    where?: ClassroomWhereInput
  }

  /**
   * Classroom.memberships
   */
  export type Classroom$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomMembership
     */
    select?: ClassroomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomMembershipInclude<ExtArgs> | null
    where?: ClassroomMembershipWhereInput
    orderBy?: ClassroomMembershipOrderByWithRelationInput | ClassroomMembershipOrderByWithRelationInput[]
    cursor?: ClassroomMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomMembershipScalarFieldEnum | ClassroomMembershipScalarFieldEnum[]
  }

  /**
   * Classroom.posts
   */
  export type Classroom$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPost
     */
    select?: ClassroomPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomPostInclude<ExtArgs> | null
    where?: ClassroomPostWhereInput
    orderBy?: ClassroomPostOrderByWithRelationInput | ClassroomPostOrderByWithRelationInput[]
    cursor?: ClassroomPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomPostScalarFieldEnum | ClassroomPostScalarFieldEnum[]
  }

  /**
   * Classroom.resources
   */
  export type Classroom$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
    where?: ClassroomResourceWhereInput
    orderBy?: ClassroomResourceOrderByWithRelationInput | ClassroomResourceOrderByWithRelationInput[]
    cursor?: ClassroomResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomResourceScalarFieldEnum | ClassroomResourceScalarFieldEnum[]
  }

  /**
   * Classroom without action
   */
  export type ClassroomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
  }


  /**
   * Model ClassroomMembership
   */

  export type AggregateClassroomMembership = {
    _count: ClassroomMembershipCountAggregateOutputType | null
    _avg: ClassroomMembershipAvgAggregateOutputType | null
    _sum: ClassroomMembershipSumAggregateOutputType | null
    _min: ClassroomMembershipMinAggregateOutputType | null
    _max: ClassroomMembershipMaxAggregateOutputType | null
  }

  export type ClassroomMembershipAvgAggregateOutputType = {
    id: number | null
    classroomId: number | null
    userId: number | null
  }

  export type ClassroomMembershipSumAggregateOutputType = {
    id: number | null
    classroomId: number | null
    userId: number | null
  }

  export type ClassroomMembershipMinAggregateOutputType = {
    id: number | null
    classroomId: number | null
    userId: number | null
    role: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ClassroomMembershipMaxAggregateOutputType = {
    id: number | null
    classroomId: number | null
    userId: number | null
    role: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ClassroomMembershipCountAggregateOutputType = {
    id: number
    classroomId: number
    userId: number
    role: number
    status: number
    createdAt: number
    _all: number
  }


  export type ClassroomMembershipAvgAggregateInputType = {
    id?: true
    classroomId?: true
    userId?: true
  }

  export type ClassroomMembershipSumAggregateInputType = {
    id?: true
    classroomId?: true
    userId?: true
  }

  export type ClassroomMembershipMinAggregateInputType = {
    id?: true
    classroomId?: true
    userId?: true
    role?: true
    status?: true
    createdAt?: true
  }

  export type ClassroomMembershipMaxAggregateInputType = {
    id?: true
    classroomId?: true
    userId?: true
    role?: true
    status?: true
    createdAt?: true
  }

  export type ClassroomMembershipCountAggregateInputType = {
    id?: true
    classroomId?: true
    userId?: true
    role?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ClassroomMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassroomMembership to aggregate.
     */
    where?: ClassroomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomMemberships to fetch.
     */
    orderBy?: ClassroomMembershipOrderByWithRelationInput | ClassroomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassroomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassroomMemberships
    **/
    _count?: true | ClassroomMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassroomMembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassroomMembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassroomMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassroomMembershipMaxAggregateInputType
  }

  export type GetClassroomMembershipAggregateType<T extends ClassroomMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateClassroomMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassroomMembership[P]>
      : GetScalarType<T[P], AggregateClassroomMembership[P]>
  }




  export type ClassroomMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomMembershipWhereInput
    orderBy?: ClassroomMembershipOrderByWithAggregationInput | ClassroomMembershipOrderByWithAggregationInput[]
    by: ClassroomMembershipScalarFieldEnum[] | ClassroomMembershipScalarFieldEnum
    having?: ClassroomMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassroomMembershipCountAggregateInputType | true
    _avg?: ClassroomMembershipAvgAggregateInputType
    _sum?: ClassroomMembershipSumAggregateInputType
    _min?: ClassroomMembershipMinAggregateInputType
    _max?: ClassroomMembershipMaxAggregateInputType
  }

  export type ClassroomMembershipGroupByOutputType = {
    id: number
    classroomId: number
    userId: number
    role: string
    status: string
    createdAt: Date
    _count: ClassroomMembershipCountAggregateOutputType | null
    _avg: ClassroomMembershipAvgAggregateOutputType | null
    _sum: ClassroomMembershipSumAggregateOutputType | null
    _min: ClassroomMembershipMinAggregateOutputType | null
    _max: ClassroomMembershipMaxAggregateOutputType | null
  }

  type GetClassroomMembershipGroupByPayload<T extends ClassroomMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassroomMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassroomMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassroomMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], ClassroomMembershipGroupByOutputType[P]>
        }
      >
    >


  export type ClassroomMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    createdAt?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroomMembership"]>

  export type ClassroomMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    createdAt?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroomMembership"]>

  export type ClassroomMembershipSelectScalar = {
    id?: boolean
    classroomId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ClassroomMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClassroomMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClassroomMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassroomMembership"
    objects: {
      classroom: Prisma.$ClassroomPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      classroomId: number
      userId: number
      role: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["classroomMembership"]>
    composites: {}
  }

  type ClassroomMembershipGetPayload<S extends boolean | null | undefined | ClassroomMembershipDefaultArgs> = $Result.GetResult<Prisma.$ClassroomMembershipPayload, S>

  type ClassroomMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassroomMembershipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassroomMembershipCountAggregateInputType | true
    }

  export interface ClassroomMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassroomMembership'], meta: { name: 'ClassroomMembership' } }
    /**
     * Find zero or one ClassroomMembership that matches the filter.
     * @param {ClassroomMembershipFindUniqueArgs} args - Arguments to find a ClassroomMembership
     * @example
     * // Get one ClassroomMembership
     * const classroomMembership = await prisma.classroomMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassroomMembershipFindUniqueArgs>(args: SelectSubset<T, ClassroomMembershipFindUniqueArgs<ExtArgs>>): Prisma__ClassroomMembershipClient<$Result.GetResult<Prisma.$ClassroomMembershipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClassroomMembership that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassroomMembershipFindUniqueOrThrowArgs} args - Arguments to find a ClassroomMembership
     * @example
     * // Get one ClassroomMembership
     * const classroomMembership = await prisma.classroomMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassroomMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassroomMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassroomMembershipClient<$Result.GetResult<Prisma.$ClassroomMembershipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClassroomMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomMembershipFindFirstArgs} args - Arguments to find a ClassroomMembership
     * @example
     * // Get one ClassroomMembership
     * const classroomMembership = await prisma.classroomMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassroomMembershipFindFirstArgs>(args?: SelectSubset<T, ClassroomMembershipFindFirstArgs<ExtArgs>>): Prisma__ClassroomMembershipClient<$Result.GetResult<Prisma.$ClassroomMembershipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClassroomMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomMembershipFindFirstOrThrowArgs} args - Arguments to find a ClassroomMembership
     * @example
     * // Get one ClassroomMembership
     * const classroomMembership = await prisma.classroomMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassroomMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassroomMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassroomMembershipClient<$Result.GetResult<Prisma.$ClassroomMembershipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClassroomMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassroomMemberships
     * const classroomMemberships = await prisma.classroomMembership.findMany()
     * 
     * // Get first 10 ClassroomMemberships
     * const classroomMemberships = await prisma.classroomMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classroomMembershipWithIdOnly = await prisma.classroomMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassroomMembershipFindManyArgs>(args?: SelectSubset<T, ClassroomMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomMembershipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClassroomMembership.
     * @param {ClassroomMembershipCreateArgs} args - Arguments to create a ClassroomMembership.
     * @example
     * // Create one ClassroomMembership
     * const ClassroomMembership = await prisma.classroomMembership.create({
     *   data: {
     *     // ... data to create a ClassroomMembership
     *   }
     * })
     * 
     */
    create<T extends ClassroomMembershipCreateArgs>(args: SelectSubset<T, ClassroomMembershipCreateArgs<ExtArgs>>): Prisma__ClassroomMembershipClient<$Result.GetResult<Prisma.$ClassroomMembershipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClassroomMemberships.
     * @param {ClassroomMembershipCreateManyArgs} args - Arguments to create many ClassroomMemberships.
     * @example
     * // Create many ClassroomMemberships
     * const classroomMembership = await prisma.classroomMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassroomMembershipCreateManyArgs>(args?: SelectSubset<T, ClassroomMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassroomMemberships and returns the data saved in the database.
     * @param {ClassroomMembershipCreateManyAndReturnArgs} args - Arguments to create many ClassroomMemberships.
     * @example
     * // Create many ClassroomMemberships
     * const classroomMembership = await prisma.classroomMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassroomMemberships and only return the `id`
     * const classroomMembershipWithIdOnly = await prisma.classroomMembership.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassroomMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassroomMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomMembershipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClassroomMembership.
     * @param {ClassroomMembershipDeleteArgs} args - Arguments to delete one ClassroomMembership.
     * @example
     * // Delete one ClassroomMembership
     * const ClassroomMembership = await prisma.classroomMembership.delete({
     *   where: {
     *     // ... filter to delete one ClassroomMembership
     *   }
     * })
     * 
     */
    delete<T extends ClassroomMembershipDeleteArgs>(args: SelectSubset<T, ClassroomMembershipDeleteArgs<ExtArgs>>): Prisma__ClassroomMembershipClient<$Result.GetResult<Prisma.$ClassroomMembershipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClassroomMembership.
     * @param {ClassroomMembershipUpdateArgs} args - Arguments to update one ClassroomMembership.
     * @example
     * // Update one ClassroomMembership
     * const classroomMembership = await prisma.classroomMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassroomMembershipUpdateArgs>(args: SelectSubset<T, ClassroomMembershipUpdateArgs<ExtArgs>>): Prisma__ClassroomMembershipClient<$Result.GetResult<Prisma.$ClassroomMembershipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClassroomMemberships.
     * @param {ClassroomMembershipDeleteManyArgs} args - Arguments to filter ClassroomMemberships to delete.
     * @example
     * // Delete a few ClassroomMemberships
     * const { count } = await prisma.classroomMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassroomMembershipDeleteManyArgs>(args?: SelectSubset<T, ClassroomMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassroomMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassroomMemberships
     * const classroomMembership = await prisma.classroomMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassroomMembershipUpdateManyArgs>(args: SelectSubset<T, ClassroomMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassroomMembership.
     * @param {ClassroomMembershipUpsertArgs} args - Arguments to update or create a ClassroomMembership.
     * @example
     * // Update or create a ClassroomMembership
     * const classroomMembership = await prisma.classroomMembership.upsert({
     *   create: {
     *     // ... data to create a ClassroomMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassroomMembership we want to update
     *   }
     * })
     */
    upsert<T extends ClassroomMembershipUpsertArgs>(args: SelectSubset<T, ClassroomMembershipUpsertArgs<ExtArgs>>): Prisma__ClassroomMembershipClient<$Result.GetResult<Prisma.$ClassroomMembershipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClassroomMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomMembershipCountArgs} args - Arguments to filter ClassroomMemberships to count.
     * @example
     * // Count the number of ClassroomMemberships
     * const count = await prisma.classroomMembership.count({
     *   where: {
     *     // ... the filter for the ClassroomMemberships we want to count
     *   }
     * })
    **/
    count<T extends ClassroomMembershipCountArgs>(
      args?: Subset<T, ClassroomMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassroomMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassroomMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassroomMembershipAggregateArgs>(args: Subset<T, ClassroomMembershipAggregateArgs>): Prisma.PrismaPromise<GetClassroomMembershipAggregateType<T>>

    /**
     * Group by ClassroomMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassroomMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassroomMembershipGroupByArgs['orderBy'] }
        : { orderBy?: ClassroomMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassroomMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassroomMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassroomMembership model
   */
  readonly fields: ClassroomMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassroomMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassroomMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classroom<T extends ClassroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassroomDefaultArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassroomMembership model
   */ 
  interface ClassroomMembershipFieldRefs {
    readonly id: FieldRef<"ClassroomMembership", 'Int'>
    readonly classroomId: FieldRef<"ClassroomMembership", 'Int'>
    readonly userId: FieldRef<"ClassroomMembership", 'Int'>
    readonly role: FieldRef<"ClassroomMembership", 'String'>
    readonly status: FieldRef<"ClassroomMembership", 'String'>
    readonly createdAt: FieldRef<"ClassroomMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClassroomMembership findUnique
   */
  export type ClassroomMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomMembership
     */
    select?: ClassroomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomMembership to fetch.
     */
    where: ClassroomMembershipWhereUniqueInput
  }

  /**
   * ClassroomMembership findUniqueOrThrow
   */
  export type ClassroomMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomMembership
     */
    select?: ClassroomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomMembership to fetch.
     */
    where: ClassroomMembershipWhereUniqueInput
  }

  /**
   * ClassroomMembership findFirst
   */
  export type ClassroomMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomMembership
     */
    select?: ClassroomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomMembership to fetch.
     */
    where?: ClassroomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomMemberships to fetch.
     */
    orderBy?: ClassroomMembershipOrderByWithRelationInput | ClassroomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassroomMemberships.
     */
    cursor?: ClassroomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassroomMemberships.
     */
    distinct?: ClassroomMembershipScalarFieldEnum | ClassroomMembershipScalarFieldEnum[]
  }

  /**
   * ClassroomMembership findFirstOrThrow
   */
  export type ClassroomMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomMembership
     */
    select?: ClassroomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomMembership to fetch.
     */
    where?: ClassroomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomMemberships to fetch.
     */
    orderBy?: ClassroomMembershipOrderByWithRelationInput | ClassroomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassroomMemberships.
     */
    cursor?: ClassroomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassroomMemberships.
     */
    distinct?: ClassroomMembershipScalarFieldEnum | ClassroomMembershipScalarFieldEnum[]
  }

  /**
   * ClassroomMembership findMany
   */
  export type ClassroomMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomMembership
     */
    select?: ClassroomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomMemberships to fetch.
     */
    where?: ClassroomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomMemberships to fetch.
     */
    orderBy?: ClassroomMembershipOrderByWithRelationInput | ClassroomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassroomMemberships.
     */
    cursor?: ClassroomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomMemberships.
     */
    skip?: number
    distinct?: ClassroomMembershipScalarFieldEnum | ClassroomMembershipScalarFieldEnum[]
  }

  /**
   * ClassroomMembership create
   */
  export type ClassroomMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomMembership
     */
    select?: ClassroomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassroomMembership.
     */
    data: XOR<ClassroomMembershipCreateInput, ClassroomMembershipUncheckedCreateInput>
  }

  /**
   * ClassroomMembership createMany
   */
  export type ClassroomMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassroomMemberships.
     */
    data: ClassroomMembershipCreateManyInput | ClassroomMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassroomMembership createManyAndReturn
   */
  export type ClassroomMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomMembership
     */
    select?: ClassroomMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClassroomMemberships.
     */
    data: ClassroomMembershipCreateManyInput | ClassroomMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassroomMembership update
   */
  export type ClassroomMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomMembership
     */
    select?: ClassroomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassroomMembership.
     */
    data: XOR<ClassroomMembershipUpdateInput, ClassroomMembershipUncheckedUpdateInput>
    /**
     * Choose, which ClassroomMembership to update.
     */
    where: ClassroomMembershipWhereUniqueInput
  }

  /**
   * ClassroomMembership updateMany
   */
  export type ClassroomMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassroomMemberships.
     */
    data: XOR<ClassroomMembershipUpdateManyMutationInput, ClassroomMembershipUncheckedUpdateManyInput>
    /**
     * Filter which ClassroomMemberships to update
     */
    where?: ClassroomMembershipWhereInput
  }

  /**
   * ClassroomMembership upsert
   */
  export type ClassroomMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomMembership
     */
    select?: ClassroomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassroomMembership to update in case it exists.
     */
    where: ClassroomMembershipWhereUniqueInput
    /**
     * In case the ClassroomMembership found by the `where` argument doesn't exist, create a new ClassroomMembership with this data.
     */
    create: XOR<ClassroomMembershipCreateInput, ClassroomMembershipUncheckedCreateInput>
    /**
     * In case the ClassroomMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassroomMembershipUpdateInput, ClassroomMembershipUncheckedUpdateInput>
  }

  /**
   * ClassroomMembership delete
   */
  export type ClassroomMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomMembership
     */
    select?: ClassroomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomMembershipInclude<ExtArgs> | null
    /**
     * Filter which ClassroomMembership to delete.
     */
    where: ClassroomMembershipWhereUniqueInput
  }

  /**
   * ClassroomMembership deleteMany
   */
  export type ClassroomMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassroomMemberships to delete
     */
    where?: ClassroomMembershipWhereInput
  }

  /**
   * ClassroomMembership without action
   */
  export type ClassroomMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomMembership
     */
    select?: ClassroomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomMembershipInclude<ExtArgs> | null
  }


  /**
   * Model ClassroomPost
   */

  export type AggregateClassroomPost = {
    _count: ClassroomPostCountAggregateOutputType | null
    _avg: ClassroomPostAvgAggregateOutputType | null
    _sum: ClassroomPostSumAggregateOutputType | null
    _min: ClassroomPostMinAggregateOutputType | null
    _max: ClassroomPostMaxAggregateOutputType | null
  }

  export type ClassroomPostAvgAggregateOutputType = {
    id: number | null
    classroomId: number | null
    authorId: number | null
  }

  export type ClassroomPostSumAggregateOutputType = {
    id: number | null
    classroomId: number | null
    authorId: number | null
  }

  export type ClassroomPostMinAggregateOutputType = {
    id: number | null
    classroomId: number | null
    authorId: number | null
    content: string | null
    pinned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassroomPostMaxAggregateOutputType = {
    id: number | null
    classroomId: number | null
    authorId: number | null
    content: string | null
    pinned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassroomPostCountAggregateOutputType = {
    id: number
    classroomId: number
    authorId: number
    content: number
    pinned: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassroomPostAvgAggregateInputType = {
    id?: true
    classroomId?: true
    authorId?: true
  }

  export type ClassroomPostSumAggregateInputType = {
    id?: true
    classroomId?: true
    authorId?: true
  }

  export type ClassroomPostMinAggregateInputType = {
    id?: true
    classroomId?: true
    authorId?: true
    content?: true
    pinned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassroomPostMaxAggregateInputType = {
    id?: true
    classroomId?: true
    authorId?: true
    content?: true
    pinned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassroomPostCountAggregateInputType = {
    id?: true
    classroomId?: true
    authorId?: true
    content?: true
    pinned?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassroomPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassroomPost to aggregate.
     */
    where?: ClassroomPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomPosts to fetch.
     */
    orderBy?: ClassroomPostOrderByWithRelationInput | ClassroomPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassroomPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassroomPosts
    **/
    _count?: true | ClassroomPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassroomPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassroomPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassroomPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassroomPostMaxAggregateInputType
  }

  export type GetClassroomPostAggregateType<T extends ClassroomPostAggregateArgs> = {
        [P in keyof T & keyof AggregateClassroomPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassroomPost[P]>
      : GetScalarType<T[P], AggregateClassroomPost[P]>
  }




  export type ClassroomPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomPostWhereInput
    orderBy?: ClassroomPostOrderByWithAggregationInput | ClassroomPostOrderByWithAggregationInput[]
    by: ClassroomPostScalarFieldEnum[] | ClassroomPostScalarFieldEnum
    having?: ClassroomPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassroomPostCountAggregateInputType | true
    _avg?: ClassroomPostAvgAggregateInputType
    _sum?: ClassroomPostSumAggregateInputType
    _min?: ClassroomPostMinAggregateInputType
    _max?: ClassroomPostMaxAggregateInputType
  }

  export type ClassroomPostGroupByOutputType = {
    id: number
    classroomId: number
    authorId: number
    content: string
    pinned: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClassroomPostCountAggregateOutputType | null
    _avg: ClassroomPostAvgAggregateOutputType | null
    _sum: ClassroomPostSumAggregateOutputType | null
    _min: ClassroomPostMinAggregateOutputType | null
    _max: ClassroomPostMaxAggregateOutputType | null
  }

  type GetClassroomPostGroupByPayload<T extends ClassroomPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassroomPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassroomPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassroomPostGroupByOutputType[P]>
            : GetScalarType<T[P], ClassroomPostGroupByOutputType[P]>
        }
      >
    >


  export type ClassroomPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    authorId?: boolean
    content?: boolean
    pinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | ClassroomPost$commentsArgs<ExtArgs>
    _count?: boolean | ClassroomPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroomPost"]>

  export type ClassroomPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    authorId?: boolean
    content?: boolean
    pinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroomPost"]>

  export type ClassroomPostSelectScalar = {
    id?: boolean
    classroomId?: boolean
    authorId?: boolean
    content?: boolean
    pinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassroomPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | ClassroomPost$commentsArgs<ExtArgs>
    _count?: boolean | ClassroomPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassroomPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClassroomPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassroomPost"
    objects: {
      classroom: Prisma.$ClassroomPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      comments: Prisma.$ClassroomCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      classroomId: number
      authorId: number
      content: string
      pinned: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["classroomPost"]>
    composites: {}
  }

  type ClassroomPostGetPayload<S extends boolean | null | undefined | ClassroomPostDefaultArgs> = $Result.GetResult<Prisma.$ClassroomPostPayload, S>

  type ClassroomPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassroomPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassroomPostCountAggregateInputType | true
    }

  export interface ClassroomPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassroomPost'], meta: { name: 'ClassroomPost' } }
    /**
     * Find zero or one ClassroomPost that matches the filter.
     * @param {ClassroomPostFindUniqueArgs} args - Arguments to find a ClassroomPost
     * @example
     * // Get one ClassroomPost
     * const classroomPost = await prisma.classroomPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassroomPostFindUniqueArgs>(args: SelectSubset<T, ClassroomPostFindUniqueArgs<ExtArgs>>): Prisma__ClassroomPostClient<$Result.GetResult<Prisma.$ClassroomPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClassroomPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassroomPostFindUniqueOrThrowArgs} args - Arguments to find a ClassroomPost
     * @example
     * // Get one ClassroomPost
     * const classroomPost = await prisma.classroomPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassroomPostFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassroomPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassroomPostClient<$Result.GetResult<Prisma.$ClassroomPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClassroomPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomPostFindFirstArgs} args - Arguments to find a ClassroomPost
     * @example
     * // Get one ClassroomPost
     * const classroomPost = await prisma.classroomPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassroomPostFindFirstArgs>(args?: SelectSubset<T, ClassroomPostFindFirstArgs<ExtArgs>>): Prisma__ClassroomPostClient<$Result.GetResult<Prisma.$ClassroomPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClassroomPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomPostFindFirstOrThrowArgs} args - Arguments to find a ClassroomPost
     * @example
     * // Get one ClassroomPost
     * const classroomPost = await prisma.classroomPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassroomPostFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassroomPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassroomPostClient<$Result.GetResult<Prisma.$ClassroomPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClassroomPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassroomPosts
     * const classroomPosts = await prisma.classroomPost.findMany()
     * 
     * // Get first 10 ClassroomPosts
     * const classroomPosts = await prisma.classroomPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classroomPostWithIdOnly = await prisma.classroomPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassroomPostFindManyArgs>(args?: SelectSubset<T, ClassroomPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClassroomPost.
     * @param {ClassroomPostCreateArgs} args - Arguments to create a ClassroomPost.
     * @example
     * // Create one ClassroomPost
     * const ClassroomPost = await prisma.classroomPost.create({
     *   data: {
     *     // ... data to create a ClassroomPost
     *   }
     * })
     * 
     */
    create<T extends ClassroomPostCreateArgs>(args: SelectSubset<T, ClassroomPostCreateArgs<ExtArgs>>): Prisma__ClassroomPostClient<$Result.GetResult<Prisma.$ClassroomPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClassroomPosts.
     * @param {ClassroomPostCreateManyArgs} args - Arguments to create many ClassroomPosts.
     * @example
     * // Create many ClassroomPosts
     * const classroomPost = await prisma.classroomPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassroomPostCreateManyArgs>(args?: SelectSubset<T, ClassroomPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassroomPosts and returns the data saved in the database.
     * @param {ClassroomPostCreateManyAndReturnArgs} args - Arguments to create many ClassroomPosts.
     * @example
     * // Create many ClassroomPosts
     * const classroomPost = await prisma.classroomPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassroomPosts and only return the `id`
     * const classroomPostWithIdOnly = await prisma.classroomPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassroomPostCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassroomPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClassroomPost.
     * @param {ClassroomPostDeleteArgs} args - Arguments to delete one ClassroomPost.
     * @example
     * // Delete one ClassroomPost
     * const ClassroomPost = await prisma.classroomPost.delete({
     *   where: {
     *     // ... filter to delete one ClassroomPost
     *   }
     * })
     * 
     */
    delete<T extends ClassroomPostDeleteArgs>(args: SelectSubset<T, ClassroomPostDeleteArgs<ExtArgs>>): Prisma__ClassroomPostClient<$Result.GetResult<Prisma.$ClassroomPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClassroomPost.
     * @param {ClassroomPostUpdateArgs} args - Arguments to update one ClassroomPost.
     * @example
     * // Update one ClassroomPost
     * const classroomPost = await prisma.classroomPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassroomPostUpdateArgs>(args: SelectSubset<T, ClassroomPostUpdateArgs<ExtArgs>>): Prisma__ClassroomPostClient<$Result.GetResult<Prisma.$ClassroomPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClassroomPosts.
     * @param {ClassroomPostDeleteManyArgs} args - Arguments to filter ClassroomPosts to delete.
     * @example
     * // Delete a few ClassroomPosts
     * const { count } = await prisma.classroomPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassroomPostDeleteManyArgs>(args?: SelectSubset<T, ClassroomPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassroomPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassroomPosts
     * const classroomPost = await prisma.classroomPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassroomPostUpdateManyArgs>(args: SelectSubset<T, ClassroomPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassroomPost.
     * @param {ClassroomPostUpsertArgs} args - Arguments to update or create a ClassroomPost.
     * @example
     * // Update or create a ClassroomPost
     * const classroomPost = await prisma.classroomPost.upsert({
     *   create: {
     *     // ... data to create a ClassroomPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassroomPost we want to update
     *   }
     * })
     */
    upsert<T extends ClassroomPostUpsertArgs>(args: SelectSubset<T, ClassroomPostUpsertArgs<ExtArgs>>): Prisma__ClassroomPostClient<$Result.GetResult<Prisma.$ClassroomPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClassroomPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomPostCountArgs} args - Arguments to filter ClassroomPosts to count.
     * @example
     * // Count the number of ClassroomPosts
     * const count = await prisma.classroomPost.count({
     *   where: {
     *     // ... the filter for the ClassroomPosts we want to count
     *   }
     * })
    **/
    count<T extends ClassroomPostCountArgs>(
      args?: Subset<T, ClassroomPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassroomPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassroomPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassroomPostAggregateArgs>(args: Subset<T, ClassroomPostAggregateArgs>): Prisma.PrismaPromise<GetClassroomPostAggregateType<T>>

    /**
     * Group by ClassroomPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassroomPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassroomPostGroupByArgs['orderBy'] }
        : { orderBy?: ClassroomPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassroomPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassroomPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassroomPost model
   */
  readonly fields: ClassroomPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassroomPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassroomPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classroom<T extends ClassroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassroomDefaultArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comments<T extends ClassroomPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, ClassroomPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassroomPost model
   */ 
  interface ClassroomPostFieldRefs {
    readonly id: FieldRef<"ClassroomPost", 'Int'>
    readonly classroomId: FieldRef<"ClassroomPost", 'Int'>
    readonly authorId: FieldRef<"ClassroomPost", 'Int'>
    readonly content: FieldRef<"ClassroomPost", 'String'>
    readonly pinned: FieldRef<"ClassroomPost", 'Boolean'>
    readonly createdAt: FieldRef<"ClassroomPost", 'DateTime'>
    readonly updatedAt: FieldRef<"ClassroomPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClassroomPost findUnique
   */
  export type ClassroomPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPost
     */
    select?: ClassroomPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomPostInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomPost to fetch.
     */
    where: ClassroomPostWhereUniqueInput
  }

  /**
   * ClassroomPost findUniqueOrThrow
   */
  export type ClassroomPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPost
     */
    select?: ClassroomPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomPostInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomPost to fetch.
     */
    where: ClassroomPostWhereUniqueInput
  }

  /**
   * ClassroomPost findFirst
   */
  export type ClassroomPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPost
     */
    select?: ClassroomPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomPostInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomPost to fetch.
     */
    where?: ClassroomPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomPosts to fetch.
     */
    orderBy?: ClassroomPostOrderByWithRelationInput | ClassroomPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassroomPosts.
     */
    cursor?: ClassroomPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassroomPosts.
     */
    distinct?: ClassroomPostScalarFieldEnum | ClassroomPostScalarFieldEnum[]
  }

  /**
   * ClassroomPost findFirstOrThrow
   */
  export type ClassroomPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPost
     */
    select?: ClassroomPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomPostInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomPost to fetch.
     */
    where?: ClassroomPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomPosts to fetch.
     */
    orderBy?: ClassroomPostOrderByWithRelationInput | ClassroomPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassroomPosts.
     */
    cursor?: ClassroomPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassroomPosts.
     */
    distinct?: ClassroomPostScalarFieldEnum | ClassroomPostScalarFieldEnum[]
  }

  /**
   * ClassroomPost findMany
   */
  export type ClassroomPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPost
     */
    select?: ClassroomPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomPostInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomPosts to fetch.
     */
    where?: ClassroomPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomPosts to fetch.
     */
    orderBy?: ClassroomPostOrderByWithRelationInput | ClassroomPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassroomPosts.
     */
    cursor?: ClassroomPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomPosts.
     */
    skip?: number
    distinct?: ClassroomPostScalarFieldEnum | ClassroomPostScalarFieldEnum[]
  }

  /**
   * ClassroomPost create
   */
  export type ClassroomPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPost
     */
    select?: ClassroomPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomPostInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassroomPost.
     */
    data: XOR<ClassroomPostCreateInput, ClassroomPostUncheckedCreateInput>
  }

  /**
   * ClassroomPost createMany
   */
  export type ClassroomPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassroomPosts.
     */
    data: ClassroomPostCreateManyInput | ClassroomPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassroomPost createManyAndReturn
   */
  export type ClassroomPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPost
     */
    select?: ClassroomPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClassroomPosts.
     */
    data: ClassroomPostCreateManyInput | ClassroomPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassroomPost update
   */
  export type ClassroomPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPost
     */
    select?: ClassroomPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomPostInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassroomPost.
     */
    data: XOR<ClassroomPostUpdateInput, ClassroomPostUncheckedUpdateInput>
    /**
     * Choose, which ClassroomPost to update.
     */
    where: ClassroomPostWhereUniqueInput
  }

  /**
   * ClassroomPost updateMany
   */
  export type ClassroomPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassroomPosts.
     */
    data: XOR<ClassroomPostUpdateManyMutationInput, ClassroomPostUncheckedUpdateManyInput>
    /**
     * Filter which ClassroomPosts to update
     */
    where?: ClassroomPostWhereInput
  }

  /**
   * ClassroomPost upsert
   */
  export type ClassroomPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPost
     */
    select?: ClassroomPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomPostInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassroomPost to update in case it exists.
     */
    where: ClassroomPostWhereUniqueInput
    /**
     * In case the ClassroomPost found by the `where` argument doesn't exist, create a new ClassroomPost with this data.
     */
    create: XOR<ClassroomPostCreateInput, ClassroomPostUncheckedCreateInput>
    /**
     * In case the ClassroomPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassroomPostUpdateInput, ClassroomPostUncheckedUpdateInput>
  }

  /**
   * ClassroomPost delete
   */
  export type ClassroomPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPost
     */
    select?: ClassroomPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomPostInclude<ExtArgs> | null
    /**
     * Filter which ClassroomPost to delete.
     */
    where: ClassroomPostWhereUniqueInput
  }

  /**
   * ClassroomPost deleteMany
   */
  export type ClassroomPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassroomPosts to delete
     */
    where?: ClassroomPostWhereInput
  }

  /**
   * ClassroomPost.comments
   */
  export type ClassroomPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomComment
     */
    select?: ClassroomCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomCommentInclude<ExtArgs> | null
    where?: ClassroomCommentWhereInput
    orderBy?: ClassroomCommentOrderByWithRelationInput | ClassroomCommentOrderByWithRelationInput[]
    cursor?: ClassroomCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomCommentScalarFieldEnum | ClassroomCommentScalarFieldEnum[]
  }

  /**
   * ClassroomPost without action
   */
  export type ClassroomPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomPost
     */
    select?: ClassroomPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomPostInclude<ExtArgs> | null
  }


  /**
   * Model ClassroomComment
   */

  export type AggregateClassroomComment = {
    _count: ClassroomCommentCountAggregateOutputType | null
    _avg: ClassroomCommentAvgAggregateOutputType | null
    _sum: ClassroomCommentSumAggregateOutputType | null
    _min: ClassroomCommentMinAggregateOutputType | null
    _max: ClassroomCommentMaxAggregateOutputType | null
  }

  export type ClassroomCommentAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    authorId: number | null
  }

  export type ClassroomCommentSumAggregateOutputType = {
    id: number | null
    postId: number | null
    authorId: number | null
  }

  export type ClassroomCommentMinAggregateOutputType = {
    id: number | null
    postId: number | null
    authorId: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassroomCommentMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    authorId: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassroomCommentCountAggregateOutputType = {
    id: number
    postId: number
    authorId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassroomCommentAvgAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
  }

  export type ClassroomCommentSumAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
  }

  export type ClassroomCommentMinAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassroomCommentMaxAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassroomCommentCountAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassroomCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassroomComment to aggregate.
     */
    where?: ClassroomCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomComments to fetch.
     */
    orderBy?: ClassroomCommentOrderByWithRelationInput | ClassroomCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassroomCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassroomComments
    **/
    _count?: true | ClassroomCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassroomCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassroomCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassroomCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassroomCommentMaxAggregateInputType
  }

  export type GetClassroomCommentAggregateType<T extends ClassroomCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateClassroomComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassroomComment[P]>
      : GetScalarType<T[P], AggregateClassroomComment[P]>
  }




  export type ClassroomCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomCommentWhereInput
    orderBy?: ClassroomCommentOrderByWithAggregationInput | ClassroomCommentOrderByWithAggregationInput[]
    by: ClassroomCommentScalarFieldEnum[] | ClassroomCommentScalarFieldEnum
    having?: ClassroomCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassroomCommentCountAggregateInputType | true
    _avg?: ClassroomCommentAvgAggregateInputType
    _sum?: ClassroomCommentSumAggregateInputType
    _min?: ClassroomCommentMinAggregateInputType
    _max?: ClassroomCommentMaxAggregateInputType
  }

  export type ClassroomCommentGroupByOutputType = {
    id: number
    postId: number
    authorId: number
    content: string
    createdAt: Date
    updatedAt: Date
    _count: ClassroomCommentCountAggregateOutputType | null
    _avg: ClassroomCommentAvgAggregateOutputType | null
    _sum: ClassroomCommentSumAggregateOutputType | null
    _min: ClassroomCommentMinAggregateOutputType | null
    _max: ClassroomCommentMaxAggregateOutputType | null
  }

  type GetClassroomCommentGroupByPayload<T extends ClassroomCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassroomCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassroomCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassroomCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ClassroomCommentGroupByOutputType[P]>
        }
      >
    >


  export type ClassroomCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | ClassroomPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroomComment"]>

  export type ClassroomCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | ClassroomPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroomComment"]>

  export type ClassroomCommentSelectScalar = {
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassroomCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | ClassroomPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClassroomCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | ClassroomPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClassroomCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassroomComment"
    objects: {
      post: Prisma.$ClassroomPostPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postId: number
      authorId: number
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["classroomComment"]>
    composites: {}
  }

  type ClassroomCommentGetPayload<S extends boolean | null | undefined | ClassroomCommentDefaultArgs> = $Result.GetResult<Prisma.$ClassroomCommentPayload, S>

  type ClassroomCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassroomCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassroomCommentCountAggregateInputType | true
    }

  export interface ClassroomCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassroomComment'], meta: { name: 'ClassroomComment' } }
    /**
     * Find zero or one ClassroomComment that matches the filter.
     * @param {ClassroomCommentFindUniqueArgs} args - Arguments to find a ClassroomComment
     * @example
     * // Get one ClassroomComment
     * const classroomComment = await prisma.classroomComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassroomCommentFindUniqueArgs>(args: SelectSubset<T, ClassroomCommentFindUniqueArgs<ExtArgs>>): Prisma__ClassroomCommentClient<$Result.GetResult<Prisma.$ClassroomCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClassroomComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassroomCommentFindUniqueOrThrowArgs} args - Arguments to find a ClassroomComment
     * @example
     * // Get one ClassroomComment
     * const classroomComment = await prisma.classroomComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassroomCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassroomCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassroomCommentClient<$Result.GetResult<Prisma.$ClassroomCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClassroomComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomCommentFindFirstArgs} args - Arguments to find a ClassroomComment
     * @example
     * // Get one ClassroomComment
     * const classroomComment = await prisma.classroomComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassroomCommentFindFirstArgs>(args?: SelectSubset<T, ClassroomCommentFindFirstArgs<ExtArgs>>): Prisma__ClassroomCommentClient<$Result.GetResult<Prisma.$ClassroomCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClassroomComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomCommentFindFirstOrThrowArgs} args - Arguments to find a ClassroomComment
     * @example
     * // Get one ClassroomComment
     * const classroomComment = await prisma.classroomComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassroomCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassroomCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassroomCommentClient<$Result.GetResult<Prisma.$ClassroomCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClassroomComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassroomComments
     * const classroomComments = await prisma.classroomComment.findMany()
     * 
     * // Get first 10 ClassroomComments
     * const classroomComments = await prisma.classroomComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classroomCommentWithIdOnly = await prisma.classroomComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassroomCommentFindManyArgs>(args?: SelectSubset<T, ClassroomCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClassroomComment.
     * @param {ClassroomCommentCreateArgs} args - Arguments to create a ClassroomComment.
     * @example
     * // Create one ClassroomComment
     * const ClassroomComment = await prisma.classroomComment.create({
     *   data: {
     *     // ... data to create a ClassroomComment
     *   }
     * })
     * 
     */
    create<T extends ClassroomCommentCreateArgs>(args: SelectSubset<T, ClassroomCommentCreateArgs<ExtArgs>>): Prisma__ClassroomCommentClient<$Result.GetResult<Prisma.$ClassroomCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClassroomComments.
     * @param {ClassroomCommentCreateManyArgs} args - Arguments to create many ClassroomComments.
     * @example
     * // Create many ClassroomComments
     * const classroomComment = await prisma.classroomComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassroomCommentCreateManyArgs>(args?: SelectSubset<T, ClassroomCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassroomComments and returns the data saved in the database.
     * @param {ClassroomCommentCreateManyAndReturnArgs} args - Arguments to create many ClassroomComments.
     * @example
     * // Create many ClassroomComments
     * const classroomComment = await prisma.classroomComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassroomComments and only return the `id`
     * const classroomCommentWithIdOnly = await prisma.classroomComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassroomCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassroomCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClassroomComment.
     * @param {ClassroomCommentDeleteArgs} args - Arguments to delete one ClassroomComment.
     * @example
     * // Delete one ClassroomComment
     * const ClassroomComment = await prisma.classroomComment.delete({
     *   where: {
     *     // ... filter to delete one ClassroomComment
     *   }
     * })
     * 
     */
    delete<T extends ClassroomCommentDeleteArgs>(args: SelectSubset<T, ClassroomCommentDeleteArgs<ExtArgs>>): Prisma__ClassroomCommentClient<$Result.GetResult<Prisma.$ClassroomCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClassroomComment.
     * @param {ClassroomCommentUpdateArgs} args - Arguments to update one ClassroomComment.
     * @example
     * // Update one ClassroomComment
     * const classroomComment = await prisma.classroomComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassroomCommentUpdateArgs>(args: SelectSubset<T, ClassroomCommentUpdateArgs<ExtArgs>>): Prisma__ClassroomCommentClient<$Result.GetResult<Prisma.$ClassroomCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClassroomComments.
     * @param {ClassroomCommentDeleteManyArgs} args - Arguments to filter ClassroomComments to delete.
     * @example
     * // Delete a few ClassroomComments
     * const { count } = await prisma.classroomComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassroomCommentDeleteManyArgs>(args?: SelectSubset<T, ClassroomCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassroomComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassroomComments
     * const classroomComment = await prisma.classroomComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassroomCommentUpdateManyArgs>(args: SelectSubset<T, ClassroomCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassroomComment.
     * @param {ClassroomCommentUpsertArgs} args - Arguments to update or create a ClassroomComment.
     * @example
     * // Update or create a ClassroomComment
     * const classroomComment = await prisma.classroomComment.upsert({
     *   create: {
     *     // ... data to create a ClassroomComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassroomComment we want to update
     *   }
     * })
     */
    upsert<T extends ClassroomCommentUpsertArgs>(args: SelectSubset<T, ClassroomCommentUpsertArgs<ExtArgs>>): Prisma__ClassroomCommentClient<$Result.GetResult<Prisma.$ClassroomCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClassroomComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomCommentCountArgs} args - Arguments to filter ClassroomComments to count.
     * @example
     * // Count the number of ClassroomComments
     * const count = await prisma.classroomComment.count({
     *   where: {
     *     // ... the filter for the ClassroomComments we want to count
     *   }
     * })
    **/
    count<T extends ClassroomCommentCountArgs>(
      args?: Subset<T, ClassroomCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassroomCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassroomComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassroomCommentAggregateArgs>(args: Subset<T, ClassroomCommentAggregateArgs>): Prisma.PrismaPromise<GetClassroomCommentAggregateType<T>>

    /**
     * Group by ClassroomComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassroomCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassroomCommentGroupByArgs['orderBy'] }
        : { orderBy?: ClassroomCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassroomCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassroomCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassroomComment model
   */
  readonly fields: ClassroomCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassroomComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassroomCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends ClassroomPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassroomPostDefaultArgs<ExtArgs>>): Prisma__ClassroomPostClient<$Result.GetResult<Prisma.$ClassroomPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassroomComment model
   */ 
  interface ClassroomCommentFieldRefs {
    readonly id: FieldRef<"ClassroomComment", 'Int'>
    readonly postId: FieldRef<"ClassroomComment", 'Int'>
    readonly authorId: FieldRef<"ClassroomComment", 'Int'>
    readonly content: FieldRef<"ClassroomComment", 'String'>
    readonly createdAt: FieldRef<"ClassroomComment", 'DateTime'>
    readonly updatedAt: FieldRef<"ClassroomComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClassroomComment findUnique
   */
  export type ClassroomCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomComment
     */
    select?: ClassroomCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomCommentInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomComment to fetch.
     */
    where: ClassroomCommentWhereUniqueInput
  }

  /**
   * ClassroomComment findUniqueOrThrow
   */
  export type ClassroomCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomComment
     */
    select?: ClassroomCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomCommentInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomComment to fetch.
     */
    where: ClassroomCommentWhereUniqueInput
  }

  /**
   * ClassroomComment findFirst
   */
  export type ClassroomCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomComment
     */
    select?: ClassroomCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomCommentInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomComment to fetch.
     */
    where?: ClassroomCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomComments to fetch.
     */
    orderBy?: ClassroomCommentOrderByWithRelationInput | ClassroomCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassroomComments.
     */
    cursor?: ClassroomCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassroomComments.
     */
    distinct?: ClassroomCommentScalarFieldEnum | ClassroomCommentScalarFieldEnum[]
  }

  /**
   * ClassroomComment findFirstOrThrow
   */
  export type ClassroomCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomComment
     */
    select?: ClassroomCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomCommentInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomComment to fetch.
     */
    where?: ClassroomCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomComments to fetch.
     */
    orderBy?: ClassroomCommentOrderByWithRelationInput | ClassroomCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassroomComments.
     */
    cursor?: ClassroomCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassroomComments.
     */
    distinct?: ClassroomCommentScalarFieldEnum | ClassroomCommentScalarFieldEnum[]
  }

  /**
   * ClassroomComment findMany
   */
  export type ClassroomCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomComment
     */
    select?: ClassroomCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomCommentInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomComments to fetch.
     */
    where?: ClassroomCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomComments to fetch.
     */
    orderBy?: ClassroomCommentOrderByWithRelationInput | ClassroomCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassroomComments.
     */
    cursor?: ClassroomCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomComments.
     */
    skip?: number
    distinct?: ClassroomCommentScalarFieldEnum | ClassroomCommentScalarFieldEnum[]
  }

  /**
   * ClassroomComment create
   */
  export type ClassroomCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomComment
     */
    select?: ClassroomCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassroomComment.
     */
    data: XOR<ClassroomCommentCreateInput, ClassroomCommentUncheckedCreateInput>
  }

  /**
   * ClassroomComment createMany
   */
  export type ClassroomCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassroomComments.
     */
    data: ClassroomCommentCreateManyInput | ClassroomCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassroomComment createManyAndReturn
   */
  export type ClassroomCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomComment
     */
    select?: ClassroomCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClassroomComments.
     */
    data: ClassroomCommentCreateManyInput | ClassroomCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassroomComment update
   */
  export type ClassroomCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomComment
     */
    select?: ClassroomCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassroomComment.
     */
    data: XOR<ClassroomCommentUpdateInput, ClassroomCommentUncheckedUpdateInput>
    /**
     * Choose, which ClassroomComment to update.
     */
    where: ClassroomCommentWhereUniqueInput
  }

  /**
   * ClassroomComment updateMany
   */
  export type ClassroomCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassroomComments.
     */
    data: XOR<ClassroomCommentUpdateManyMutationInput, ClassroomCommentUncheckedUpdateManyInput>
    /**
     * Filter which ClassroomComments to update
     */
    where?: ClassroomCommentWhereInput
  }

  /**
   * ClassroomComment upsert
   */
  export type ClassroomCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomComment
     */
    select?: ClassroomCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassroomComment to update in case it exists.
     */
    where: ClassroomCommentWhereUniqueInput
    /**
     * In case the ClassroomComment found by the `where` argument doesn't exist, create a new ClassroomComment with this data.
     */
    create: XOR<ClassroomCommentCreateInput, ClassroomCommentUncheckedCreateInput>
    /**
     * In case the ClassroomComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassroomCommentUpdateInput, ClassroomCommentUncheckedUpdateInput>
  }

  /**
   * ClassroomComment delete
   */
  export type ClassroomCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomComment
     */
    select?: ClassroomCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomCommentInclude<ExtArgs> | null
    /**
     * Filter which ClassroomComment to delete.
     */
    where: ClassroomCommentWhereUniqueInput
  }

  /**
   * ClassroomComment deleteMany
   */
  export type ClassroomCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassroomComments to delete
     */
    where?: ClassroomCommentWhereInput
  }

  /**
   * ClassroomComment without action
   */
  export type ClassroomCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomComment
     */
    select?: ClassroomCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomCommentInclude<ExtArgs> | null
  }


  /**
   * Model ClassroomResource
   */

  export type AggregateClassroomResource = {
    _count: ClassroomResourceCountAggregateOutputType | null
    _avg: ClassroomResourceAvgAggregateOutputType | null
    _sum: ClassroomResourceSumAggregateOutputType | null
    _min: ClassroomResourceMinAggregateOutputType | null
    _max: ClassroomResourceMaxAggregateOutputType | null
  }

  export type ClassroomResourceAvgAggregateOutputType = {
    id: number | null
    classroomId: number | null
    courseId: number | null
    quizId: number | null
    addedBy: number | null
  }

  export type ClassroomResourceSumAggregateOutputType = {
    id: number | null
    classroomId: number | null
    courseId: number | null
    quizId: number | null
    addedBy: number | null
  }

  export type ClassroomResourceMinAggregateOutputType = {
    id: number | null
    classroomId: number | null
    courseId: number | null
    quizId: number | null
    pinnedAt: Date | null
    addedBy: number | null
  }

  export type ClassroomResourceMaxAggregateOutputType = {
    id: number | null
    classroomId: number | null
    courseId: number | null
    quizId: number | null
    pinnedAt: Date | null
    addedBy: number | null
  }

  export type ClassroomResourceCountAggregateOutputType = {
    id: number
    classroomId: number
    courseId: number
    quizId: number
    pinnedAt: number
    addedBy: number
    _all: number
  }


  export type ClassroomResourceAvgAggregateInputType = {
    id?: true
    classroomId?: true
    courseId?: true
    quizId?: true
    addedBy?: true
  }

  export type ClassroomResourceSumAggregateInputType = {
    id?: true
    classroomId?: true
    courseId?: true
    quizId?: true
    addedBy?: true
  }

  export type ClassroomResourceMinAggregateInputType = {
    id?: true
    classroomId?: true
    courseId?: true
    quizId?: true
    pinnedAt?: true
    addedBy?: true
  }

  export type ClassroomResourceMaxAggregateInputType = {
    id?: true
    classroomId?: true
    courseId?: true
    quizId?: true
    pinnedAt?: true
    addedBy?: true
  }

  export type ClassroomResourceCountAggregateInputType = {
    id?: true
    classroomId?: true
    courseId?: true
    quizId?: true
    pinnedAt?: true
    addedBy?: true
    _all?: true
  }

  export type ClassroomResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassroomResource to aggregate.
     */
    where?: ClassroomResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomResources to fetch.
     */
    orderBy?: ClassroomResourceOrderByWithRelationInput | ClassroomResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassroomResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassroomResources
    **/
    _count?: true | ClassroomResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassroomResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassroomResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassroomResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassroomResourceMaxAggregateInputType
  }

  export type GetClassroomResourceAggregateType<T extends ClassroomResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateClassroomResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassroomResource[P]>
      : GetScalarType<T[P], AggregateClassroomResource[P]>
  }




  export type ClassroomResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomResourceWhereInput
    orderBy?: ClassroomResourceOrderByWithAggregationInput | ClassroomResourceOrderByWithAggregationInput[]
    by: ClassroomResourceScalarFieldEnum[] | ClassroomResourceScalarFieldEnum
    having?: ClassroomResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassroomResourceCountAggregateInputType | true
    _avg?: ClassroomResourceAvgAggregateInputType
    _sum?: ClassroomResourceSumAggregateInputType
    _min?: ClassroomResourceMinAggregateInputType
    _max?: ClassroomResourceMaxAggregateInputType
  }

  export type ClassroomResourceGroupByOutputType = {
    id: number
    classroomId: number
    courseId: number | null
    quizId: number | null
    pinnedAt: Date | null
    addedBy: number
    _count: ClassroomResourceCountAggregateOutputType | null
    _avg: ClassroomResourceAvgAggregateOutputType | null
    _sum: ClassroomResourceSumAggregateOutputType | null
    _min: ClassroomResourceMinAggregateOutputType | null
    _max: ClassroomResourceMaxAggregateOutputType | null
  }

  type GetClassroomResourceGroupByPayload<T extends ClassroomResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassroomResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassroomResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassroomResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ClassroomResourceGroupByOutputType[P]>
        }
      >
    >


  export type ClassroomResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    courseId?: boolean
    quizId?: boolean
    pinnedAt?: boolean
    addedBy?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    course?: boolean | ClassroomResource$courseArgs<ExtArgs>
    quiz?: boolean | ClassroomResource$quizArgs<ExtArgs>
    addedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroomResource"]>

  export type ClassroomResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    courseId?: boolean
    quizId?: boolean
    pinnedAt?: boolean
    addedBy?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    course?: boolean | ClassroomResource$courseArgs<ExtArgs>
    quiz?: boolean | ClassroomResource$quizArgs<ExtArgs>
    addedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroomResource"]>

  export type ClassroomResourceSelectScalar = {
    id?: boolean
    classroomId?: boolean
    courseId?: boolean
    quizId?: boolean
    pinnedAt?: boolean
    addedBy?: boolean
  }

  export type ClassroomResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    course?: boolean | ClassroomResource$courseArgs<ExtArgs>
    quiz?: boolean | ClassroomResource$quizArgs<ExtArgs>
    addedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClassroomResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    course?: boolean | ClassroomResource$courseArgs<ExtArgs>
    quiz?: boolean | ClassroomResource$quizArgs<ExtArgs>
    addedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClassroomResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassroomResource"
    objects: {
      classroom: Prisma.$ClassroomPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs> | null
      quiz: Prisma.$QuizPayload<ExtArgs> | null
      addedByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      classroomId: number
      courseId: number | null
      quizId: number | null
      pinnedAt: Date | null
      addedBy: number
    }, ExtArgs["result"]["classroomResource"]>
    composites: {}
  }

  type ClassroomResourceGetPayload<S extends boolean | null | undefined | ClassroomResourceDefaultArgs> = $Result.GetResult<Prisma.$ClassroomResourcePayload, S>

  type ClassroomResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassroomResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassroomResourceCountAggregateInputType | true
    }

  export interface ClassroomResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassroomResource'], meta: { name: 'ClassroomResource' } }
    /**
     * Find zero or one ClassroomResource that matches the filter.
     * @param {ClassroomResourceFindUniqueArgs} args - Arguments to find a ClassroomResource
     * @example
     * // Get one ClassroomResource
     * const classroomResource = await prisma.classroomResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassroomResourceFindUniqueArgs>(args: SelectSubset<T, ClassroomResourceFindUniqueArgs<ExtArgs>>): Prisma__ClassroomResourceClient<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClassroomResource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassroomResourceFindUniqueOrThrowArgs} args - Arguments to find a ClassroomResource
     * @example
     * // Get one ClassroomResource
     * const classroomResource = await prisma.classroomResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassroomResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassroomResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassroomResourceClient<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClassroomResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomResourceFindFirstArgs} args - Arguments to find a ClassroomResource
     * @example
     * // Get one ClassroomResource
     * const classroomResource = await prisma.classroomResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassroomResourceFindFirstArgs>(args?: SelectSubset<T, ClassroomResourceFindFirstArgs<ExtArgs>>): Prisma__ClassroomResourceClient<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClassroomResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomResourceFindFirstOrThrowArgs} args - Arguments to find a ClassroomResource
     * @example
     * // Get one ClassroomResource
     * const classroomResource = await prisma.classroomResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassroomResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassroomResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassroomResourceClient<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClassroomResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassroomResources
     * const classroomResources = await prisma.classroomResource.findMany()
     * 
     * // Get first 10 ClassroomResources
     * const classroomResources = await prisma.classroomResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classroomResourceWithIdOnly = await prisma.classroomResource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassroomResourceFindManyArgs>(args?: SelectSubset<T, ClassroomResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClassroomResource.
     * @param {ClassroomResourceCreateArgs} args - Arguments to create a ClassroomResource.
     * @example
     * // Create one ClassroomResource
     * const ClassroomResource = await prisma.classroomResource.create({
     *   data: {
     *     // ... data to create a ClassroomResource
     *   }
     * })
     * 
     */
    create<T extends ClassroomResourceCreateArgs>(args: SelectSubset<T, ClassroomResourceCreateArgs<ExtArgs>>): Prisma__ClassroomResourceClient<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClassroomResources.
     * @param {ClassroomResourceCreateManyArgs} args - Arguments to create many ClassroomResources.
     * @example
     * // Create many ClassroomResources
     * const classroomResource = await prisma.classroomResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassroomResourceCreateManyArgs>(args?: SelectSubset<T, ClassroomResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassroomResources and returns the data saved in the database.
     * @param {ClassroomResourceCreateManyAndReturnArgs} args - Arguments to create many ClassroomResources.
     * @example
     * // Create many ClassroomResources
     * const classroomResource = await prisma.classroomResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassroomResources and only return the `id`
     * const classroomResourceWithIdOnly = await prisma.classroomResource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassroomResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassroomResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClassroomResource.
     * @param {ClassroomResourceDeleteArgs} args - Arguments to delete one ClassroomResource.
     * @example
     * // Delete one ClassroomResource
     * const ClassroomResource = await prisma.classroomResource.delete({
     *   where: {
     *     // ... filter to delete one ClassroomResource
     *   }
     * })
     * 
     */
    delete<T extends ClassroomResourceDeleteArgs>(args: SelectSubset<T, ClassroomResourceDeleteArgs<ExtArgs>>): Prisma__ClassroomResourceClient<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClassroomResource.
     * @param {ClassroomResourceUpdateArgs} args - Arguments to update one ClassroomResource.
     * @example
     * // Update one ClassroomResource
     * const classroomResource = await prisma.classroomResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassroomResourceUpdateArgs>(args: SelectSubset<T, ClassroomResourceUpdateArgs<ExtArgs>>): Prisma__ClassroomResourceClient<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClassroomResources.
     * @param {ClassroomResourceDeleteManyArgs} args - Arguments to filter ClassroomResources to delete.
     * @example
     * // Delete a few ClassroomResources
     * const { count } = await prisma.classroomResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassroomResourceDeleteManyArgs>(args?: SelectSubset<T, ClassroomResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassroomResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassroomResources
     * const classroomResource = await prisma.classroomResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassroomResourceUpdateManyArgs>(args: SelectSubset<T, ClassroomResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassroomResource.
     * @param {ClassroomResourceUpsertArgs} args - Arguments to update or create a ClassroomResource.
     * @example
     * // Update or create a ClassroomResource
     * const classroomResource = await prisma.classroomResource.upsert({
     *   create: {
     *     // ... data to create a ClassroomResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassroomResource we want to update
     *   }
     * })
     */
    upsert<T extends ClassroomResourceUpsertArgs>(args: SelectSubset<T, ClassroomResourceUpsertArgs<ExtArgs>>): Prisma__ClassroomResourceClient<$Result.GetResult<Prisma.$ClassroomResourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClassroomResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomResourceCountArgs} args - Arguments to filter ClassroomResources to count.
     * @example
     * // Count the number of ClassroomResources
     * const count = await prisma.classroomResource.count({
     *   where: {
     *     // ... the filter for the ClassroomResources we want to count
     *   }
     * })
    **/
    count<T extends ClassroomResourceCountArgs>(
      args?: Subset<T, ClassroomResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassroomResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassroomResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassroomResourceAggregateArgs>(args: Subset<T, ClassroomResourceAggregateArgs>): Prisma.PrismaPromise<GetClassroomResourceAggregateType<T>>

    /**
     * Group by ClassroomResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassroomResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassroomResourceGroupByArgs['orderBy'] }
        : { orderBy?: ClassroomResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassroomResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassroomResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassroomResource model
   */
  readonly fields: ClassroomResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassroomResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassroomResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classroom<T extends ClassroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassroomDefaultArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends ClassroomResource$courseArgs<ExtArgs> = {}>(args?: Subset<T, ClassroomResource$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    quiz<T extends ClassroomResource$quizArgs<ExtArgs> = {}>(args?: Subset<T, ClassroomResource$quizArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    addedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassroomResource model
   */ 
  interface ClassroomResourceFieldRefs {
    readonly id: FieldRef<"ClassroomResource", 'Int'>
    readonly classroomId: FieldRef<"ClassroomResource", 'Int'>
    readonly courseId: FieldRef<"ClassroomResource", 'Int'>
    readonly quizId: FieldRef<"ClassroomResource", 'Int'>
    readonly pinnedAt: FieldRef<"ClassroomResource", 'DateTime'>
    readonly addedBy: FieldRef<"ClassroomResource", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClassroomResource findUnique
   */
  export type ClassroomResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomResource to fetch.
     */
    where: ClassroomResourceWhereUniqueInput
  }

  /**
   * ClassroomResource findUniqueOrThrow
   */
  export type ClassroomResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomResource to fetch.
     */
    where: ClassroomResourceWhereUniqueInput
  }

  /**
   * ClassroomResource findFirst
   */
  export type ClassroomResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomResource to fetch.
     */
    where?: ClassroomResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomResources to fetch.
     */
    orderBy?: ClassroomResourceOrderByWithRelationInput | ClassroomResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassroomResources.
     */
    cursor?: ClassroomResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassroomResources.
     */
    distinct?: ClassroomResourceScalarFieldEnum | ClassroomResourceScalarFieldEnum[]
  }

  /**
   * ClassroomResource findFirstOrThrow
   */
  export type ClassroomResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomResource to fetch.
     */
    where?: ClassroomResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomResources to fetch.
     */
    orderBy?: ClassroomResourceOrderByWithRelationInput | ClassroomResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassroomResources.
     */
    cursor?: ClassroomResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassroomResources.
     */
    distinct?: ClassroomResourceScalarFieldEnum | ClassroomResourceScalarFieldEnum[]
  }

  /**
   * ClassroomResource findMany
   */
  export type ClassroomResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomResources to fetch.
     */
    where?: ClassroomResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomResources to fetch.
     */
    orderBy?: ClassroomResourceOrderByWithRelationInput | ClassroomResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassroomResources.
     */
    cursor?: ClassroomResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomResources.
     */
    skip?: number
    distinct?: ClassroomResourceScalarFieldEnum | ClassroomResourceScalarFieldEnum[]
  }

  /**
   * ClassroomResource create
   */
  export type ClassroomResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassroomResource.
     */
    data: XOR<ClassroomResourceCreateInput, ClassroomResourceUncheckedCreateInput>
  }

  /**
   * ClassroomResource createMany
   */
  export type ClassroomResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassroomResources.
     */
    data: ClassroomResourceCreateManyInput | ClassroomResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassroomResource createManyAndReturn
   */
  export type ClassroomResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClassroomResources.
     */
    data: ClassroomResourceCreateManyInput | ClassroomResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassroomResource update
   */
  export type ClassroomResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassroomResource.
     */
    data: XOR<ClassroomResourceUpdateInput, ClassroomResourceUncheckedUpdateInput>
    /**
     * Choose, which ClassroomResource to update.
     */
    where: ClassroomResourceWhereUniqueInput
  }

  /**
   * ClassroomResource updateMany
   */
  export type ClassroomResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassroomResources.
     */
    data: XOR<ClassroomResourceUpdateManyMutationInput, ClassroomResourceUncheckedUpdateManyInput>
    /**
     * Filter which ClassroomResources to update
     */
    where?: ClassroomResourceWhereInput
  }

  /**
   * ClassroomResource upsert
   */
  export type ClassroomResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassroomResource to update in case it exists.
     */
    where: ClassroomResourceWhereUniqueInput
    /**
     * In case the ClassroomResource found by the `where` argument doesn't exist, create a new ClassroomResource with this data.
     */
    create: XOR<ClassroomResourceCreateInput, ClassroomResourceUncheckedCreateInput>
    /**
     * In case the ClassroomResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassroomResourceUpdateInput, ClassroomResourceUncheckedUpdateInput>
  }

  /**
   * ClassroomResource delete
   */
  export type ClassroomResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
    /**
     * Filter which ClassroomResource to delete.
     */
    where: ClassroomResourceWhereUniqueInput
  }

  /**
   * ClassroomResource deleteMany
   */
  export type ClassroomResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassroomResources to delete
     */
    where?: ClassroomResourceWhereInput
  }

  /**
   * ClassroomResource.course
   */
  export type ClassroomResource$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * ClassroomResource.quiz
   */
  export type ClassroomResource$quizArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
  }

  /**
   * ClassroomResource without action
   */
  export type ClassroomResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomResource
     */
    select?: ClassroomResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomResourceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    image: 'image',
    emailVerified: 'emailVerified',
    role: 'role',
    apiKey: 'apiKey',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    slug: 'slug',
    visibility: 'visibility',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const ChapterScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    order: 'order',
    content: 'content',
    blocks: 'blocks'
  };

  export type ChapterScalarFieldEnum = (typeof ChapterScalarFieldEnum)[keyof typeof ChapterScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    chapterId: 'chapterId',
    title: 'title',
    visibility: 'visibility',
    questions: 'questions',
    settings: 'settings',
    quizType: 'quizType',
    attemptLimit: 'attemptLimit',
    scoreReleaseMode: 'scoreReleaseMode',
    createdAt: 'createdAt'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const QuizAttemptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    quizId: 'quizId',
    answers: 'answers',
    score: 'score',
    totalQuestions: 'totalQuestions',
    correctAnswers: 'correctAnswers',
    percentage: 'percentage',
    timeSpent: 'timeSpent',
    detailedResults: 'detailedResults',
    completedAt: 'completedAt',
    scoreReleasedAt: 'scoreReleasedAt',
    endReason: 'endReason'
  };

  export type QuizAttemptScalarFieldEnum = (typeof QuizAttemptScalarFieldEnum)[keyof typeof QuizAttemptScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fullName: 'fullName',
    firstName: 'firstName',
    lastName: 'lastName',
    nickname: 'nickname',
    headline: 'headline',
    jobTitle: 'jobTitle',
    company: 'company',
    grade: 'grade',
    school: 'school',
    bio: 'bio',
    avatar: 'avatar',
    website: 'website',
    location: 'location',
    phone: 'phone',
    linkedin: 'linkedin',
    github: 'github',
    twitter: 'twitter',
    preferences: 'preferences',
    learningGoals: 'learningGoals',
    timezone: 'timezone',
    language: 'language',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const BlockProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    chapterId: 'chapterId',
    blockId: 'blockId',
    blockType: 'blockType',
    completed: 'completed',
    score: 'score',
    attempts: 'attempts',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlockProgressScalarFieldEnum = (typeof BlockProgressScalarFieldEnum)[keyof typeof BlockProgressScalarFieldEnum]


  export const ClassroomScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    isPrivate: 'isPrivate',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassroomScalarFieldEnum = (typeof ClassroomScalarFieldEnum)[keyof typeof ClassroomScalarFieldEnum]


  export const ClassroomMembershipScalarFieldEnum: {
    id: 'id',
    classroomId: 'classroomId',
    userId: 'userId',
    role: 'role',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ClassroomMembershipScalarFieldEnum = (typeof ClassroomMembershipScalarFieldEnum)[keyof typeof ClassroomMembershipScalarFieldEnum]


  export const ClassroomPostScalarFieldEnum: {
    id: 'id',
    classroomId: 'classroomId',
    authorId: 'authorId',
    content: 'content',
    pinned: 'pinned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassroomPostScalarFieldEnum = (typeof ClassroomPostScalarFieldEnum)[keyof typeof ClassroomPostScalarFieldEnum]


  export const ClassroomCommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassroomCommentScalarFieldEnum = (typeof ClassroomCommentScalarFieldEnum)[keyof typeof ClassroomCommentScalarFieldEnum]


  export const ClassroomResourceScalarFieldEnum: {
    id: 'id',
    classroomId: 'classroomId',
    courseId: 'courseId',
    quizId: 'quizId',
    pinnedAt: 'pinnedAt',
    addedBy: 'addedBy'
  };

  export type ClassroomResourceScalarFieldEnum = (typeof ClassroomResourceScalarFieldEnum)[keyof typeof ClassroomResourceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: StringFilter<"User"> | string
    apiKey?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    courses?: CourseListRelationFilter
    attempts?: QuizAttemptListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    blockProgress?: BlockProgressListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    classroomsCreated?: ClassroomListRelationFilter
    classroomMemberships?: ClassroomMembershipListRelationFilter
    classroomPosts?: ClassroomPostListRelationFilter
    classroomComments?: ClassroomCommentListRelationFilter
    classroomResourcesAdded?: ClassroomResourceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    role?: SortOrder
    apiKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    courses?: CourseOrderByRelationAggregateInput
    attempts?: QuizAttemptOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
    blockProgress?: BlockProgressOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
    classroomsCreated?: ClassroomOrderByRelationAggregateInput
    classroomMemberships?: ClassroomMembershipOrderByRelationAggregateInput
    classroomPosts?: ClassroomPostOrderByRelationAggregateInput
    classroomComments?: ClassroomCommentOrderByRelationAggregateInput
    classroomResourcesAdded?: ClassroomResourceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    apiKey?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    courses?: CourseListRelationFilter
    attempts?: QuizAttemptListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    blockProgress?: BlockProgressListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    classroomsCreated?: ClassroomListRelationFilter
    classroomMemberships?: ClassroomMembershipListRelationFilter
    classroomPosts?: ClassroomPostListRelationFilter
    classroomComments?: ClassroomCommentListRelationFilter
    classroomResourcesAdded?: ClassroomResourceListRelationFilter
  }, "id" | "email" | "apiKey">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    role?: SortOrder
    apiKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    apiKey?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: IntFilter<"Course"> | number
    title?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    slug?: StringFilter<"Course"> | string
    visibility?: StringFilter<"Course"> | string
    createdBy?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    chapters?: ChapterListRelationFilter
    quizzes?: QuizListRelationFilter
    creator?: XOR<UserRelationFilter, UserWhereInput>
    classroomResources?: ClassroomResourceListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    chapters?: ChapterOrderByRelationAggregateInput
    quizzes?: QuizOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    classroomResources?: ClassroomResourceOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    visibility?: StringFilter<"Course"> | string
    createdBy?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    chapters?: ChapterListRelationFilter
    quizzes?: QuizListRelationFilter
    creator?: XOR<UserRelationFilter, UserWhereInput>
    classroomResources?: ClassroomResourceListRelationFilter
  }, "id" | "slug">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Course"> | number
    title?: StringWithAggregatesFilter<"Course"> | string
    description?: StringNullableWithAggregatesFilter<"Course"> | string | null
    slug?: StringWithAggregatesFilter<"Course"> | string
    visibility?: StringWithAggregatesFilter<"Course"> | string
    createdBy?: IntWithAggregatesFilter<"Course"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type ChapterWhereInput = {
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    id?: IntFilter<"Chapter"> | number
    courseId?: IntFilter<"Chapter"> | number
    title?: StringFilter<"Chapter"> | string
    order?: IntFilter<"Chapter"> | number
    content?: StringNullableFilter<"Chapter"> | string | null
    blocks?: StringNullableFilter<"Chapter"> | string | null
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    quizzes?: QuizListRelationFilter
    blockProgress?: BlockProgressListRelationFilter
  }

  export type ChapterOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    order?: SortOrder
    content?: SortOrderInput | SortOrder
    blocks?: SortOrderInput | SortOrder
    course?: CourseOrderByWithRelationInput
    quizzes?: QuizOrderByRelationAggregateInput
    blockProgress?: BlockProgressOrderByRelationAggregateInput
  }

  export type ChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    courseId?: IntFilter<"Chapter"> | number
    title?: StringFilter<"Chapter"> | string
    order?: IntFilter<"Chapter"> | number
    content?: StringNullableFilter<"Chapter"> | string | null
    blocks?: StringNullableFilter<"Chapter"> | string | null
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    quizzes?: QuizListRelationFilter
    blockProgress?: BlockProgressListRelationFilter
  }, "id">

  export type ChapterOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    order?: SortOrder
    content?: SortOrderInput | SortOrder
    blocks?: SortOrderInput | SortOrder
    _count?: ChapterCountOrderByAggregateInput
    _avg?: ChapterAvgOrderByAggregateInput
    _max?: ChapterMaxOrderByAggregateInput
    _min?: ChapterMinOrderByAggregateInput
    _sum?: ChapterSumOrderByAggregateInput
  }

  export type ChapterScalarWhereWithAggregatesInput = {
    AND?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    OR?: ChapterScalarWhereWithAggregatesInput[]
    NOT?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Chapter"> | number
    courseId?: IntWithAggregatesFilter<"Chapter"> | number
    title?: StringWithAggregatesFilter<"Chapter"> | string
    order?: IntWithAggregatesFilter<"Chapter"> | number
    content?: StringNullableWithAggregatesFilter<"Chapter"> | string | null
    blocks?: StringNullableWithAggregatesFilter<"Chapter"> | string | null
  }

  export type QuizWhereInput = {
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    id?: IntFilter<"Quiz"> | number
    courseId?: IntNullableFilter<"Quiz"> | number | null
    chapterId?: IntNullableFilter<"Quiz"> | number | null
    title?: StringFilter<"Quiz"> | string
    visibility?: StringFilter<"Quiz"> | string
    questions?: StringFilter<"Quiz"> | string
    settings?: StringNullableFilter<"Quiz"> | string | null
    quizType?: StringFilter<"Quiz"> | string
    attemptLimit?: IntNullableFilter<"Quiz"> | number | null
    scoreReleaseMode?: StringFilter<"Quiz"> | string
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
    chapter?: XOR<ChapterNullableRelationFilter, ChapterWhereInput> | null
    attempts?: QuizAttemptListRelationFilter
    classroomResources?: ClassroomResourceListRelationFilter
  }

  export type QuizOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrderInput | SortOrder
    chapterId?: SortOrderInput | SortOrder
    title?: SortOrder
    visibility?: SortOrder
    questions?: SortOrder
    settings?: SortOrderInput | SortOrder
    quizType?: SortOrder
    attemptLimit?: SortOrderInput | SortOrder
    scoreReleaseMode?: SortOrder
    createdAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    chapter?: ChapterOrderByWithRelationInput
    attempts?: QuizAttemptOrderByRelationAggregateInput
    classroomResources?: ClassroomResourceOrderByRelationAggregateInput
  }

  export type QuizWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    courseId?: IntNullableFilter<"Quiz"> | number | null
    chapterId?: IntNullableFilter<"Quiz"> | number | null
    title?: StringFilter<"Quiz"> | string
    visibility?: StringFilter<"Quiz"> | string
    questions?: StringFilter<"Quiz"> | string
    settings?: StringNullableFilter<"Quiz"> | string | null
    quizType?: StringFilter<"Quiz"> | string
    attemptLimit?: IntNullableFilter<"Quiz"> | number | null
    scoreReleaseMode?: StringFilter<"Quiz"> | string
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
    chapter?: XOR<ChapterNullableRelationFilter, ChapterWhereInput> | null
    attempts?: QuizAttemptListRelationFilter
    classroomResources?: ClassroomResourceListRelationFilter
  }, "id">

  export type QuizOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrderInput | SortOrder
    chapterId?: SortOrderInput | SortOrder
    title?: SortOrder
    visibility?: SortOrder
    questions?: SortOrder
    settings?: SortOrderInput | SortOrder
    quizType?: SortOrder
    attemptLimit?: SortOrderInput | SortOrder
    scoreReleaseMode?: SortOrder
    createdAt?: SortOrder
    _count?: QuizCountOrderByAggregateInput
    _avg?: QuizAvgOrderByAggregateInput
    _max?: QuizMaxOrderByAggregateInput
    _min?: QuizMinOrderByAggregateInput
    _sum?: QuizSumOrderByAggregateInput
  }

  export type QuizScalarWhereWithAggregatesInput = {
    AND?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    OR?: QuizScalarWhereWithAggregatesInput[]
    NOT?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Quiz"> | number
    courseId?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
    chapterId?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
    title?: StringWithAggregatesFilter<"Quiz"> | string
    visibility?: StringWithAggregatesFilter<"Quiz"> | string
    questions?: StringWithAggregatesFilter<"Quiz"> | string
    settings?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    quizType?: StringWithAggregatesFilter<"Quiz"> | string
    attemptLimit?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
    scoreReleaseMode?: StringWithAggregatesFilter<"Quiz"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
  }

  export type QuizAttemptWhereInput = {
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    id?: IntFilter<"QuizAttempt"> | number
    userId?: IntFilter<"QuizAttempt"> | number
    quizId?: IntFilter<"QuizAttempt"> | number
    answers?: StringFilter<"QuizAttempt"> | string
    score?: IntFilter<"QuizAttempt"> | number
    totalQuestions?: IntFilter<"QuizAttempt"> | number
    correctAnswers?: IntFilter<"QuizAttempt"> | number
    percentage?: IntFilter<"QuizAttempt"> | number
    timeSpent?: IntFilter<"QuizAttempt"> | number
    detailedResults?: StringFilter<"QuizAttempt"> | string
    completedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    scoreReleasedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    endReason?: StringFilter<"QuizAttempt"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    quiz?: XOR<QuizRelationFilter, QuizWhereInput>
  }

  export type QuizAttemptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    answers?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    correctAnswers?: SortOrder
    percentage?: SortOrder
    timeSpent?: SortOrder
    detailedResults?: SortOrder
    completedAt?: SortOrder
    scoreReleasedAt?: SortOrderInput | SortOrder
    endReason?: SortOrder
    user?: UserOrderByWithRelationInput
    quiz?: QuizOrderByWithRelationInput
  }

  export type QuizAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    userId?: IntFilter<"QuizAttempt"> | number
    quizId?: IntFilter<"QuizAttempt"> | number
    answers?: StringFilter<"QuizAttempt"> | string
    score?: IntFilter<"QuizAttempt"> | number
    totalQuestions?: IntFilter<"QuizAttempt"> | number
    correctAnswers?: IntFilter<"QuizAttempt"> | number
    percentage?: IntFilter<"QuizAttempt"> | number
    timeSpent?: IntFilter<"QuizAttempt"> | number
    detailedResults?: StringFilter<"QuizAttempt"> | string
    completedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    scoreReleasedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    endReason?: StringFilter<"QuizAttempt"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    quiz?: XOR<QuizRelationFilter, QuizWhereInput>
  }, "id">

  export type QuizAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    answers?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    correctAnswers?: SortOrder
    percentage?: SortOrder
    timeSpent?: SortOrder
    detailedResults?: SortOrder
    completedAt?: SortOrder
    scoreReleasedAt?: SortOrderInput | SortOrder
    endReason?: SortOrder
    _count?: QuizAttemptCountOrderByAggregateInput
    _avg?: QuizAttemptAvgOrderByAggregateInput
    _max?: QuizAttemptMaxOrderByAggregateInput
    _min?: QuizAttemptMinOrderByAggregateInput
    _sum?: QuizAttemptSumOrderByAggregateInput
  }

  export type QuizAttemptScalarWhereWithAggregatesInput = {
    AND?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    OR?: QuizAttemptScalarWhereWithAggregatesInput[]
    NOT?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizAttempt"> | number
    userId?: IntWithAggregatesFilter<"QuizAttempt"> | number
    quizId?: IntWithAggregatesFilter<"QuizAttempt"> | number
    answers?: StringWithAggregatesFilter<"QuizAttempt"> | string
    score?: IntWithAggregatesFilter<"QuizAttempt"> | number
    totalQuestions?: IntWithAggregatesFilter<"QuizAttempt"> | number
    correctAnswers?: IntWithAggregatesFilter<"QuizAttempt"> | number
    percentage?: IntWithAggregatesFilter<"QuizAttempt"> | number
    timeSpent?: IntWithAggregatesFilter<"QuizAttempt"> | number
    detailedResults?: StringWithAggregatesFilter<"QuizAttempt"> | string
    completedAt?: DateTimeWithAggregatesFilter<"QuizAttempt"> | Date | string
    scoreReleasedAt?: DateTimeNullableWithAggregatesFilter<"QuizAttempt"> | Date | string | null
    endReason?: StringWithAggregatesFilter<"QuizAttempt"> | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: IntFilter<"Profile"> | number
    userId?: IntFilter<"Profile"> | number
    fullName?: StringNullableFilter<"Profile"> | string | null
    firstName?: StringNullableFilter<"Profile"> | string | null
    lastName?: StringNullableFilter<"Profile"> | string | null
    nickname?: StringNullableFilter<"Profile"> | string | null
    headline?: StringNullableFilter<"Profile"> | string | null
    jobTitle?: StringNullableFilter<"Profile"> | string | null
    company?: StringNullableFilter<"Profile"> | string | null
    grade?: StringNullableFilter<"Profile"> | string | null
    school?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    avatar?: StringNullableFilter<"Profile"> | string | null
    website?: StringNullableFilter<"Profile"> | string | null
    location?: StringNullableFilter<"Profile"> | string | null
    phone?: StringNullableFilter<"Profile"> | string | null
    linkedin?: StringNullableFilter<"Profile"> | string | null
    github?: StringNullableFilter<"Profile"> | string | null
    twitter?: StringNullableFilter<"Profile"> | string | null
    preferences?: StringNullableFilter<"Profile"> | string | null
    learningGoals?: StringNullableFilter<"Profile"> | string | null
    timezone?: StringNullableFilter<"Profile"> | string | null
    language?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    nickname?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    school?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    learningGoals?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    fullName?: StringNullableFilter<"Profile"> | string | null
    firstName?: StringNullableFilter<"Profile"> | string | null
    lastName?: StringNullableFilter<"Profile"> | string | null
    nickname?: StringNullableFilter<"Profile"> | string | null
    headline?: StringNullableFilter<"Profile"> | string | null
    jobTitle?: StringNullableFilter<"Profile"> | string | null
    company?: StringNullableFilter<"Profile"> | string | null
    grade?: StringNullableFilter<"Profile"> | string | null
    school?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    avatar?: StringNullableFilter<"Profile"> | string | null
    website?: StringNullableFilter<"Profile"> | string | null
    location?: StringNullableFilter<"Profile"> | string | null
    phone?: StringNullableFilter<"Profile"> | string | null
    linkedin?: StringNullableFilter<"Profile"> | string | null
    github?: StringNullableFilter<"Profile"> | string | null
    twitter?: StringNullableFilter<"Profile"> | string | null
    preferences?: StringNullableFilter<"Profile"> | string | null
    learningGoals?: StringNullableFilter<"Profile"> | string | null
    timezone?: StringNullableFilter<"Profile"> | string | null
    language?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    nickname?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    school?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    learningGoals?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Profile"> | number
    userId?: IntWithAggregatesFilter<"Profile"> | number
    fullName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    nickname?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    headline?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    jobTitle?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    company?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    grade?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    school?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    website?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    location?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    linkedin?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    github?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    preferences?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    learningGoals?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    language?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: IntFilter<"Account"> | number
    userId?: IntFilter<"Account"> | number
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: IntFilter<"Account"> | number
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Account"> | number
    userId?: IntWithAggregatesFilter<"Account"> | number
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: IntFilter<"Session"> | number
    sessionToken?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: IntFilter<"Session"> | number
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Session"> | number
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: IntWithAggregatesFilter<"Session"> | number
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: IntFilter<"PasswordResetToken"> | number
    userId?: IntFilter<"PasswordResetToken"> | number
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: IntFilter<"PasswordResetToken"> | number
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _avg?: PasswordResetTokenAvgOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
    _sum?: PasswordResetTokenSumOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PasswordResetToken"> | number
    userId?: IntWithAggregatesFilter<"PasswordResetToken"> | number
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"PasswordResetToken"> | Date | string | null
  }

  export type BlockProgressWhereInput = {
    AND?: BlockProgressWhereInput | BlockProgressWhereInput[]
    OR?: BlockProgressWhereInput[]
    NOT?: BlockProgressWhereInput | BlockProgressWhereInput[]
    id?: IntFilter<"BlockProgress"> | number
    userId?: IntFilter<"BlockProgress"> | number
    chapterId?: IntFilter<"BlockProgress"> | number
    blockId?: StringFilter<"BlockProgress"> | string
    blockType?: StringFilter<"BlockProgress"> | string
    completed?: BoolFilter<"BlockProgress"> | boolean
    score?: FloatNullableFilter<"BlockProgress"> | number | null
    attempts?: IntFilter<"BlockProgress"> | number
    data?: StringNullableFilter<"BlockProgress"> | string | null
    createdAt?: DateTimeFilter<"BlockProgress"> | Date | string
    updatedAt?: DateTimeFilter<"BlockProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    chapter?: XOR<ChapterRelationFilter, ChapterWhereInput>
  }

  export type BlockProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    blockId?: SortOrder
    blockType?: SortOrder
    completed?: SortOrder
    score?: SortOrderInput | SortOrder
    attempts?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    chapter?: ChapterOrderByWithRelationInput
  }

  export type BlockProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_chapterId_blockId?: BlockProgressUserIdChapterIdBlockIdCompoundUniqueInput
    AND?: BlockProgressWhereInput | BlockProgressWhereInput[]
    OR?: BlockProgressWhereInput[]
    NOT?: BlockProgressWhereInput | BlockProgressWhereInput[]
    userId?: IntFilter<"BlockProgress"> | number
    chapterId?: IntFilter<"BlockProgress"> | number
    blockId?: StringFilter<"BlockProgress"> | string
    blockType?: StringFilter<"BlockProgress"> | string
    completed?: BoolFilter<"BlockProgress"> | boolean
    score?: FloatNullableFilter<"BlockProgress"> | number | null
    attempts?: IntFilter<"BlockProgress"> | number
    data?: StringNullableFilter<"BlockProgress"> | string | null
    createdAt?: DateTimeFilter<"BlockProgress"> | Date | string
    updatedAt?: DateTimeFilter<"BlockProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    chapter?: XOR<ChapterRelationFilter, ChapterWhereInput>
  }, "id" | "userId_chapterId_blockId">

  export type BlockProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    blockId?: SortOrder
    blockType?: SortOrder
    completed?: SortOrder
    score?: SortOrderInput | SortOrder
    attempts?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlockProgressCountOrderByAggregateInput
    _avg?: BlockProgressAvgOrderByAggregateInput
    _max?: BlockProgressMaxOrderByAggregateInput
    _min?: BlockProgressMinOrderByAggregateInput
    _sum?: BlockProgressSumOrderByAggregateInput
  }

  export type BlockProgressScalarWhereWithAggregatesInput = {
    AND?: BlockProgressScalarWhereWithAggregatesInput | BlockProgressScalarWhereWithAggregatesInput[]
    OR?: BlockProgressScalarWhereWithAggregatesInput[]
    NOT?: BlockProgressScalarWhereWithAggregatesInput | BlockProgressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlockProgress"> | number
    userId?: IntWithAggregatesFilter<"BlockProgress"> | number
    chapterId?: IntWithAggregatesFilter<"BlockProgress"> | number
    blockId?: StringWithAggregatesFilter<"BlockProgress"> | string
    blockType?: StringWithAggregatesFilter<"BlockProgress"> | string
    completed?: BoolWithAggregatesFilter<"BlockProgress"> | boolean
    score?: FloatNullableWithAggregatesFilter<"BlockProgress"> | number | null
    attempts?: IntWithAggregatesFilter<"BlockProgress"> | number
    data?: StringNullableWithAggregatesFilter<"BlockProgress"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlockProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlockProgress"> | Date | string
  }

  export type ClassroomWhereInput = {
    AND?: ClassroomWhereInput | ClassroomWhereInput[]
    OR?: ClassroomWhereInput[]
    NOT?: ClassroomWhereInput | ClassroomWhereInput[]
    id?: IntFilter<"Classroom"> | number
    title?: StringFilter<"Classroom"> | string
    description?: StringNullableFilter<"Classroom"> | string | null
    isPrivate?: BoolFilter<"Classroom"> | boolean
    createdBy?: IntFilter<"Classroom"> | number
    createdAt?: DateTimeFilter<"Classroom"> | Date | string
    updatedAt?: DateTimeFilter<"Classroom"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    memberships?: ClassroomMembershipListRelationFilter
    posts?: ClassroomPostListRelationFilter
    resources?: ClassroomResourceListRelationFilter
  }

  export type ClassroomOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isPrivate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    memberships?: ClassroomMembershipOrderByRelationAggregateInput
    posts?: ClassroomPostOrderByRelationAggregateInput
    resources?: ClassroomResourceOrderByRelationAggregateInput
  }

  export type ClassroomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassroomWhereInput | ClassroomWhereInput[]
    OR?: ClassroomWhereInput[]
    NOT?: ClassroomWhereInput | ClassroomWhereInput[]
    title?: StringFilter<"Classroom"> | string
    description?: StringNullableFilter<"Classroom"> | string | null
    isPrivate?: BoolFilter<"Classroom"> | boolean
    createdBy?: IntFilter<"Classroom"> | number
    createdAt?: DateTimeFilter<"Classroom"> | Date | string
    updatedAt?: DateTimeFilter<"Classroom"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    memberships?: ClassroomMembershipListRelationFilter
    posts?: ClassroomPostListRelationFilter
    resources?: ClassroomResourceListRelationFilter
  }, "id">

  export type ClassroomOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isPrivate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassroomCountOrderByAggregateInput
    _avg?: ClassroomAvgOrderByAggregateInput
    _max?: ClassroomMaxOrderByAggregateInput
    _min?: ClassroomMinOrderByAggregateInput
    _sum?: ClassroomSumOrderByAggregateInput
  }

  export type ClassroomScalarWhereWithAggregatesInput = {
    AND?: ClassroomScalarWhereWithAggregatesInput | ClassroomScalarWhereWithAggregatesInput[]
    OR?: ClassroomScalarWhereWithAggregatesInput[]
    NOT?: ClassroomScalarWhereWithAggregatesInput | ClassroomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Classroom"> | number
    title?: StringWithAggregatesFilter<"Classroom"> | string
    description?: StringNullableWithAggregatesFilter<"Classroom"> | string | null
    isPrivate?: BoolWithAggregatesFilter<"Classroom"> | boolean
    createdBy?: IntWithAggregatesFilter<"Classroom"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Classroom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Classroom"> | Date | string
  }

  export type ClassroomMembershipWhereInput = {
    AND?: ClassroomMembershipWhereInput | ClassroomMembershipWhereInput[]
    OR?: ClassroomMembershipWhereInput[]
    NOT?: ClassroomMembershipWhereInput | ClassroomMembershipWhereInput[]
    id?: IntFilter<"ClassroomMembership"> | number
    classroomId?: IntFilter<"ClassroomMembership"> | number
    userId?: IntFilter<"ClassroomMembership"> | number
    role?: StringFilter<"ClassroomMembership"> | string
    status?: StringFilter<"ClassroomMembership"> | string
    createdAt?: DateTimeFilter<"ClassroomMembership"> | Date | string
    classroom?: XOR<ClassroomRelationFilter, ClassroomWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ClassroomMembershipOrderByWithRelationInput = {
    id?: SortOrder
    classroomId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    classroom?: ClassroomOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ClassroomMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    classroomId_userId?: ClassroomMembershipClassroomIdUserIdCompoundUniqueInput
    AND?: ClassroomMembershipWhereInput | ClassroomMembershipWhereInput[]
    OR?: ClassroomMembershipWhereInput[]
    NOT?: ClassroomMembershipWhereInput | ClassroomMembershipWhereInput[]
    classroomId?: IntFilter<"ClassroomMembership"> | number
    userId?: IntFilter<"ClassroomMembership"> | number
    role?: StringFilter<"ClassroomMembership"> | string
    status?: StringFilter<"ClassroomMembership"> | string
    createdAt?: DateTimeFilter<"ClassroomMembership"> | Date | string
    classroom?: XOR<ClassroomRelationFilter, ClassroomWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "classroomId_userId">

  export type ClassroomMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    classroomId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ClassroomMembershipCountOrderByAggregateInput
    _avg?: ClassroomMembershipAvgOrderByAggregateInput
    _max?: ClassroomMembershipMaxOrderByAggregateInput
    _min?: ClassroomMembershipMinOrderByAggregateInput
    _sum?: ClassroomMembershipSumOrderByAggregateInput
  }

  export type ClassroomMembershipScalarWhereWithAggregatesInput = {
    AND?: ClassroomMembershipScalarWhereWithAggregatesInput | ClassroomMembershipScalarWhereWithAggregatesInput[]
    OR?: ClassroomMembershipScalarWhereWithAggregatesInput[]
    NOT?: ClassroomMembershipScalarWhereWithAggregatesInput | ClassroomMembershipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClassroomMembership"> | number
    classroomId?: IntWithAggregatesFilter<"ClassroomMembership"> | number
    userId?: IntWithAggregatesFilter<"ClassroomMembership"> | number
    role?: StringWithAggregatesFilter<"ClassroomMembership"> | string
    status?: StringWithAggregatesFilter<"ClassroomMembership"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClassroomMembership"> | Date | string
  }

  export type ClassroomPostWhereInput = {
    AND?: ClassroomPostWhereInput | ClassroomPostWhereInput[]
    OR?: ClassroomPostWhereInput[]
    NOT?: ClassroomPostWhereInput | ClassroomPostWhereInput[]
    id?: IntFilter<"ClassroomPost"> | number
    classroomId?: IntFilter<"ClassroomPost"> | number
    authorId?: IntFilter<"ClassroomPost"> | number
    content?: StringFilter<"ClassroomPost"> | string
    pinned?: BoolFilter<"ClassroomPost"> | boolean
    createdAt?: DateTimeFilter<"ClassroomPost"> | Date | string
    updatedAt?: DateTimeFilter<"ClassroomPost"> | Date | string
    classroom?: XOR<ClassroomRelationFilter, ClassroomWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    comments?: ClassroomCommentListRelationFilter
  }

  export type ClassroomPostOrderByWithRelationInput = {
    id?: SortOrder
    classroomId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    pinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classroom?: ClassroomOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    comments?: ClassroomCommentOrderByRelationAggregateInput
  }

  export type ClassroomPostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassroomPostWhereInput | ClassroomPostWhereInput[]
    OR?: ClassroomPostWhereInput[]
    NOT?: ClassroomPostWhereInput | ClassroomPostWhereInput[]
    classroomId?: IntFilter<"ClassroomPost"> | number
    authorId?: IntFilter<"ClassroomPost"> | number
    content?: StringFilter<"ClassroomPost"> | string
    pinned?: BoolFilter<"ClassroomPost"> | boolean
    createdAt?: DateTimeFilter<"ClassroomPost"> | Date | string
    updatedAt?: DateTimeFilter<"ClassroomPost"> | Date | string
    classroom?: XOR<ClassroomRelationFilter, ClassroomWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    comments?: ClassroomCommentListRelationFilter
  }, "id">

  export type ClassroomPostOrderByWithAggregationInput = {
    id?: SortOrder
    classroomId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    pinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassroomPostCountOrderByAggregateInput
    _avg?: ClassroomPostAvgOrderByAggregateInput
    _max?: ClassroomPostMaxOrderByAggregateInput
    _min?: ClassroomPostMinOrderByAggregateInput
    _sum?: ClassroomPostSumOrderByAggregateInput
  }

  export type ClassroomPostScalarWhereWithAggregatesInput = {
    AND?: ClassroomPostScalarWhereWithAggregatesInput | ClassroomPostScalarWhereWithAggregatesInput[]
    OR?: ClassroomPostScalarWhereWithAggregatesInput[]
    NOT?: ClassroomPostScalarWhereWithAggregatesInput | ClassroomPostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClassroomPost"> | number
    classroomId?: IntWithAggregatesFilter<"ClassroomPost"> | number
    authorId?: IntWithAggregatesFilter<"ClassroomPost"> | number
    content?: StringWithAggregatesFilter<"ClassroomPost"> | string
    pinned?: BoolWithAggregatesFilter<"ClassroomPost"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ClassroomPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClassroomPost"> | Date | string
  }

  export type ClassroomCommentWhereInput = {
    AND?: ClassroomCommentWhereInput | ClassroomCommentWhereInput[]
    OR?: ClassroomCommentWhereInput[]
    NOT?: ClassroomCommentWhereInput | ClassroomCommentWhereInput[]
    id?: IntFilter<"ClassroomComment"> | number
    postId?: IntFilter<"ClassroomComment"> | number
    authorId?: IntFilter<"ClassroomComment"> | number
    content?: StringFilter<"ClassroomComment"> | string
    createdAt?: DateTimeFilter<"ClassroomComment"> | Date | string
    updatedAt?: DateTimeFilter<"ClassroomComment"> | Date | string
    post?: XOR<ClassroomPostRelationFilter, ClassroomPostWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ClassroomCommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: ClassroomPostOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type ClassroomCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassroomCommentWhereInput | ClassroomCommentWhereInput[]
    OR?: ClassroomCommentWhereInput[]
    NOT?: ClassroomCommentWhereInput | ClassroomCommentWhereInput[]
    postId?: IntFilter<"ClassroomComment"> | number
    authorId?: IntFilter<"ClassroomComment"> | number
    content?: StringFilter<"ClassroomComment"> | string
    createdAt?: DateTimeFilter<"ClassroomComment"> | Date | string
    updatedAt?: DateTimeFilter<"ClassroomComment"> | Date | string
    post?: XOR<ClassroomPostRelationFilter, ClassroomPostWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ClassroomCommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassroomCommentCountOrderByAggregateInput
    _avg?: ClassroomCommentAvgOrderByAggregateInput
    _max?: ClassroomCommentMaxOrderByAggregateInput
    _min?: ClassroomCommentMinOrderByAggregateInput
    _sum?: ClassroomCommentSumOrderByAggregateInput
  }

  export type ClassroomCommentScalarWhereWithAggregatesInput = {
    AND?: ClassroomCommentScalarWhereWithAggregatesInput | ClassroomCommentScalarWhereWithAggregatesInput[]
    OR?: ClassroomCommentScalarWhereWithAggregatesInput[]
    NOT?: ClassroomCommentScalarWhereWithAggregatesInput | ClassroomCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClassroomComment"> | number
    postId?: IntWithAggregatesFilter<"ClassroomComment"> | number
    authorId?: IntWithAggregatesFilter<"ClassroomComment"> | number
    content?: StringWithAggregatesFilter<"ClassroomComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClassroomComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClassroomComment"> | Date | string
  }

  export type ClassroomResourceWhereInput = {
    AND?: ClassroomResourceWhereInput | ClassroomResourceWhereInput[]
    OR?: ClassroomResourceWhereInput[]
    NOT?: ClassroomResourceWhereInput | ClassroomResourceWhereInput[]
    id?: IntFilter<"ClassroomResource"> | number
    classroomId?: IntFilter<"ClassroomResource"> | number
    courseId?: IntNullableFilter<"ClassroomResource"> | number | null
    quizId?: IntNullableFilter<"ClassroomResource"> | number | null
    pinnedAt?: DateTimeNullableFilter<"ClassroomResource"> | Date | string | null
    addedBy?: IntFilter<"ClassroomResource"> | number
    classroom?: XOR<ClassroomRelationFilter, ClassroomWhereInput>
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
    quiz?: XOR<QuizNullableRelationFilter, QuizWhereInput> | null
    addedByUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ClassroomResourceOrderByWithRelationInput = {
    id?: SortOrder
    classroomId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    quizId?: SortOrderInput | SortOrder
    pinnedAt?: SortOrderInput | SortOrder
    addedBy?: SortOrder
    classroom?: ClassroomOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    quiz?: QuizOrderByWithRelationInput
    addedByUser?: UserOrderByWithRelationInput
  }

  export type ClassroomResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassroomResourceWhereInput | ClassroomResourceWhereInput[]
    OR?: ClassroomResourceWhereInput[]
    NOT?: ClassroomResourceWhereInput | ClassroomResourceWhereInput[]
    classroomId?: IntFilter<"ClassroomResource"> | number
    courseId?: IntNullableFilter<"ClassroomResource"> | number | null
    quizId?: IntNullableFilter<"ClassroomResource"> | number | null
    pinnedAt?: DateTimeNullableFilter<"ClassroomResource"> | Date | string | null
    addedBy?: IntFilter<"ClassroomResource"> | number
    classroom?: XOR<ClassroomRelationFilter, ClassroomWhereInput>
    course?: XOR<CourseNullableRelationFilter, CourseWhereInput> | null
    quiz?: XOR<QuizNullableRelationFilter, QuizWhereInput> | null
    addedByUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ClassroomResourceOrderByWithAggregationInput = {
    id?: SortOrder
    classroomId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    quizId?: SortOrderInput | SortOrder
    pinnedAt?: SortOrderInput | SortOrder
    addedBy?: SortOrder
    _count?: ClassroomResourceCountOrderByAggregateInput
    _avg?: ClassroomResourceAvgOrderByAggregateInput
    _max?: ClassroomResourceMaxOrderByAggregateInput
    _min?: ClassroomResourceMinOrderByAggregateInput
    _sum?: ClassroomResourceSumOrderByAggregateInput
  }

  export type ClassroomResourceScalarWhereWithAggregatesInput = {
    AND?: ClassroomResourceScalarWhereWithAggregatesInput | ClassroomResourceScalarWhereWithAggregatesInput[]
    OR?: ClassroomResourceScalarWhereWithAggregatesInput[]
    NOT?: ClassroomResourceScalarWhereWithAggregatesInput | ClassroomResourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClassroomResource"> | number
    classroomId?: IntWithAggregatesFilter<"ClassroomResource"> | number
    courseId?: IntNullableWithAggregatesFilter<"ClassroomResource"> | number | null
    quizId?: IntNullableWithAggregatesFilter<"ClassroomResource"> | number | null
    pinnedAt?: DateTimeNullableWithAggregatesFilter<"ClassroomResource"> | Date | string | null
    addedBy?: IntWithAggregatesFilter<"ClassroomResource"> | number
  }

  export type UserCreateInput = {
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceCreateNestedManyWithoutAddedByUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostUncheckedCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentUncheckedCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceUncheckedCreateNestedManyWithoutAddedByUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUncheckedUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUncheckedUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUncheckedUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUncheckedUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    title: string
    description?: string | null
    slug: string
    visibility?: string
    createdAt?: Date | string
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    quizzes?: QuizCreateNestedManyWithoutCourseInput
    creator: UserCreateNestedOneWithoutCoursesInput
    classroomResources?: ClassroomResourceCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    slug: string
    visibility?: string
    createdBy: number
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutCourseInput
    classroomResources?: ClassroomResourceUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUpdateManyWithoutCourseNestedInput
    creator?: UserUpdateOneRequiredWithoutCoursesNestedInput
    classroomResources?: ClassroomResourceUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutCourseNestedInput
    classroomResources?: ClassroomResourceUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    slug: string
    visibility?: string
    createdBy: number
    createdAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCreateInput = {
    title: string
    order: number
    content?: string | null
    blocks?: string | null
    course: CourseCreateNestedOneWithoutChaptersInput
    quizzes?: QuizCreateNestedManyWithoutChapterInput
    blockProgress?: BlockProgressCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateInput = {
    id?: number
    courseId: number
    title: string
    order: number
    content?: string | null
    blocks?: string | null
    quizzes?: QuizUncheckedCreateNestedManyWithoutChapterInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutChaptersNestedInput
    quizzes?: QuizUpdateManyWithoutChapterNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUncheckedUpdateManyWithoutChapterNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterCreateManyInput = {
    id?: number
    courseId: number
    title: string
    order: number
    content?: string | null
    blocks?: string | null
  }

  export type ChapterUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChapterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizCreateInput = {
    title: string
    visibility?: string
    questions: string
    settings?: string | null
    quizType?: string
    attemptLimit?: number | null
    scoreReleaseMode?: string
    createdAt?: Date | string
    course?: CourseCreateNestedOneWithoutQuizzesInput
    chapter?: ChapterCreateNestedOneWithoutQuizzesInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
    classroomResources?: ClassroomResourceCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateInput = {
    id?: number
    courseId?: number | null
    chapterId?: number | null
    title: string
    visibility?: string
    questions: string
    settings?: string | null
    quizType?: string
    attemptLimit?: number | null
    scoreReleaseMode?: string
    createdAt?: Date | string
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
    classroomResources?: ClassroomResourceUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutQuizzesNestedInput
    chapter?: ChapterUpdateOneWithoutQuizzesNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
    classroomResources?: ClassroomResourceUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
    classroomResources?: ClassroomResourceUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizCreateManyInput = {
    id?: number
    courseId?: number | null
    chapterId?: number | null
    title: string
    visibility?: string
    questions: string
    settings?: string | null
    quizType?: string
    attemptLimit?: number | null
    scoreReleaseMode?: string
    createdAt?: Date | string
  }

  export type QuizUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAttemptCreateInput = {
    answers: string
    score: number
    totalQuestions: number
    correctAnswers: number
    percentage: number
    timeSpent: number
    detailedResults: string
    completedAt?: Date | string
    scoreReleasedAt?: Date | string | null
    endReason?: string
    user: UserCreateNestedOneWithoutAttemptsInput
    quiz: QuizCreateNestedOneWithoutAttemptsInput
  }

  export type QuizAttemptUncheckedCreateInput = {
    id?: number
    userId: number
    quizId: number
    answers: string
    score: number
    totalQuestions: number
    correctAnswers: number
    percentage: number
    timeSpent: number
    detailedResults: string
    completedAt?: Date | string
    scoreReleasedAt?: Date | string | null
    endReason?: string
  }

  export type QuizAttemptUpdateInput = {
    answers?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    percentage?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    detailedResults?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scoreReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endReason?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAttemptsNestedInput
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    percentage?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    detailedResults?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scoreReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endReason?: StringFieldUpdateOperationsInput | string
  }

  export type QuizAttemptCreateManyInput = {
    id?: number
    userId: number
    quizId: number
    answers: string
    score: number
    totalQuestions: number
    correctAnswers: number
    percentage: number
    timeSpent: number
    detailedResults: string
    completedAt?: Date | string
    scoreReleasedAt?: Date | string | null
    endReason?: string
  }

  export type QuizAttemptUpdateManyMutationInput = {
    answers?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    percentage?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    detailedResults?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scoreReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endReason?: StringFieldUpdateOperationsInput | string
  }

  export type QuizAttemptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    percentage?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    detailedResults?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scoreReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endReason?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateInput = {
    fullName?: string | null
    firstName?: string | null
    lastName?: string | null
    nickname?: string | null
    headline?: string | null
    jobTitle?: string | null
    company?: string | null
    grade?: string | null
    school?: string | null
    bio?: string | null
    avatar?: string | null
    website?: string | null
    location?: string | null
    phone?: string | null
    linkedin?: string | null
    github?: string | null
    twitter?: string | null
    preferences?: string | null
    learningGoals?: string | null
    timezone?: string | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: number
    userId: number
    fullName?: string | null
    firstName?: string | null
    lastName?: string | null
    nickname?: string | null
    headline?: string | null
    jobTitle?: string | null
    company?: string | null
    grade?: string | null
    school?: string | null
    bio?: string | null
    avatar?: string | null
    website?: string | null
    location?: string | null
    phone?: string | null
    linkedin?: string | null
    github?: string | null
    twitter?: string | null
    preferences?: string | null
    learningGoals?: string | null
    timezone?: string | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateInput = {
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    learningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    learningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateManyInput = {
    id?: number
    userId: number
    fullName?: string | null
    firstName?: string | null
    lastName?: string | null
    nickname?: string | null
    headline?: string | null
    jobTitle?: string | null
    company?: string | null
    grade?: string | null
    school?: string | null
    bio?: string | null
    avatar?: string | null
    website?: string | null
    location?: string | null
    phone?: string | null
    linkedin?: string | null
    github?: string | null
    twitter?: string | null
    preferences?: string | null
    learningGoals?: string | null
    timezone?: string | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    learningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    learningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: number
    userId: number
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: number
    userId: number
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    sessionToken: string
    userId: number
    expires: Date | string
  }

  export type SessionUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: number
    sessionToken: string
    userId: number
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
  }

  export type PasswordResetTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockProgressCreateInput = {
    blockId: string
    blockType: string
    completed?: boolean
    score?: number | null
    attempts?: number
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBlockProgressInput
    chapter: ChapterCreateNestedOneWithoutBlockProgressInput
  }

  export type BlockProgressUncheckedCreateInput = {
    id?: number
    userId: number
    chapterId: number
    blockId: string
    blockType: string
    completed?: boolean
    score?: number | null
    attempts?: number
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockProgressUpdateInput = {
    blockId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlockProgressNestedInput
    chapter?: ChapterUpdateOneRequiredWithoutBlockProgressNestedInput
  }

  export type BlockProgressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    blockId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockProgressCreateManyInput = {
    id?: number
    userId: number
    chapterId: number
    blockId: string
    blockType: string
    completed?: boolean
    score?: number | null
    attempts?: number
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockProgressUpdateManyMutationInput = {
    blockId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockProgressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    blockId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomCreateInput = {
    title: string
    description?: string | null
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutClassroomsCreatedInput
    memberships?: ClassroomMembershipCreateNestedManyWithoutClassroomInput
    posts?: ClassroomPostCreateNestedManyWithoutClassroomInput
    resources?: ClassroomResourceCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    isPrivate?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutClassroomInput
    posts?: ClassroomPostUncheckedCreateNestedManyWithoutClassroomInput
    resources?: ClassroomResourceUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutClassroomsCreatedNestedInput
    memberships?: ClassroomMembershipUpdateManyWithoutClassroomNestedInput
    posts?: ClassroomPostUpdateManyWithoutClassroomNestedInput
    resources?: ClassroomResourceUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: ClassroomMembershipUncheckedUpdateManyWithoutClassroomNestedInput
    posts?: ClassroomPostUncheckedUpdateManyWithoutClassroomNestedInput
    resources?: ClassroomResourceUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    isPrivate?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomMembershipCreateInput = {
    role?: string
    status?: string
    createdAt?: Date | string
    classroom: ClassroomCreateNestedOneWithoutMembershipsInput
    user: UserCreateNestedOneWithoutClassroomMembershipsInput
  }

  export type ClassroomMembershipUncheckedCreateInput = {
    id?: number
    classroomId: number
    userId: number
    role?: string
    status?: string
    createdAt?: Date | string
  }

  export type ClassroomMembershipUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: ClassroomUpdateOneRequiredWithoutMembershipsNestedInput
    user?: UserUpdateOneRequiredWithoutClassroomMembershipsNestedInput
  }

  export type ClassroomMembershipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomMembershipCreateManyInput = {
    id?: number
    classroomId: number
    userId: number
    role?: string
    status?: string
    createdAt?: Date | string
  }

  export type ClassroomMembershipUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomMembershipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomPostCreateInput = {
    content: string
    pinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    classroom: ClassroomCreateNestedOneWithoutPostsInput
    author: UserCreateNestedOneWithoutClassroomPostsInput
    comments?: ClassroomCommentCreateNestedManyWithoutPostInput
  }

  export type ClassroomPostUncheckedCreateInput = {
    id?: number
    classroomId: number
    authorId: number
    content: string
    pinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ClassroomCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type ClassroomPostUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: ClassroomUpdateOneRequiredWithoutPostsNestedInput
    author?: UserUpdateOneRequiredWithoutClassroomPostsNestedInput
    comments?: ClassroomCommentUpdateManyWithoutPostNestedInput
  }

  export type ClassroomPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ClassroomCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ClassroomPostCreateManyInput = {
    id?: number
    classroomId: number
    authorId: number
    content: string
    pinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomPostUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomCommentCreateInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: ClassroomPostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutClassroomCommentsInput
  }

  export type ClassroomCommentUncheckedCreateInput = {
    id?: number
    postId: number
    authorId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomCommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: ClassroomPostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutClassroomCommentsNestedInput
  }

  export type ClassroomCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomCommentCreateManyInput = {
    id?: number
    postId: number
    authorId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomCommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomResourceCreateInput = {
    pinnedAt?: Date | string | null
    classroom: ClassroomCreateNestedOneWithoutResourcesInput
    course?: CourseCreateNestedOneWithoutClassroomResourcesInput
    quiz?: QuizCreateNestedOneWithoutClassroomResourcesInput
    addedByUser: UserCreateNestedOneWithoutClassroomResourcesAddedInput
  }

  export type ClassroomResourceUncheckedCreateInput = {
    id?: number
    classroomId: number
    courseId?: number | null
    quizId?: number | null
    pinnedAt?: Date | string | null
    addedBy: number
  }

  export type ClassroomResourceUpdateInput = {
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: ClassroomUpdateOneRequiredWithoutResourcesNestedInput
    course?: CourseUpdateOneWithoutClassroomResourcesNestedInput
    quiz?: QuizUpdateOneWithoutClassroomResourcesNestedInput
    addedByUser?: UserUpdateOneRequiredWithoutClassroomResourcesAddedNestedInput
  }

  export type ClassroomResourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedBy?: IntFieldUpdateOperationsInput | number
  }

  export type ClassroomResourceCreateManyInput = {
    id?: number
    classroomId: number
    courseId?: number | null
    quizId?: number | null
    pinnedAt?: Date | string | null
    addedBy: number
  }

  export type ClassroomResourceUpdateManyMutationInput = {
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassroomResourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedBy?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type QuizAttemptListRelationFilter = {
    every?: QuizAttemptWhereInput
    some?: QuizAttemptWhereInput
    none?: QuizAttemptWhereInput
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type BlockProgressListRelationFilter = {
    every?: BlockProgressWhereInput
    some?: BlockProgressWhereInput
    none?: BlockProgressWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type ClassroomListRelationFilter = {
    every?: ClassroomWhereInput
    some?: ClassroomWhereInput
    none?: ClassroomWhereInput
  }

  export type ClassroomMembershipListRelationFilter = {
    every?: ClassroomMembershipWhereInput
    some?: ClassroomMembershipWhereInput
    none?: ClassroomMembershipWhereInput
  }

  export type ClassroomPostListRelationFilter = {
    every?: ClassroomPostWhereInput
    some?: ClassroomPostWhereInput
    none?: ClassroomPostWhereInput
  }

  export type ClassroomCommentListRelationFilter = {
    every?: ClassroomCommentWhereInput
    some?: ClassroomCommentWhereInput
    none?: ClassroomCommentWhereInput
  }

  export type ClassroomResourceListRelationFilter = {
    every?: ClassroomResourceWhereInput
    some?: ClassroomResourceWhereInput
    none?: ClassroomResourceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassroomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassroomMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassroomPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassroomCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassroomResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ChapterListRelationFilter = {
    every?: ChapterWhereInput
    some?: ChapterWhereInput
    none?: ChapterWhereInput
  }

  export type QuizListRelationFilter = {
    every?: QuizWhereInput
    some?: QuizWhereInput
    none?: QuizWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    visibility?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type ChapterCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    order?: SortOrder
    content?: SortOrder
    blocks?: SortOrder
  }

  export type ChapterAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
  }

  export type ChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    order?: SortOrder
    content?: SortOrder
    blocks?: SortOrder
  }

  export type ChapterMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    order?: SortOrder
    content?: SortOrder
    blocks?: SortOrder
  }

  export type ChapterSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CourseNullableRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type ChapterNullableRelationFilter = {
    is?: ChapterWhereInput | null
    isNot?: ChapterWhereInput | null
  }

  export type QuizCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    chapterId?: SortOrder
    title?: SortOrder
    visibility?: SortOrder
    questions?: SortOrder
    settings?: SortOrder
    quizType?: SortOrder
    attemptLimit?: SortOrder
    scoreReleaseMode?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    chapterId?: SortOrder
    attemptLimit?: SortOrder
  }

  export type QuizMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    chapterId?: SortOrder
    title?: SortOrder
    visibility?: SortOrder
    questions?: SortOrder
    settings?: SortOrder
    quizType?: SortOrder
    attemptLimit?: SortOrder
    scoreReleaseMode?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    chapterId?: SortOrder
    title?: SortOrder
    visibility?: SortOrder
    questions?: SortOrder
    settings?: SortOrder
    quizType?: SortOrder
    attemptLimit?: SortOrder
    scoreReleaseMode?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    chapterId?: SortOrder
    attemptLimit?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type QuizRelationFilter = {
    is?: QuizWhereInput
    isNot?: QuizWhereInput
  }

  export type QuizAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    answers?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    correctAnswers?: SortOrder
    percentage?: SortOrder
    timeSpent?: SortOrder
    detailedResults?: SortOrder
    completedAt?: SortOrder
    scoreReleasedAt?: SortOrder
    endReason?: SortOrder
  }

  export type QuizAttemptAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    correctAnswers?: SortOrder
    percentage?: SortOrder
    timeSpent?: SortOrder
  }

  export type QuizAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    answers?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    correctAnswers?: SortOrder
    percentage?: SortOrder
    timeSpent?: SortOrder
    detailedResults?: SortOrder
    completedAt?: SortOrder
    scoreReleasedAt?: SortOrder
    endReason?: SortOrder
  }

  export type QuizAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    answers?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    correctAnswers?: SortOrder
    percentage?: SortOrder
    timeSpent?: SortOrder
    detailedResults?: SortOrder
    completedAt?: SortOrder
    scoreReleasedAt?: SortOrder
    endReason?: SortOrder
  }

  export type QuizAttemptSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    correctAnswers?: SortOrder
    percentage?: SortOrder
    timeSpent?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    nickname?: SortOrder
    headline?: SortOrder
    jobTitle?: SortOrder
    company?: SortOrder
    grade?: SortOrder
    school?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    website?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    linkedin?: SortOrder
    github?: SortOrder
    twitter?: SortOrder
    preferences?: SortOrder
    learningGoals?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    nickname?: SortOrder
    headline?: SortOrder
    jobTitle?: SortOrder
    company?: SortOrder
    grade?: SortOrder
    school?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    website?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    linkedin?: SortOrder
    github?: SortOrder
    twitter?: SortOrder
    preferences?: SortOrder
    learningGoals?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    nickname?: SortOrder
    headline?: SortOrder
    jobTitle?: SortOrder
    company?: SortOrder
    grade?: SortOrder
    school?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    website?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    linkedin?: SortOrder
    github?: SortOrder
    twitter?: SortOrder
    preferences?: SortOrder
    learningGoals?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires_at?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
  }

  export type PasswordResetTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
  }

  export type PasswordResetTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ChapterRelationFilter = {
    is?: ChapterWhereInput
    isNot?: ChapterWhereInput
  }

  export type BlockProgressUserIdChapterIdBlockIdCompoundUniqueInput = {
    userId: number
    chapterId: number
    blockId: string
  }

  export type BlockProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    blockId?: SortOrder
    blockType?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    attempts?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockProgressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    score?: SortOrder
    attempts?: SortOrder
  }

  export type BlockProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    blockId?: SortOrder
    blockType?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    attempts?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    blockId?: SortOrder
    blockType?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    attempts?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockProgressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    score?: SortOrder
    attempts?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ClassroomCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isPrivate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type ClassroomMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isPrivate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isPrivate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type ClassroomRelationFilter = {
    is?: ClassroomWhereInput
    isNot?: ClassroomWhereInput
  }

  export type ClassroomMembershipClassroomIdUserIdCompoundUniqueInput = {
    classroomId: number
    userId: number
  }

  export type ClassroomMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClassroomMembershipAvgOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    userId?: SortOrder
  }

  export type ClassroomMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClassroomMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClassroomMembershipSumOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    userId?: SortOrder
  }

  export type ClassroomPostCountOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    pinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomPostAvgOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    authorId?: SortOrder
  }

  export type ClassroomPostMaxOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    pinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomPostMinOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    pinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomPostSumOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    authorId?: SortOrder
  }

  export type ClassroomPostRelationFilter = {
    is?: ClassroomPostWhereInput
    isNot?: ClassroomPostWhereInput
  }

  export type ClassroomCommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
  }

  export type ClassroomCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomCommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomCommentSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
  }

  export type QuizNullableRelationFilter = {
    is?: QuizWhereInput | null
    isNot?: QuizWhereInput | null
  }

  export type ClassroomResourceCountOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    courseId?: SortOrder
    quizId?: SortOrder
    pinnedAt?: SortOrder
    addedBy?: SortOrder
  }

  export type ClassroomResourceAvgOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    courseId?: SortOrder
    quizId?: SortOrder
    addedBy?: SortOrder
  }

  export type ClassroomResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    courseId?: SortOrder
    quizId?: SortOrder
    pinnedAt?: SortOrder
    addedBy?: SortOrder
  }

  export type ClassroomResourceMinOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    courseId?: SortOrder
    quizId?: SortOrder
    pinnedAt?: SortOrder
    addedBy?: SortOrder
  }

  export type ClassroomResourceSumOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    courseId?: SortOrder
    quizId?: SortOrder
    addedBy?: SortOrder
  }

  export type CourseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type QuizAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type BlockProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<BlockProgressCreateWithoutUserInput, BlockProgressUncheckedCreateWithoutUserInput> | BlockProgressCreateWithoutUserInput[] | BlockProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlockProgressCreateOrConnectWithoutUserInput | BlockProgressCreateOrConnectWithoutUserInput[]
    createMany?: BlockProgressCreateManyUserInputEnvelope
    connect?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type ClassroomCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ClassroomCreateWithoutCreatorInput, ClassroomUncheckedCreateWithoutCreatorInput> | ClassroomCreateWithoutCreatorInput[] | ClassroomUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutCreatorInput | ClassroomCreateOrConnectWithoutCreatorInput[]
    createMany?: ClassroomCreateManyCreatorInputEnvelope
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type ClassroomMembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<ClassroomMembershipCreateWithoutUserInput, ClassroomMembershipUncheckedCreateWithoutUserInput> | ClassroomMembershipCreateWithoutUserInput[] | ClassroomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassroomMembershipCreateOrConnectWithoutUserInput | ClassroomMembershipCreateOrConnectWithoutUserInput[]
    createMany?: ClassroomMembershipCreateManyUserInputEnvelope
    connect?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
  }

  export type ClassroomPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ClassroomPostCreateWithoutAuthorInput, ClassroomPostUncheckedCreateWithoutAuthorInput> | ClassroomPostCreateWithoutAuthorInput[] | ClassroomPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClassroomPostCreateOrConnectWithoutAuthorInput | ClassroomPostCreateOrConnectWithoutAuthorInput[]
    createMany?: ClassroomPostCreateManyAuthorInputEnvelope
    connect?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
  }

  export type ClassroomCommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ClassroomCommentCreateWithoutAuthorInput, ClassroomCommentUncheckedCreateWithoutAuthorInput> | ClassroomCommentCreateWithoutAuthorInput[] | ClassroomCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClassroomCommentCreateOrConnectWithoutAuthorInput | ClassroomCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: ClassroomCommentCreateManyAuthorInputEnvelope
    connect?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
  }

  export type ClassroomResourceCreateNestedManyWithoutAddedByUserInput = {
    create?: XOR<ClassroomResourceCreateWithoutAddedByUserInput, ClassroomResourceUncheckedCreateWithoutAddedByUserInput> | ClassroomResourceCreateWithoutAddedByUserInput[] | ClassroomResourceUncheckedCreateWithoutAddedByUserInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutAddedByUserInput | ClassroomResourceCreateOrConnectWithoutAddedByUserInput[]
    createMany?: ClassroomResourceCreateManyAddedByUserInputEnvelope
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type BlockProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlockProgressCreateWithoutUserInput, BlockProgressUncheckedCreateWithoutUserInput> | BlockProgressCreateWithoutUserInput[] | BlockProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlockProgressCreateOrConnectWithoutUserInput | BlockProgressCreateOrConnectWithoutUserInput[]
    createMany?: BlockProgressCreateManyUserInputEnvelope
    connect?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type ClassroomUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ClassroomCreateWithoutCreatorInput, ClassroomUncheckedCreateWithoutCreatorInput> | ClassroomCreateWithoutCreatorInput[] | ClassroomUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutCreatorInput | ClassroomCreateOrConnectWithoutCreatorInput[]
    createMany?: ClassroomCreateManyCreatorInputEnvelope
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type ClassroomMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClassroomMembershipCreateWithoutUserInput, ClassroomMembershipUncheckedCreateWithoutUserInput> | ClassroomMembershipCreateWithoutUserInput[] | ClassroomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassroomMembershipCreateOrConnectWithoutUserInput | ClassroomMembershipCreateOrConnectWithoutUserInput[]
    createMany?: ClassroomMembershipCreateManyUserInputEnvelope
    connect?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
  }

  export type ClassroomPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ClassroomPostCreateWithoutAuthorInput, ClassroomPostUncheckedCreateWithoutAuthorInput> | ClassroomPostCreateWithoutAuthorInput[] | ClassroomPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClassroomPostCreateOrConnectWithoutAuthorInput | ClassroomPostCreateOrConnectWithoutAuthorInput[]
    createMany?: ClassroomPostCreateManyAuthorInputEnvelope
    connect?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
  }

  export type ClassroomCommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ClassroomCommentCreateWithoutAuthorInput, ClassroomCommentUncheckedCreateWithoutAuthorInput> | ClassroomCommentCreateWithoutAuthorInput[] | ClassroomCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClassroomCommentCreateOrConnectWithoutAuthorInput | ClassroomCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: ClassroomCommentCreateManyAuthorInputEnvelope
    connect?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
  }

  export type ClassroomResourceUncheckedCreateNestedManyWithoutAddedByUserInput = {
    create?: XOR<ClassroomResourceCreateWithoutAddedByUserInput, ClassroomResourceUncheckedCreateWithoutAddedByUserInput> | ClassroomResourceCreateWithoutAddedByUserInput[] | ClassroomResourceUncheckedCreateWithoutAddedByUserInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutAddedByUserInput | ClassroomResourceCreateOrConnectWithoutAddedByUserInput[]
    createMany?: ClassroomResourceCreateManyAddedByUserInputEnvelope
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CourseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatorInput | CourseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatorInput | CourseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatorInput | CourseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type QuizAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutUserInput | QuizAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutUserInput | QuizAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutUserInput | QuizAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type BlockProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlockProgressCreateWithoutUserInput, BlockProgressUncheckedCreateWithoutUserInput> | BlockProgressCreateWithoutUserInput[] | BlockProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlockProgressCreateOrConnectWithoutUserInput | BlockProgressCreateOrConnectWithoutUserInput[]
    upsert?: BlockProgressUpsertWithWhereUniqueWithoutUserInput | BlockProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlockProgressCreateManyUserInputEnvelope
    set?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    disconnect?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    delete?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    connect?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    update?: BlockProgressUpdateWithWhereUniqueWithoutUserInput | BlockProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlockProgressUpdateManyWithWhereWithoutUserInput | BlockProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlockProgressScalarWhereInput | BlockProgressScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type ClassroomUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ClassroomCreateWithoutCreatorInput, ClassroomUncheckedCreateWithoutCreatorInput> | ClassroomCreateWithoutCreatorInput[] | ClassroomUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutCreatorInput | ClassroomCreateOrConnectWithoutCreatorInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutCreatorInput | ClassroomUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ClassroomCreateManyCreatorInputEnvelope
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutCreatorInput | ClassroomUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutCreatorInput | ClassroomUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type ClassroomMembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClassroomMembershipCreateWithoutUserInput, ClassroomMembershipUncheckedCreateWithoutUserInput> | ClassroomMembershipCreateWithoutUserInput[] | ClassroomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassroomMembershipCreateOrConnectWithoutUserInput | ClassroomMembershipCreateOrConnectWithoutUserInput[]
    upsert?: ClassroomMembershipUpsertWithWhereUniqueWithoutUserInput | ClassroomMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClassroomMembershipCreateManyUserInputEnvelope
    set?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    disconnect?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    delete?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    connect?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    update?: ClassroomMembershipUpdateWithWhereUniqueWithoutUserInput | ClassroomMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClassroomMembershipUpdateManyWithWhereWithoutUserInput | ClassroomMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClassroomMembershipScalarWhereInput | ClassroomMembershipScalarWhereInput[]
  }

  export type ClassroomPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ClassroomPostCreateWithoutAuthorInput, ClassroomPostUncheckedCreateWithoutAuthorInput> | ClassroomPostCreateWithoutAuthorInput[] | ClassroomPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClassroomPostCreateOrConnectWithoutAuthorInput | ClassroomPostCreateOrConnectWithoutAuthorInput[]
    upsert?: ClassroomPostUpsertWithWhereUniqueWithoutAuthorInput | ClassroomPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ClassroomPostCreateManyAuthorInputEnvelope
    set?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    disconnect?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    delete?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    connect?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    update?: ClassroomPostUpdateWithWhereUniqueWithoutAuthorInput | ClassroomPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ClassroomPostUpdateManyWithWhereWithoutAuthorInput | ClassroomPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ClassroomPostScalarWhereInput | ClassroomPostScalarWhereInput[]
  }

  export type ClassroomCommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ClassroomCommentCreateWithoutAuthorInput, ClassroomCommentUncheckedCreateWithoutAuthorInput> | ClassroomCommentCreateWithoutAuthorInput[] | ClassroomCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClassroomCommentCreateOrConnectWithoutAuthorInput | ClassroomCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: ClassroomCommentUpsertWithWhereUniqueWithoutAuthorInput | ClassroomCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ClassroomCommentCreateManyAuthorInputEnvelope
    set?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    disconnect?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    delete?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    connect?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    update?: ClassroomCommentUpdateWithWhereUniqueWithoutAuthorInput | ClassroomCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ClassroomCommentUpdateManyWithWhereWithoutAuthorInput | ClassroomCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ClassroomCommentScalarWhereInput | ClassroomCommentScalarWhereInput[]
  }

  export type ClassroomResourceUpdateManyWithoutAddedByUserNestedInput = {
    create?: XOR<ClassroomResourceCreateWithoutAddedByUserInput, ClassroomResourceUncheckedCreateWithoutAddedByUserInput> | ClassroomResourceCreateWithoutAddedByUserInput[] | ClassroomResourceUncheckedCreateWithoutAddedByUserInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutAddedByUserInput | ClassroomResourceCreateOrConnectWithoutAddedByUserInput[]
    upsert?: ClassroomResourceUpsertWithWhereUniqueWithoutAddedByUserInput | ClassroomResourceUpsertWithWhereUniqueWithoutAddedByUserInput[]
    createMany?: ClassroomResourceCreateManyAddedByUserInputEnvelope
    set?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    disconnect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    delete?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    update?: ClassroomResourceUpdateWithWhereUniqueWithoutAddedByUserInput | ClassroomResourceUpdateWithWhereUniqueWithoutAddedByUserInput[]
    updateMany?: ClassroomResourceUpdateManyWithWhereWithoutAddedByUserInput | ClassroomResourceUpdateManyWithWhereWithoutAddedByUserInput[]
    deleteMany?: ClassroomResourceScalarWhereInput | ClassroomResourceScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatorInput | CourseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatorInput | CourseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatorInput | CourseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutUserInput | QuizAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutUserInput | QuizAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutUserInput | QuizAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type BlockProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlockProgressCreateWithoutUserInput, BlockProgressUncheckedCreateWithoutUserInput> | BlockProgressCreateWithoutUserInput[] | BlockProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlockProgressCreateOrConnectWithoutUserInput | BlockProgressCreateOrConnectWithoutUserInput[]
    upsert?: BlockProgressUpsertWithWhereUniqueWithoutUserInput | BlockProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlockProgressCreateManyUserInputEnvelope
    set?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    disconnect?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    delete?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    connect?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    update?: BlockProgressUpdateWithWhereUniqueWithoutUserInput | BlockProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlockProgressUpdateManyWithWhereWithoutUserInput | BlockProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlockProgressScalarWhereInput | BlockProgressScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type ClassroomUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ClassroomCreateWithoutCreatorInput, ClassroomUncheckedCreateWithoutCreatorInput> | ClassroomCreateWithoutCreatorInput[] | ClassroomUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutCreatorInput | ClassroomCreateOrConnectWithoutCreatorInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutCreatorInput | ClassroomUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ClassroomCreateManyCreatorInputEnvelope
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutCreatorInput | ClassroomUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutCreatorInput | ClassroomUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type ClassroomMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClassroomMembershipCreateWithoutUserInput, ClassroomMembershipUncheckedCreateWithoutUserInput> | ClassroomMembershipCreateWithoutUserInput[] | ClassroomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassroomMembershipCreateOrConnectWithoutUserInput | ClassroomMembershipCreateOrConnectWithoutUserInput[]
    upsert?: ClassroomMembershipUpsertWithWhereUniqueWithoutUserInput | ClassroomMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClassroomMembershipCreateManyUserInputEnvelope
    set?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    disconnect?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    delete?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    connect?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    update?: ClassroomMembershipUpdateWithWhereUniqueWithoutUserInput | ClassroomMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClassroomMembershipUpdateManyWithWhereWithoutUserInput | ClassroomMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClassroomMembershipScalarWhereInput | ClassroomMembershipScalarWhereInput[]
  }

  export type ClassroomPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ClassroomPostCreateWithoutAuthorInput, ClassroomPostUncheckedCreateWithoutAuthorInput> | ClassroomPostCreateWithoutAuthorInput[] | ClassroomPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClassroomPostCreateOrConnectWithoutAuthorInput | ClassroomPostCreateOrConnectWithoutAuthorInput[]
    upsert?: ClassroomPostUpsertWithWhereUniqueWithoutAuthorInput | ClassroomPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ClassroomPostCreateManyAuthorInputEnvelope
    set?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    disconnect?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    delete?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    connect?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    update?: ClassroomPostUpdateWithWhereUniqueWithoutAuthorInput | ClassroomPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ClassroomPostUpdateManyWithWhereWithoutAuthorInput | ClassroomPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ClassroomPostScalarWhereInput | ClassroomPostScalarWhereInput[]
  }

  export type ClassroomCommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ClassroomCommentCreateWithoutAuthorInput, ClassroomCommentUncheckedCreateWithoutAuthorInput> | ClassroomCommentCreateWithoutAuthorInput[] | ClassroomCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClassroomCommentCreateOrConnectWithoutAuthorInput | ClassroomCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: ClassroomCommentUpsertWithWhereUniqueWithoutAuthorInput | ClassroomCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ClassroomCommentCreateManyAuthorInputEnvelope
    set?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    disconnect?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    delete?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    connect?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    update?: ClassroomCommentUpdateWithWhereUniqueWithoutAuthorInput | ClassroomCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ClassroomCommentUpdateManyWithWhereWithoutAuthorInput | ClassroomCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ClassroomCommentScalarWhereInput | ClassroomCommentScalarWhereInput[]
  }

  export type ClassroomResourceUncheckedUpdateManyWithoutAddedByUserNestedInput = {
    create?: XOR<ClassroomResourceCreateWithoutAddedByUserInput, ClassroomResourceUncheckedCreateWithoutAddedByUserInput> | ClassroomResourceCreateWithoutAddedByUserInput[] | ClassroomResourceUncheckedCreateWithoutAddedByUserInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutAddedByUserInput | ClassroomResourceCreateOrConnectWithoutAddedByUserInput[]
    upsert?: ClassroomResourceUpsertWithWhereUniqueWithoutAddedByUserInput | ClassroomResourceUpsertWithWhereUniqueWithoutAddedByUserInput[]
    createMany?: ClassroomResourceCreateManyAddedByUserInputEnvelope
    set?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    disconnect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    delete?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    update?: ClassroomResourceUpdateWithWhereUniqueWithoutAddedByUserInput | ClassroomResourceUpdateWithWhereUniqueWithoutAddedByUserInput[]
    updateMany?: ClassroomResourceUpdateManyWithWhereWithoutAddedByUserInput | ClassroomResourceUpdateManyWithWhereWithoutAddedByUserInput[]
    deleteMany?: ClassroomResourceScalarWhereInput | ClassroomResourceScalarWhereInput[]
  }

  export type ChapterCreateNestedManyWithoutCourseInput = {
    create?: XOR<ChapterCreateWithoutCourseInput, ChapterUncheckedCreateWithoutCourseInput> | ChapterCreateWithoutCourseInput[] | ChapterUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutCourseInput | ChapterCreateOrConnectWithoutCourseInput[]
    createMany?: ChapterCreateManyCourseInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type QuizCreateNestedManyWithoutCourseInput = {
    create?: XOR<QuizCreateWithoutCourseInput, QuizUncheckedCreateWithoutCourseInput> | QuizCreateWithoutCourseInput[] | QuizUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutCourseInput | QuizCreateOrConnectWithoutCourseInput[]
    createMany?: QuizCreateManyCourseInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCoursesInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type ClassroomResourceCreateNestedManyWithoutCourseInput = {
    create?: XOR<ClassroomResourceCreateWithoutCourseInput, ClassroomResourceUncheckedCreateWithoutCourseInput> | ClassroomResourceCreateWithoutCourseInput[] | ClassroomResourceUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutCourseInput | ClassroomResourceCreateOrConnectWithoutCourseInput[]
    createMany?: ClassroomResourceCreateManyCourseInputEnvelope
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
  }

  export type ChapterUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ChapterCreateWithoutCourseInput, ChapterUncheckedCreateWithoutCourseInput> | ChapterCreateWithoutCourseInput[] | ChapterUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutCourseInput | ChapterCreateOrConnectWithoutCourseInput[]
    createMany?: ChapterCreateManyCourseInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<QuizCreateWithoutCourseInput, QuizUncheckedCreateWithoutCourseInput> | QuizCreateWithoutCourseInput[] | QuizUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutCourseInput | QuizCreateOrConnectWithoutCourseInput[]
    createMany?: QuizCreateManyCourseInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type ClassroomResourceUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ClassroomResourceCreateWithoutCourseInput, ClassroomResourceUncheckedCreateWithoutCourseInput> | ClassroomResourceCreateWithoutCourseInput[] | ClassroomResourceUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutCourseInput | ClassroomResourceCreateOrConnectWithoutCourseInput[]
    createMany?: ClassroomResourceCreateManyCourseInputEnvelope
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
  }

  export type ChapterUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ChapterCreateWithoutCourseInput, ChapterUncheckedCreateWithoutCourseInput> | ChapterCreateWithoutCourseInput[] | ChapterUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutCourseInput | ChapterCreateOrConnectWithoutCourseInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutCourseInput | ChapterUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ChapterCreateManyCourseInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutCourseInput | ChapterUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutCourseInput | ChapterUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type QuizUpdateManyWithoutCourseNestedInput = {
    create?: XOR<QuizCreateWithoutCourseInput, QuizUncheckedCreateWithoutCourseInput> | QuizCreateWithoutCourseInput[] | QuizUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutCourseInput | QuizCreateOrConnectWithoutCourseInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutCourseInput | QuizUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: QuizCreateManyCourseInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutCourseInput | QuizUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutCourseInput | QuizUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    upsert?: UserUpsertWithoutCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoursesInput, UserUpdateWithoutCoursesInput>, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type ClassroomResourceUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ClassroomResourceCreateWithoutCourseInput, ClassroomResourceUncheckedCreateWithoutCourseInput> | ClassroomResourceCreateWithoutCourseInput[] | ClassroomResourceUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutCourseInput | ClassroomResourceCreateOrConnectWithoutCourseInput[]
    upsert?: ClassroomResourceUpsertWithWhereUniqueWithoutCourseInput | ClassroomResourceUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ClassroomResourceCreateManyCourseInputEnvelope
    set?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    disconnect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    delete?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    update?: ClassroomResourceUpdateWithWhereUniqueWithoutCourseInput | ClassroomResourceUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ClassroomResourceUpdateManyWithWhereWithoutCourseInput | ClassroomResourceUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ClassroomResourceScalarWhereInput | ClassroomResourceScalarWhereInput[]
  }

  export type ChapterUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ChapterCreateWithoutCourseInput, ChapterUncheckedCreateWithoutCourseInput> | ChapterCreateWithoutCourseInput[] | ChapterUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutCourseInput | ChapterCreateOrConnectWithoutCourseInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutCourseInput | ChapterUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ChapterCreateManyCourseInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutCourseInput | ChapterUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutCourseInput | ChapterUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<QuizCreateWithoutCourseInput, QuizUncheckedCreateWithoutCourseInput> | QuizCreateWithoutCourseInput[] | QuizUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutCourseInput | QuizCreateOrConnectWithoutCourseInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutCourseInput | QuizUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: QuizCreateManyCourseInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutCourseInput | QuizUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutCourseInput | QuizUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type ClassroomResourceUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ClassroomResourceCreateWithoutCourseInput, ClassroomResourceUncheckedCreateWithoutCourseInput> | ClassroomResourceCreateWithoutCourseInput[] | ClassroomResourceUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutCourseInput | ClassroomResourceCreateOrConnectWithoutCourseInput[]
    upsert?: ClassroomResourceUpsertWithWhereUniqueWithoutCourseInput | ClassroomResourceUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ClassroomResourceCreateManyCourseInputEnvelope
    set?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    disconnect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    delete?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    update?: ClassroomResourceUpdateWithWhereUniqueWithoutCourseInput | ClassroomResourceUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ClassroomResourceUpdateManyWithWhereWithoutCourseInput | ClassroomResourceUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ClassroomResourceScalarWhereInput | ClassroomResourceScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutChaptersInput = {
    create?: XOR<CourseCreateWithoutChaptersInput, CourseUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: CourseCreateOrConnectWithoutChaptersInput
    connect?: CourseWhereUniqueInput
  }

  export type QuizCreateNestedManyWithoutChapterInput = {
    create?: XOR<QuizCreateWithoutChapterInput, QuizUncheckedCreateWithoutChapterInput> | QuizCreateWithoutChapterInput[] | QuizUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutChapterInput | QuizCreateOrConnectWithoutChapterInput[]
    createMany?: QuizCreateManyChapterInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type BlockProgressCreateNestedManyWithoutChapterInput = {
    create?: XOR<BlockProgressCreateWithoutChapterInput, BlockProgressUncheckedCreateWithoutChapterInput> | BlockProgressCreateWithoutChapterInput[] | BlockProgressUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: BlockProgressCreateOrConnectWithoutChapterInput | BlockProgressCreateOrConnectWithoutChapterInput[]
    createMany?: BlockProgressCreateManyChapterInputEnvelope
    connect?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<QuizCreateWithoutChapterInput, QuizUncheckedCreateWithoutChapterInput> | QuizCreateWithoutChapterInput[] | QuizUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutChapterInput | QuizCreateOrConnectWithoutChapterInput[]
    createMany?: QuizCreateManyChapterInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type BlockProgressUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<BlockProgressCreateWithoutChapterInput, BlockProgressUncheckedCreateWithoutChapterInput> | BlockProgressCreateWithoutChapterInput[] | BlockProgressUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: BlockProgressCreateOrConnectWithoutChapterInput | BlockProgressCreateOrConnectWithoutChapterInput[]
    createMany?: BlockProgressCreateManyChapterInputEnvelope
    connect?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<CourseCreateWithoutChaptersInput, CourseUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: CourseCreateOrConnectWithoutChaptersInput
    upsert?: CourseUpsertWithoutChaptersInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutChaptersInput, CourseUpdateWithoutChaptersInput>, CourseUncheckedUpdateWithoutChaptersInput>
  }

  export type QuizUpdateManyWithoutChapterNestedInput = {
    create?: XOR<QuizCreateWithoutChapterInput, QuizUncheckedCreateWithoutChapterInput> | QuizCreateWithoutChapterInput[] | QuizUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutChapterInput | QuizCreateOrConnectWithoutChapterInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutChapterInput | QuizUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: QuizCreateManyChapterInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutChapterInput | QuizUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutChapterInput | QuizUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type BlockProgressUpdateManyWithoutChapterNestedInput = {
    create?: XOR<BlockProgressCreateWithoutChapterInput, BlockProgressUncheckedCreateWithoutChapterInput> | BlockProgressCreateWithoutChapterInput[] | BlockProgressUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: BlockProgressCreateOrConnectWithoutChapterInput | BlockProgressCreateOrConnectWithoutChapterInput[]
    upsert?: BlockProgressUpsertWithWhereUniqueWithoutChapterInput | BlockProgressUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: BlockProgressCreateManyChapterInputEnvelope
    set?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    disconnect?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    delete?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    connect?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    update?: BlockProgressUpdateWithWhereUniqueWithoutChapterInput | BlockProgressUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: BlockProgressUpdateManyWithWhereWithoutChapterInput | BlockProgressUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: BlockProgressScalarWhereInput | BlockProgressScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<QuizCreateWithoutChapterInput, QuizUncheckedCreateWithoutChapterInput> | QuizCreateWithoutChapterInput[] | QuizUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutChapterInput | QuizCreateOrConnectWithoutChapterInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutChapterInput | QuizUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: QuizCreateManyChapterInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutChapterInput | QuizUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutChapterInput | QuizUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type BlockProgressUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<BlockProgressCreateWithoutChapterInput, BlockProgressUncheckedCreateWithoutChapterInput> | BlockProgressCreateWithoutChapterInput[] | BlockProgressUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: BlockProgressCreateOrConnectWithoutChapterInput | BlockProgressCreateOrConnectWithoutChapterInput[]
    upsert?: BlockProgressUpsertWithWhereUniqueWithoutChapterInput | BlockProgressUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: BlockProgressCreateManyChapterInputEnvelope
    set?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    disconnect?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    delete?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    connect?: BlockProgressWhereUniqueInput | BlockProgressWhereUniqueInput[]
    update?: BlockProgressUpdateWithWhereUniqueWithoutChapterInput | BlockProgressUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: BlockProgressUpdateManyWithWhereWithoutChapterInput | BlockProgressUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: BlockProgressScalarWhereInput | BlockProgressScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<CourseCreateWithoutQuizzesInput, CourseUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutQuizzesInput
    connect?: CourseWhereUniqueInput
  }

  export type ChapterCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<ChapterCreateWithoutQuizzesInput, ChapterUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutQuizzesInput
    connect?: ChapterWhereUniqueInput
  }

  export type QuizAttemptCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type ClassroomResourceCreateNestedManyWithoutQuizInput = {
    create?: XOR<ClassroomResourceCreateWithoutQuizInput, ClassroomResourceUncheckedCreateWithoutQuizInput> | ClassroomResourceCreateWithoutQuizInput[] | ClassroomResourceUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutQuizInput | ClassroomResourceCreateOrConnectWithoutQuizInput[]
    createMany?: ClassroomResourceCreateManyQuizInputEnvelope
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type ClassroomResourceUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<ClassroomResourceCreateWithoutQuizInput, ClassroomResourceUncheckedCreateWithoutQuizInput> | ClassroomResourceCreateWithoutQuizInput[] | ClassroomResourceUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutQuizInput | ClassroomResourceCreateOrConnectWithoutQuizInput[]
    createMany?: ClassroomResourceCreateManyQuizInputEnvelope
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseUpdateOneWithoutQuizzesNestedInput = {
    create?: XOR<CourseCreateWithoutQuizzesInput, CourseUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutQuizzesInput
    upsert?: CourseUpsertWithoutQuizzesInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutQuizzesInput, CourseUpdateWithoutQuizzesInput>, CourseUncheckedUpdateWithoutQuizzesInput>
  }

  export type ChapterUpdateOneWithoutQuizzesNestedInput = {
    create?: XOR<ChapterCreateWithoutQuizzesInput, ChapterUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutQuizzesInput
    upsert?: ChapterUpsertWithoutQuizzesInput
    disconnect?: ChapterWhereInput | boolean
    delete?: ChapterWhereInput | boolean
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutQuizzesInput, ChapterUpdateWithoutQuizzesInput>, ChapterUncheckedUpdateWithoutQuizzesInput>
  }

  export type QuizAttemptUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutQuizInput | QuizAttemptUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutQuizInput | QuizAttemptUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutQuizInput | QuizAttemptUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type ClassroomResourceUpdateManyWithoutQuizNestedInput = {
    create?: XOR<ClassroomResourceCreateWithoutQuizInput, ClassroomResourceUncheckedCreateWithoutQuizInput> | ClassroomResourceCreateWithoutQuizInput[] | ClassroomResourceUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutQuizInput | ClassroomResourceCreateOrConnectWithoutQuizInput[]
    upsert?: ClassroomResourceUpsertWithWhereUniqueWithoutQuizInput | ClassroomResourceUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: ClassroomResourceCreateManyQuizInputEnvelope
    set?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    disconnect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    delete?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    update?: ClassroomResourceUpdateWithWhereUniqueWithoutQuizInput | ClassroomResourceUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: ClassroomResourceUpdateManyWithWhereWithoutQuizInput | ClassroomResourceUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: ClassroomResourceScalarWhereInput | ClassroomResourceScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutQuizInput | QuizAttemptUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutQuizInput | QuizAttemptUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutQuizInput | QuizAttemptUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type ClassroomResourceUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<ClassroomResourceCreateWithoutQuizInput, ClassroomResourceUncheckedCreateWithoutQuizInput> | ClassroomResourceCreateWithoutQuizInput[] | ClassroomResourceUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutQuizInput | ClassroomResourceCreateOrConnectWithoutQuizInput[]
    upsert?: ClassroomResourceUpsertWithWhereUniqueWithoutQuizInput | ClassroomResourceUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: ClassroomResourceCreateManyQuizInputEnvelope
    set?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    disconnect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    delete?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    update?: ClassroomResourceUpdateWithWhereUniqueWithoutQuizInput | ClassroomResourceUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: ClassroomResourceUpdateManyWithWhereWithoutQuizInput | ClassroomResourceUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: ClassroomResourceScalarWhereInput | ClassroomResourceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<UserCreateWithoutAttemptsInput, UserUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type QuizCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutAttemptsInput
    connect?: QuizWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutAttemptsInput, UserUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttemptsInput
    upsert?: UserUpsertWithoutAttemptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttemptsInput, UserUpdateWithoutAttemptsInput>, UserUncheckedUpdateWithoutAttemptsInput>
  }

  export type QuizUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutAttemptsInput
    upsert?: QuizUpsertWithoutAttemptsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutAttemptsInput, QuizUpdateWithoutAttemptsInput>, QuizUncheckedUpdateWithoutAttemptsInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserCreateNestedOneWithoutBlockProgressInput = {
    create?: XOR<UserCreateWithoutBlockProgressInput, UserUncheckedCreateWithoutBlockProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockProgressInput
    connect?: UserWhereUniqueInput
  }

  export type ChapterCreateNestedOneWithoutBlockProgressInput = {
    create?: XOR<ChapterCreateWithoutBlockProgressInput, ChapterUncheckedCreateWithoutBlockProgressInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutBlockProgressInput
    connect?: ChapterWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutBlockProgressNestedInput = {
    create?: XOR<UserCreateWithoutBlockProgressInput, UserUncheckedCreateWithoutBlockProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockProgressInput
    upsert?: UserUpsertWithoutBlockProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockProgressInput, UserUpdateWithoutBlockProgressInput>, UserUncheckedUpdateWithoutBlockProgressInput>
  }

  export type ChapterUpdateOneRequiredWithoutBlockProgressNestedInput = {
    create?: XOR<ChapterCreateWithoutBlockProgressInput, ChapterUncheckedCreateWithoutBlockProgressInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutBlockProgressInput
    upsert?: ChapterUpsertWithoutBlockProgressInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutBlockProgressInput, ChapterUpdateWithoutBlockProgressInput>, ChapterUncheckedUpdateWithoutBlockProgressInput>
  }

  export type UserCreateNestedOneWithoutClassroomsCreatedInput = {
    create?: XOR<UserCreateWithoutClassroomsCreatedInput, UserUncheckedCreateWithoutClassroomsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassroomsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type ClassroomMembershipCreateNestedManyWithoutClassroomInput = {
    create?: XOR<ClassroomMembershipCreateWithoutClassroomInput, ClassroomMembershipUncheckedCreateWithoutClassroomInput> | ClassroomMembershipCreateWithoutClassroomInput[] | ClassroomMembershipUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomMembershipCreateOrConnectWithoutClassroomInput | ClassroomMembershipCreateOrConnectWithoutClassroomInput[]
    createMany?: ClassroomMembershipCreateManyClassroomInputEnvelope
    connect?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
  }

  export type ClassroomPostCreateNestedManyWithoutClassroomInput = {
    create?: XOR<ClassroomPostCreateWithoutClassroomInput, ClassroomPostUncheckedCreateWithoutClassroomInput> | ClassroomPostCreateWithoutClassroomInput[] | ClassroomPostUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomPostCreateOrConnectWithoutClassroomInput | ClassroomPostCreateOrConnectWithoutClassroomInput[]
    createMany?: ClassroomPostCreateManyClassroomInputEnvelope
    connect?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
  }

  export type ClassroomResourceCreateNestedManyWithoutClassroomInput = {
    create?: XOR<ClassroomResourceCreateWithoutClassroomInput, ClassroomResourceUncheckedCreateWithoutClassroomInput> | ClassroomResourceCreateWithoutClassroomInput[] | ClassroomResourceUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutClassroomInput | ClassroomResourceCreateOrConnectWithoutClassroomInput[]
    createMany?: ClassroomResourceCreateManyClassroomInputEnvelope
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
  }

  export type ClassroomMembershipUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<ClassroomMembershipCreateWithoutClassroomInput, ClassroomMembershipUncheckedCreateWithoutClassroomInput> | ClassroomMembershipCreateWithoutClassroomInput[] | ClassroomMembershipUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomMembershipCreateOrConnectWithoutClassroomInput | ClassroomMembershipCreateOrConnectWithoutClassroomInput[]
    createMany?: ClassroomMembershipCreateManyClassroomInputEnvelope
    connect?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
  }

  export type ClassroomPostUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<ClassroomPostCreateWithoutClassroomInput, ClassroomPostUncheckedCreateWithoutClassroomInput> | ClassroomPostCreateWithoutClassroomInput[] | ClassroomPostUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomPostCreateOrConnectWithoutClassroomInput | ClassroomPostCreateOrConnectWithoutClassroomInput[]
    createMany?: ClassroomPostCreateManyClassroomInputEnvelope
    connect?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
  }

  export type ClassroomResourceUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<ClassroomResourceCreateWithoutClassroomInput, ClassroomResourceUncheckedCreateWithoutClassroomInput> | ClassroomResourceCreateWithoutClassroomInput[] | ClassroomResourceUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutClassroomInput | ClassroomResourceCreateOrConnectWithoutClassroomInput[]
    createMany?: ClassroomResourceCreateManyClassroomInputEnvelope
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutClassroomsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutClassroomsCreatedInput, UserUncheckedCreateWithoutClassroomsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassroomsCreatedInput
    upsert?: UserUpsertWithoutClassroomsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassroomsCreatedInput, UserUpdateWithoutClassroomsCreatedInput>, UserUncheckedUpdateWithoutClassroomsCreatedInput>
  }

  export type ClassroomMembershipUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<ClassroomMembershipCreateWithoutClassroomInput, ClassroomMembershipUncheckedCreateWithoutClassroomInput> | ClassroomMembershipCreateWithoutClassroomInput[] | ClassroomMembershipUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomMembershipCreateOrConnectWithoutClassroomInput | ClassroomMembershipCreateOrConnectWithoutClassroomInput[]
    upsert?: ClassroomMembershipUpsertWithWhereUniqueWithoutClassroomInput | ClassroomMembershipUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: ClassroomMembershipCreateManyClassroomInputEnvelope
    set?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    disconnect?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    delete?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    connect?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    update?: ClassroomMembershipUpdateWithWhereUniqueWithoutClassroomInput | ClassroomMembershipUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: ClassroomMembershipUpdateManyWithWhereWithoutClassroomInput | ClassroomMembershipUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: ClassroomMembershipScalarWhereInput | ClassroomMembershipScalarWhereInput[]
  }

  export type ClassroomPostUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<ClassroomPostCreateWithoutClassroomInput, ClassroomPostUncheckedCreateWithoutClassroomInput> | ClassroomPostCreateWithoutClassroomInput[] | ClassroomPostUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomPostCreateOrConnectWithoutClassroomInput | ClassroomPostCreateOrConnectWithoutClassroomInput[]
    upsert?: ClassroomPostUpsertWithWhereUniqueWithoutClassroomInput | ClassroomPostUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: ClassroomPostCreateManyClassroomInputEnvelope
    set?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    disconnect?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    delete?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    connect?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    update?: ClassroomPostUpdateWithWhereUniqueWithoutClassroomInput | ClassroomPostUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: ClassroomPostUpdateManyWithWhereWithoutClassroomInput | ClassroomPostUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: ClassroomPostScalarWhereInput | ClassroomPostScalarWhereInput[]
  }

  export type ClassroomResourceUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<ClassroomResourceCreateWithoutClassroomInput, ClassroomResourceUncheckedCreateWithoutClassroomInput> | ClassroomResourceCreateWithoutClassroomInput[] | ClassroomResourceUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutClassroomInput | ClassroomResourceCreateOrConnectWithoutClassroomInput[]
    upsert?: ClassroomResourceUpsertWithWhereUniqueWithoutClassroomInput | ClassroomResourceUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: ClassroomResourceCreateManyClassroomInputEnvelope
    set?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    disconnect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    delete?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    update?: ClassroomResourceUpdateWithWhereUniqueWithoutClassroomInput | ClassroomResourceUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: ClassroomResourceUpdateManyWithWhereWithoutClassroomInput | ClassroomResourceUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: ClassroomResourceScalarWhereInput | ClassroomResourceScalarWhereInput[]
  }

  export type ClassroomMembershipUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<ClassroomMembershipCreateWithoutClassroomInput, ClassroomMembershipUncheckedCreateWithoutClassroomInput> | ClassroomMembershipCreateWithoutClassroomInput[] | ClassroomMembershipUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomMembershipCreateOrConnectWithoutClassroomInput | ClassroomMembershipCreateOrConnectWithoutClassroomInput[]
    upsert?: ClassroomMembershipUpsertWithWhereUniqueWithoutClassroomInput | ClassroomMembershipUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: ClassroomMembershipCreateManyClassroomInputEnvelope
    set?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    disconnect?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    delete?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    connect?: ClassroomMembershipWhereUniqueInput | ClassroomMembershipWhereUniqueInput[]
    update?: ClassroomMembershipUpdateWithWhereUniqueWithoutClassroomInput | ClassroomMembershipUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: ClassroomMembershipUpdateManyWithWhereWithoutClassroomInput | ClassroomMembershipUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: ClassroomMembershipScalarWhereInput | ClassroomMembershipScalarWhereInput[]
  }

  export type ClassroomPostUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<ClassroomPostCreateWithoutClassroomInput, ClassroomPostUncheckedCreateWithoutClassroomInput> | ClassroomPostCreateWithoutClassroomInput[] | ClassroomPostUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomPostCreateOrConnectWithoutClassroomInput | ClassroomPostCreateOrConnectWithoutClassroomInput[]
    upsert?: ClassroomPostUpsertWithWhereUniqueWithoutClassroomInput | ClassroomPostUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: ClassroomPostCreateManyClassroomInputEnvelope
    set?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    disconnect?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    delete?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    connect?: ClassroomPostWhereUniqueInput | ClassroomPostWhereUniqueInput[]
    update?: ClassroomPostUpdateWithWhereUniqueWithoutClassroomInput | ClassroomPostUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: ClassroomPostUpdateManyWithWhereWithoutClassroomInput | ClassroomPostUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: ClassroomPostScalarWhereInput | ClassroomPostScalarWhereInput[]
  }

  export type ClassroomResourceUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<ClassroomResourceCreateWithoutClassroomInput, ClassroomResourceUncheckedCreateWithoutClassroomInput> | ClassroomResourceCreateWithoutClassroomInput[] | ClassroomResourceUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomResourceCreateOrConnectWithoutClassroomInput | ClassroomResourceCreateOrConnectWithoutClassroomInput[]
    upsert?: ClassroomResourceUpsertWithWhereUniqueWithoutClassroomInput | ClassroomResourceUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: ClassroomResourceCreateManyClassroomInputEnvelope
    set?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    disconnect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    delete?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    connect?: ClassroomResourceWhereUniqueInput | ClassroomResourceWhereUniqueInput[]
    update?: ClassroomResourceUpdateWithWhereUniqueWithoutClassroomInput | ClassroomResourceUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: ClassroomResourceUpdateManyWithWhereWithoutClassroomInput | ClassroomResourceUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: ClassroomResourceScalarWhereInput | ClassroomResourceScalarWhereInput[]
  }

  export type ClassroomCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<ClassroomCreateWithoutMembershipsInput, ClassroomUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutMembershipsInput
    connect?: ClassroomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClassroomMembershipsInput = {
    create?: XOR<UserCreateWithoutClassroomMembershipsInput, UserUncheckedCreateWithoutClassroomMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassroomMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type ClassroomUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<ClassroomCreateWithoutMembershipsInput, ClassroomUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutMembershipsInput
    upsert?: ClassroomUpsertWithoutMembershipsInput
    connect?: ClassroomWhereUniqueInput
    update?: XOR<XOR<ClassroomUpdateToOneWithWhereWithoutMembershipsInput, ClassroomUpdateWithoutMembershipsInput>, ClassroomUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateOneRequiredWithoutClassroomMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutClassroomMembershipsInput, UserUncheckedCreateWithoutClassroomMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassroomMembershipsInput
    upsert?: UserUpsertWithoutClassroomMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassroomMembershipsInput, UserUpdateWithoutClassroomMembershipsInput>, UserUncheckedUpdateWithoutClassroomMembershipsInput>
  }

  export type ClassroomCreateNestedOneWithoutPostsInput = {
    create?: XOR<ClassroomCreateWithoutPostsInput, ClassroomUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutPostsInput
    connect?: ClassroomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClassroomPostsInput = {
    create?: XOR<UserCreateWithoutClassroomPostsInput, UserUncheckedCreateWithoutClassroomPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassroomPostsInput
    connect?: UserWhereUniqueInput
  }

  export type ClassroomCommentCreateNestedManyWithoutPostInput = {
    create?: XOR<ClassroomCommentCreateWithoutPostInput, ClassroomCommentUncheckedCreateWithoutPostInput> | ClassroomCommentCreateWithoutPostInput[] | ClassroomCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ClassroomCommentCreateOrConnectWithoutPostInput | ClassroomCommentCreateOrConnectWithoutPostInput[]
    createMany?: ClassroomCommentCreateManyPostInputEnvelope
    connect?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
  }

  export type ClassroomCommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ClassroomCommentCreateWithoutPostInput, ClassroomCommentUncheckedCreateWithoutPostInput> | ClassroomCommentCreateWithoutPostInput[] | ClassroomCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ClassroomCommentCreateOrConnectWithoutPostInput | ClassroomCommentCreateOrConnectWithoutPostInput[]
    createMany?: ClassroomCommentCreateManyPostInputEnvelope
    connect?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
  }

  export type ClassroomUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<ClassroomCreateWithoutPostsInput, ClassroomUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutPostsInput
    upsert?: ClassroomUpsertWithoutPostsInput
    connect?: ClassroomWhereUniqueInput
    update?: XOR<XOR<ClassroomUpdateToOneWithWhereWithoutPostsInput, ClassroomUpdateWithoutPostsInput>, ClassroomUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateOneRequiredWithoutClassroomPostsNestedInput = {
    create?: XOR<UserCreateWithoutClassroomPostsInput, UserUncheckedCreateWithoutClassroomPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassroomPostsInput
    upsert?: UserUpsertWithoutClassroomPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassroomPostsInput, UserUpdateWithoutClassroomPostsInput>, UserUncheckedUpdateWithoutClassroomPostsInput>
  }

  export type ClassroomCommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<ClassroomCommentCreateWithoutPostInput, ClassroomCommentUncheckedCreateWithoutPostInput> | ClassroomCommentCreateWithoutPostInput[] | ClassroomCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ClassroomCommentCreateOrConnectWithoutPostInput | ClassroomCommentCreateOrConnectWithoutPostInput[]
    upsert?: ClassroomCommentUpsertWithWhereUniqueWithoutPostInput | ClassroomCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ClassroomCommentCreateManyPostInputEnvelope
    set?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    disconnect?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    delete?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    connect?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    update?: ClassroomCommentUpdateWithWhereUniqueWithoutPostInput | ClassroomCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ClassroomCommentUpdateManyWithWhereWithoutPostInput | ClassroomCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ClassroomCommentScalarWhereInput | ClassroomCommentScalarWhereInput[]
  }

  export type ClassroomCommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ClassroomCommentCreateWithoutPostInput, ClassroomCommentUncheckedCreateWithoutPostInput> | ClassroomCommentCreateWithoutPostInput[] | ClassroomCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ClassroomCommentCreateOrConnectWithoutPostInput | ClassroomCommentCreateOrConnectWithoutPostInput[]
    upsert?: ClassroomCommentUpsertWithWhereUniqueWithoutPostInput | ClassroomCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ClassroomCommentCreateManyPostInputEnvelope
    set?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    disconnect?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    delete?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    connect?: ClassroomCommentWhereUniqueInput | ClassroomCommentWhereUniqueInput[]
    update?: ClassroomCommentUpdateWithWhereUniqueWithoutPostInput | ClassroomCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ClassroomCommentUpdateManyWithWhereWithoutPostInput | ClassroomCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ClassroomCommentScalarWhereInput | ClassroomCommentScalarWhereInput[]
  }

  export type ClassroomPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ClassroomPostCreateWithoutCommentsInput, ClassroomPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ClassroomPostCreateOrConnectWithoutCommentsInput
    connect?: ClassroomPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClassroomCommentsInput = {
    create?: XOR<UserCreateWithoutClassroomCommentsInput, UserUncheckedCreateWithoutClassroomCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassroomCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ClassroomPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ClassroomPostCreateWithoutCommentsInput, ClassroomPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ClassroomPostCreateOrConnectWithoutCommentsInput
    upsert?: ClassroomPostUpsertWithoutCommentsInput
    connect?: ClassroomPostWhereUniqueInput
    update?: XOR<XOR<ClassroomPostUpdateToOneWithWhereWithoutCommentsInput, ClassroomPostUpdateWithoutCommentsInput>, ClassroomPostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutClassroomCommentsNestedInput = {
    create?: XOR<UserCreateWithoutClassroomCommentsInput, UserUncheckedCreateWithoutClassroomCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassroomCommentsInput
    upsert?: UserUpsertWithoutClassroomCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassroomCommentsInput, UserUpdateWithoutClassroomCommentsInput>, UserUncheckedUpdateWithoutClassroomCommentsInput>
  }

  export type ClassroomCreateNestedOneWithoutResourcesInput = {
    create?: XOR<ClassroomCreateWithoutResourcesInput, ClassroomUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutResourcesInput
    connect?: ClassroomWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutClassroomResourcesInput = {
    create?: XOR<CourseCreateWithoutClassroomResourcesInput, CourseUncheckedCreateWithoutClassroomResourcesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutClassroomResourcesInput
    connect?: CourseWhereUniqueInput
  }

  export type QuizCreateNestedOneWithoutClassroomResourcesInput = {
    create?: XOR<QuizCreateWithoutClassroomResourcesInput, QuizUncheckedCreateWithoutClassroomResourcesInput>
    connectOrCreate?: QuizCreateOrConnectWithoutClassroomResourcesInput
    connect?: QuizWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClassroomResourcesAddedInput = {
    create?: XOR<UserCreateWithoutClassroomResourcesAddedInput, UserUncheckedCreateWithoutClassroomResourcesAddedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassroomResourcesAddedInput
    connect?: UserWhereUniqueInput
  }

  export type ClassroomUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<ClassroomCreateWithoutResourcesInput, ClassroomUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutResourcesInput
    upsert?: ClassroomUpsertWithoutResourcesInput
    connect?: ClassroomWhereUniqueInput
    update?: XOR<XOR<ClassroomUpdateToOneWithWhereWithoutResourcesInput, ClassroomUpdateWithoutResourcesInput>, ClassroomUncheckedUpdateWithoutResourcesInput>
  }

  export type CourseUpdateOneWithoutClassroomResourcesNestedInput = {
    create?: XOR<CourseCreateWithoutClassroomResourcesInput, CourseUncheckedCreateWithoutClassroomResourcesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutClassroomResourcesInput
    upsert?: CourseUpsertWithoutClassroomResourcesInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutClassroomResourcesInput, CourseUpdateWithoutClassroomResourcesInput>, CourseUncheckedUpdateWithoutClassroomResourcesInput>
  }

  export type QuizUpdateOneWithoutClassroomResourcesNestedInput = {
    create?: XOR<QuizCreateWithoutClassroomResourcesInput, QuizUncheckedCreateWithoutClassroomResourcesInput>
    connectOrCreate?: QuizCreateOrConnectWithoutClassroomResourcesInput
    upsert?: QuizUpsertWithoutClassroomResourcesInput
    disconnect?: QuizWhereInput | boolean
    delete?: QuizWhereInput | boolean
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutClassroomResourcesInput, QuizUpdateWithoutClassroomResourcesInput>, QuizUncheckedUpdateWithoutClassroomResourcesInput>
  }

  export type UserUpdateOneRequiredWithoutClassroomResourcesAddedNestedInput = {
    create?: XOR<UserCreateWithoutClassroomResourcesAddedInput, UserUncheckedCreateWithoutClassroomResourcesAddedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassroomResourcesAddedInput
    upsert?: UserUpsertWithoutClassroomResourcesAddedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassroomResourcesAddedInput, UserUpdateWithoutClassroomResourcesAddedInput>, UserUncheckedUpdateWithoutClassroomResourcesAddedInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CourseCreateWithoutCreatorInput = {
    title: string
    description?: string | null
    slug: string
    visibility?: string
    createdAt?: Date | string
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    quizzes?: QuizCreateNestedManyWithoutCourseInput
    classroomResources?: ClassroomResourceCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCreatorInput = {
    id?: number
    title: string
    description?: string | null
    slug: string
    visibility?: string
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutCourseInput
    classroomResources?: ClassroomResourceUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput>
  }

  export type CourseCreateManyCreatorInputEnvelope = {
    data: CourseCreateManyCreatorInput | CourseCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptCreateWithoutUserInput = {
    answers: string
    score: number
    totalQuestions: number
    correctAnswers: number
    percentage: number
    timeSpent: number
    detailedResults: string
    completedAt?: Date | string
    scoreReleasedAt?: Date | string | null
    endReason?: string
    quiz: QuizCreateNestedOneWithoutAttemptsInput
  }

  export type QuizAttemptUncheckedCreateWithoutUserInput = {
    id?: number
    quizId: number
    answers: string
    score: number
    totalQuestions: number
    correctAnswers: number
    percentage: number
    timeSpent: number
    detailedResults: string
    completedAt?: Date | string
    scoreReleasedAt?: Date | string | null
    endReason?: string
  }

  export type QuizAttemptCreateOrConnectWithoutUserInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput>
  }

  export type QuizAttemptCreateManyUserInputEnvelope = {
    data: QuizAttemptCreateManyUserInput | QuizAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUserInput = {
    fullName?: string | null
    firstName?: string | null
    lastName?: string | null
    nickname?: string | null
    headline?: string | null
    jobTitle?: string | null
    company?: string | null
    grade?: string | null
    school?: string | null
    bio?: string | null
    avatar?: string | null
    website?: string | null
    location?: string | null
    phone?: string | null
    linkedin?: string | null
    github?: string | null
    twitter?: string | null
    preferences?: string | null
    learningGoals?: string | null
    timezone?: string | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: number
    fullName?: string | null
    firstName?: string | null
    lastName?: string | null
    nickname?: string | null
    headline?: string | null
    jobTitle?: string | null
    company?: string | null
    grade?: string | null
    school?: string | null
    bio?: string | null
    avatar?: string | null
    website?: string | null
    location?: string | null
    phone?: string | null
    linkedin?: string | null
    github?: string | null
    twitter?: string | null
    preferences?: string | null
    learningGoals?: string | null
    timezone?: string | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type BlockProgressCreateWithoutUserInput = {
    blockId: string
    blockType: string
    completed?: boolean
    score?: number | null
    attempts?: number
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutBlockProgressInput
  }

  export type BlockProgressUncheckedCreateWithoutUserInput = {
    id?: number
    chapterId: number
    blockId: string
    blockType: string
    completed?: boolean
    score?: number | null
    attempts?: number
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockProgressCreateOrConnectWithoutUserInput = {
    where: BlockProgressWhereUniqueInput
    create: XOR<BlockProgressCreateWithoutUserInput, BlockProgressUncheckedCreateWithoutUserInput>
  }

  export type BlockProgressCreateManyUserInputEnvelope = {
    data: BlockProgressCreateManyUserInput | BlockProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: number
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomCreateWithoutCreatorInput = {
    title: string
    description?: string | null
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: ClassroomMembershipCreateNestedManyWithoutClassroomInput
    posts?: ClassroomPostCreateNestedManyWithoutClassroomInput
    resources?: ClassroomResourceCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutCreatorInput = {
    id?: number
    title: string
    description?: string | null
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutClassroomInput
    posts?: ClassroomPostUncheckedCreateNestedManyWithoutClassroomInput
    resources?: ClassroomResourceUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutCreatorInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutCreatorInput, ClassroomUncheckedCreateWithoutCreatorInput>
  }

  export type ClassroomCreateManyCreatorInputEnvelope = {
    data: ClassroomCreateManyCreatorInput | ClassroomCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomMembershipCreateWithoutUserInput = {
    role?: string
    status?: string
    createdAt?: Date | string
    classroom: ClassroomCreateNestedOneWithoutMembershipsInput
  }

  export type ClassroomMembershipUncheckedCreateWithoutUserInput = {
    id?: number
    classroomId: number
    role?: string
    status?: string
    createdAt?: Date | string
  }

  export type ClassroomMembershipCreateOrConnectWithoutUserInput = {
    where: ClassroomMembershipWhereUniqueInput
    create: XOR<ClassroomMembershipCreateWithoutUserInput, ClassroomMembershipUncheckedCreateWithoutUserInput>
  }

  export type ClassroomMembershipCreateManyUserInputEnvelope = {
    data: ClassroomMembershipCreateManyUserInput | ClassroomMembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomPostCreateWithoutAuthorInput = {
    content: string
    pinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    classroom: ClassroomCreateNestedOneWithoutPostsInput
    comments?: ClassroomCommentCreateNestedManyWithoutPostInput
  }

  export type ClassroomPostUncheckedCreateWithoutAuthorInput = {
    id?: number
    classroomId: number
    content: string
    pinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ClassroomCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type ClassroomPostCreateOrConnectWithoutAuthorInput = {
    where: ClassroomPostWhereUniqueInput
    create: XOR<ClassroomPostCreateWithoutAuthorInput, ClassroomPostUncheckedCreateWithoutAuthorInput>
  }

  export type ClassroomPostCreateManyAuthorInputEnvelope = {
    data: ClassroomPostCreateManyAuthorInput | ClassroomPostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomCommentCreateWithoutAuthorInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: ClassroomPostCreateNestedOneWithoutCommentsInput
  }

  export type ClassroomCommentUncheckedCreateWithoutAuthorInput = {
    id?: number
    postId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomCommentCreateOrConnectWithoutAuthorInput = {
    where: ClassroomCommentWhereUniqueInput
    create: XOR<ClassroomCommentCreateWithoutAuthorInput, ClassroomCommentUncheckedCreateWithoutAuthorInput>
  }

  export type ClassroomCommentCreateManyAuthorInputEnvelope = {
    data: ClassroomCommentCreateManyAuthorInput | ClassroomCommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomResourceCreateWithoutAddedByUserInput = {
    pinnedAt?: Date | string | null
    classroom: ClassroomCreateNestedOneWithoutResourcesInput
    course?: CourseCreateNestedOneWithoutClassroomResourcesInput
    quiz?: QuizCreateNestedOneWithoutClassroomResourcesInput
  }

  export type ClassroomResourceUncheckedCreateWithoutAddedByUserInput = {
    id?: number
    classroomId: number
    courseId?: number | null
    quizId?: number | null
    pinnedAt?: Date | string | null
  }

  export type ClassroomResourceCreateOrConnectWithoutAddedByUserInput = {
    where: ClassroomResourceWhereUniqueInput
    create: XOR<ClassroomResourceCreateWithoutAddedByUserInput, ClassroomResourceUncheckedCreateWithoutAddedByUserInput>
  }

  export type ClassroomResourceCreateManyAddedByUserInputEnvelope = {
    data: ClassroomResourceCreateManyAddedByUserInput | ClassroomResourceCreateManyAddedByUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCreatorInput, CourseUncheckedUpdateWithoutCreatorInput>
    create: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCreatorInput, CourseUncheckedUpdateWithoutCreatorInput>
  }

  export type CourseUpdateManyWithWhereWithoutCreatorInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: IntFilter<"Course"> | number
    title?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    slug?: StringFilter<"Course"> | string
    visibility?: StringFilter<"Course"> | string
    createdBy?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutUserInput, QuizAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutUserInput, QuizAttemptUncheckedUpdateWithoutUserInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutUserInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type QuizAttemptScalarWhereInput = {
    AND?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    OR?: QuizAttemptScalarWhereInput[]
    NOT?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    id?: IntFilter<"QuizAttempt"> | number
    userId?: IntFilter<"QuizAttempt"> | number
    quizId?: IntFilter<"QuizAttempt"> | number
    answers?: StringFilter<"QuizAttempt"> | string
    score?: IntFilter<"QuizAttempt"> | number
    totalQuestions?: IntFilter<"QuizAttempt"> | number
    correctAnswers?: IntFilter<"QuizAttempt"> | number
    percentage?: IntFilter<"QuizAttempt"> | number
    timeSpent?: IntFilter<"QuizAttempt"> | number
    detailedResults?: StringFilter<"QuizAttempt"> | string
    completedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    scoreReleasedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    endReason?: StringFilter<"QuizAttempt"> | string
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    learningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    learningGoals?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: BlockProgressWhereUniqueInput
    update: XOR<BlockProgressUpdateWithoutUserInput, BlockProgressUncheckedUpdateWithoutUserInput>
    create: XOR<BlockProgressCreateWithoutUserInput, BlockProgressUncheckedCreateWithoutUserInput>
  }

  export type BlockProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: BlockProgressWhereUniqueInput
    data: XOR<BlockProgressUpdateWithoutUserInput, BlockProgressUncheckedUpdateWithoutUserInput>
  }

  export type BlockProgressUpdateManyWithWhereWithoutUserInput = {
    where: BlockProgressScalarWhereInput
    data: XOR<BlockProgressUpdateManyMutationInput, BlockProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type BlockProgressScalarWhereInput = {
    AND?: BlockProgressScalarWhereInput | BlockProgressScalarWhereInput[]
    OR?: BlockProgressScalarWhereInput[]
    NOT?: BlockProgressScalarWhereInput | BlockProgressScalarWhereInput[]
    id?: IntFilter<"BlockProgress"> | number
    userId?: IntFilter<"BlockProgress"> | number
    chapterId?: IntFilter<"BlockProgress"> | number
    blockId?: StringFilter<"BlockProgress"> | string
    blockType?: StringFilter<"BlockProgress"> | string
    completed?: BoolFilter<"BlockProgress"> | boolean
    score?: FloatNullableFilter<"BlockProgress"> | number | null
    attempts?: IntFilter<"BlockProgress"> | number
    data?: StringNullableFilter<"BlockProgress"> | string | null
    createdAt?: DateTimeFilter<"BlockProgress"> | Date | string
    updatedAt?: DateTimeFilter<"BlockProgress"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: IntFilter<"Account"> | number
    userId?: IntFilter<"Account"> | number
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: IntFilter<"Session"> | number
    sessionToken?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: IntFilter<"PasswordResetToken"> | number
    userId?: IntFilter<"PasswordResetToken"> | number
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
  }

  export type ClassroomUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ClassroomWhereUniqueInput
    update: XOR<ClassroomUpdateWithoutCreatorInput, ClassroomUncheckedUpdateWithoutCreatorInput>
    create: XOR<ClassroomCreateWithoutCreatorInput, ClassroomUncheckedCreateWithoutCreatorInput>
  }

  export type ClassroomUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ClassroomWhereUniqueInput
    data: XOR<ClassroomUpdateWithoutCreatorInput, ClassroomUncheckedUpdateWithoutCreatorInput>
  }

  export type ClassroomUpdateManyWithWhereWithoutCreatorInput = {
    where: ClassroomScalarWhereInput
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ClassroomScalarWhereInput = {
    AND?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
    OR?: ClassroomScalarWhereInput[]
    NOT?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
    id?: IntFilter<"Classroom"> | number
    title?: StringFilter<"Classroom"> | string
    description?: StringNullableFilter<"Classroom"> | string | null
    isPrivate?: BoolFilter<"Classroom"> | boolean
    createdBy?: IntFilter<"Classroom"> | number
    createdAt?: DateTimeFilter<"Classroom"> | Date | string
    updatedAt?: DateTimeFilter<"Classroom"> | Date | string
  }

  export type ClassroomMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: ClassroomMembershipWhereUniqueInput
    update: XOR<ClassroomMembershipUpdateWithoutUserInput, ClassroomMembershipUncheckedUpdateWithoutUserInput>
    create: XOR<ClassroomMembershipCreateWithoutUserInput, ClassroomMembershipUncheckedCreateWithoutUserInput>
  }

  export type ClassroomMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: ClassroomMembershipWhereUniqueInput
    data: XOR<ClassroomMembershipUpdateWithoutUserInput, ClassroomMembershipUncheckedUpdateWithoutUserInput>
  }

  export type ClassroomMembershipUpdateManyWithWhereWithoutUserInput = {
    where: ClassroomMembershipScalarWhereInput
    data: XOR<ClassroomMembershipUpdateManyMutationInput, ClassroomMembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type ClassroomMembershipScalarWhereInput = {
    AND?: ClassroomMembershipScalarWhereInput | ClassroomMembershipScalarWhereInput[]
    OR?: ClassroomMembershipScalarWhereInput[]
    NOT?: ClassroomMembershipScalarWhereInput | ClassroomMembershipScalarWhereInput[]
    id?: IntFilter<"ClassroomMembership"> | number
    classroomId?: IntFilter<"ClassroomMembership"> | number
    userId?: IntFilter<"ClassroomMembership"> | number
    role?: StringFilter<"ClassroomMembership"> | string
    status?: StringFilter<"ClassroomMembership"> | string
    createdAt?: DateTimeFilter<"ClassroomMembership"> | Date | string
  }

  export type ClassroomPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ClassroomPostWhereUniqueInput
    update: XOR<ClassroomPostUpdateWithoutAuthorInput, ClassroomPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<ClassroomPostCreateWithoutAuthorInput, ClassroomPostUncheckedCreateWithoutAuthorInput>
  }

  export type ClassroomPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ClassroomPostWhereUniqueInput
    data: XOR<ClassroomPostUpdateWithoutAuthorInput, ClassroomPostUncheckedUpdateWithoutAuthorInput>
  }

  export type ClassroomPostUpdateManyWithWhereWithoutAuthorInput = {
    where: ClassroomPostScalarWhereInput
    data: XOR<ClassroomPostUpdateManyMutationInput, ClassroomPostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ClassroomPostScalarWhereInput = {
    AND?: ClassroomPostScalarWhereInput | ClassroomPostScalarWhereInput[]
    OR?: ClassroomPostScalarWhereInput[]
    NOT?: ClassroomPostScalarWhereInput | ClassroomPostScalarWhereInput[]
    id?: IntFilter<"ClassroomPost"> | number
    classroomId?: IntFilter<"ClassroomPost"> | number
    authorId?: IntFilter<"ClassroomPost"> | number
    content?: StringFilter<"ClassroomPost"> | string
    pinned?: BoolFilter<"ClassroomPost"> | boolean
    createdAt?: DateTimeFilter<"ClassroomPost"> | Date | string
    updatedAt?: DateTimeFilter<"ClassroomPost"> | Date | string
  }

  export type ClassroomCommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ClassroomCommentWhereUniqueInput
    update: XOR<ClassroomCommentUpdateWithoutAuthorInput, ClassroomCommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<ClassroomCommentCreateWithoutAuthorInput, ClassroomCommentUncheckedCreateWithoutAuthorInput>
  }

  export type ClassroomCommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ClassroomCommentWhereUniqueInput
    data: XOR<ClassroomCommentUpdateWithoutAuthorInput, ClassroomCommentUncheckedUpdateWithoutAuthorInput>
  }

  export type ClassroomCommentUpdateManyWithWhereWithoutAuthorInput = {
    where: ClassroomCommentScalarWhereInput
    data: XOR<ClassroomCommentUpdateManyMutationInput, ClassroomCommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ClassroomCommentScalarWhereInput = {
    AND?: ClassroomCommentScalarWhereInput | ClassroomCommentScalarWhereInput[]
    OR?: ClassroomCommentScalarWhereInput[]
    NOT?: ClassroomCommentScalarWhereInput | ClassroomCommentScalarWhereInput[]
    id?: IntFilter<"ClassroomComment"> | number
    postId?: IntFilter<"ClassroomComment"> | number
    authorId?: IntFilter<"ClassroomComment"> | number
    content?: StringFilter<"ClassroomComment"> | string
    createdAt?: DateTimeFilter<"ClassroomComment"> | Date | string
    updatedAt?: DateTimeFilter<"ClassroomComment"> | Date | string
  }

  export type ClassroomResourceUpsertWithWhereUniqueWithoutAddedByUserInput = {
    where: ClassroomResourceWhereUniqueInput
    update: XOR<ClassroomResourceUpdateWithoutAddedByUserInput, ClassroomResourceUncheckedUpdateWithoutAddedByUserInput>
    create: XOR<ClassroomResourceCreateWithoutAddedByUserInput, ClassroomResourceUncheckedCreateWithoutAddedByUserInput>
  }

  export type ClassroomResourceUpdateWithWhereUniqueWithoutAddedByUserInput = {
    where: ClassroomResourceWhereUniqueInput
    data: XOR<ClassroomResourceUpdateWithoutAddedByUserInput, ClassroomResourceUncheckedUpdateWithoutAddedByUserInput>
  }

  export type ClassroomResourceUpdateManyWithWhereWithoutAddedByUserInput = {
    where: ClassroomResourceScalarWhereInput
    data: XOR<ClassroomResourceUpdateManyMutationInput, ClassroomResourceUncheckedUpdateManyWithoutAddedByUserInput>
  }

  export type ClassroomResourceScalarWhereInput = {
    AND?: ClassroomResourceScalarWhereInput | ClassroomResourceScalarWhereInput[]
    OR?: ClassroomResourceScalarWhereInput[]
    NOT?: ClassroomResourceScalarWhereInput | ClassroomResourceScalarWhereInput[]
    id?: IntFilter<"ClassroomResource"> | number
    classroomId?: IntFilter<"ClassroomResource"> | number
    courseId?: IntNullableFilter<"ClassroomResource"> | number | null
    quizId?: IntNullableFilter<"ClassroomResource"> | number | null
    pinnedAt?: DateTimeNullableFilter<"ClassroomResource"> | Date | string | null
    addedBy?: IntFilter<"ClassroomResource"> | number
  }

  export type ChapterCreateWithoutCourseInput = {
    title: string
    order: number
    content?: string | null
    blocks?: string | null
    quizzes?: QuizCreateNestedManyWithoutChapterInput
    blockProgress?: BlockProgressCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutCourseInput = {
    id?: number
    title: string
    order: number
    content?: string | null
    blocks?: string | null
    quizzes?: QuizUncheckedCreateNestedManyWithoutChapterInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutCourseInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutCourseInput, ChapterUncheckedCreateWithoutCourseInput>
  }

  export type ChapterCreateManyCourseInputEnvelope = {
    data: ChapterCreateManyCourseInput | ChapterCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type QuizCreateWithoutCourseInput = {
    title: string
    visibility?: string
    questions: string
    settings?: string | null
    quizType?: string
    attemptLimit?: number | null
    scoreReleaseMode?: string
    createdAt?: Date | string
    chapter?: ChapterCreateNestedOneWithoutQuizzesInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
    classroomResources?: ClassroomResourceCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutCourseInput = {
    id?: number
    chapterId?: number | null
    title: string
    visibility?: string
    questions: string
    settings?: string | null
    quizType?: string
    attemptLimit?: number | null
    scoreReleaseMode?: string
    createdAt?: Date | string
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
    classroomResources?: ClassroomResourceUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutCourseInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutCourseInput, QuizUncheckedCreateWithoutCourseInput>
  }

  export type QuizCreateManyCourseInputEnvelope = {
    data: QuizCreateManyCourseInput | QuizCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCoursesInput = {
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    attempts?: QuizAttemptCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceCreateNestedManyWithoutAddedByUserInput
  }

  export type UserUncheckedCreateWithoutCoursesInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostUncheckedCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentUncheckedCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceUncheckedCreateNestedManyWithoutAddedByUserInput
  }

  export type UserCreateOrConnectWithoutCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
  }

  export type ClassroomResourceCreateWithoutCourseInput = {
    pinnedAt?: Date | string | null
    classroom: ClassroomCreateNestedOneWithoutResourcesInput
    quiz?: QuizCreateNestedOneWithoutClassroomResourcesInput
    addedByUser: UserCreateNestedOneWithoutClassroomResourcesAddedInput
  }

  export type ClassroomResourceUncheckedCreateWithoutCourseInput = {
    id?: number
    classroomId: number
    quizId?: number | null
    pinnedAt?: Date | string | null
    addedBy: number
  }

  export type ClassroomResourceCreateOrConnectWithoutCourseInput = {
    where: ClassroomResourceWhereUniqueInput
    create: XOR<ClassroomResourceCreateWithoutCourseInput, ClassroomResourceUncheckedCreateWithoutCourseInput>
  }

  export type ClassroomResourceCreateManyCourseInputEnvelope = {
    data: ClassroomResourceCreateManyCourseInput | ClassroomResourceCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ChapterUpsertWithWhereUniqueWithoutCourseInput = {
    where: ChapterWhereUniqueInput
    update: XOR<ChapterUpdateWithoutCourseInput, ChapterUncheckedUpdateWithoutCourseInput>
    create: XOR<ChapterCreateWithoutCourseInput, ChapterUncheckedCreateWithoutCourseInput>
  }

  export type ChapterUpdateWithWhereUniqueWithoutCourseInput = {
    where: ChapterWhereUniqueInput
    data: XOR<ChapterUpdateWithoutCourseInput, ChapterUncheckedUpdateWithoutCourseInput>
  }

  export type ChapterUpdateManyWithWhereWithoutCourseInput = {
    where: ChapterScalarWhereInput
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyWithoutCourseInput>
  }

  export type ChapterScalarWhereInput = {
    AND?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    OR?: ChapterScalarWhereInput[]
    NOT?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    id?: IntFilter<"Chapter"> | number
    courseId?: IntFilter<"Chapter"> | number
    title?: StringFilter<"Chapter"> | string
    order?: IntFilter<"Chapter"> | number
    content?: StringNullableFilter<"Chapter"> | string | null
    blocks?: StringNullableFilter<"Chapter"> | string | null
  }

  export type QuizUpsertWithWhereUniqueWithoutCourseInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutCourseInput, QuizUncheckedUpdateWithoutCourseInput>
    create: XOR<QuizCreateWithoutCourseInput, QuizUncheckedCreateWithoutCourseInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutCourseInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutCourseInput, QuizUncheckedUpdateWithoutCourseInput>
  }

  export type QuizUpdateManyWithWhereWithoutCourseInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutCourseInput>
  }

  export type QuizScalarWhereInput = {
    AND?: QuizScalarWhereInput | QuizScalarWhereInput[]
    OR?: QuizScalarWhereInput[]
    NOT?: QuizScalarWhereInput | QuizScalarWhereInput[]
    id?: IntFilter<"Quiz"> | number
    courseId?: IntNullableFilter<"Quiz"> | number | null
    chapterId?: IntNullableFilter<"Quiz"> | number | null
    title?: StringFilter<"Quiz"> | string
    visibility?: StringFilter<"Quiz"> | string
    questions?: StringFilter<"Quiz"> | string
    settings?: StringNullableFilter<"Quiz"> | string | null
    quizType?: StringFilter<"Quiz"> | string
    attemptLimit?: IntNullableFilter<"Quiz"> | number | null
    scoreReleaseMode?: StringFilter<"Quiz"> | string
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
  }

  export type UserUpsertWithoutCoursesInput = {
    update: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type UserUpdateWithoutCoursesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoursesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUncheckedUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUncheckedUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUncheckedUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUncheckedUpdateManyWithoutAddedByUserNestedInput
  }

  export type ClassroomResourceUpsertWithWhereUniqueWithoutCourseInput = {
    where: ClassroomResourceWhereUniqueInput
    update: XOR<ClassroomResourceUpdateWithoutCourseInput, ClassroomResourceUncheckedUpdateWithoutCourseInput>
    create: XOR<ClassroomResourceCreateWithoutCourseInput, ClassroomResourceUncheckedCreateWithoutCourseInput>
  }

  export type ClassroomResourceUpdateWithWhereUniqueWithoutCourseInput = {
    where: ClassroomResourceWhereUniqueInput
    data: XOR<ClassroomResourceUpdateWithoutCourseInput, ClassroomResourceUncheckedUpdateWithoutCourseInput>
  }

  export type ClassroomResourceUpdateManyWithWhereWithoutCourseInput = {
    where: ClassroomResourceScalarWhereInput
    data: XOR<ClassroomResourceUpdateManyMutationInput, ClassroomResourceUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutChaptersInput = {
    title: string
    description?: string | null
    slug: string
    visibility?: string
    createdAt?: Date | string
    quizzes?: QuizCreateNestedManyWithoutCourseInput
    creator: UserCreateNestedOneWithoutCoursesInput
    classroomResources?: ClassroomResourceCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutChaptersInput = {
    id?: number
    title: string
    description?: string | null
    slug: string
    visibility?: string
    createdBy: number
    createdAt?: Date | string
    quizzes?: QuizUncheckedCreateNestedManyWithoutCourseInput
    classroomResources?: ClassroomResourceUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutChaptersInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutChaptersInput, CourseUncheckedCreateWithoutChaptersInput>
  }

  export type QuizCreateWithoutChapterInput = {
    title: string
    visibility?: string
    questions: string
    settings?: string | null
    quizType?: string
    attemptLimit?: number | null
    scoreReleaseMode?: string
    createdAt?: Date | string
    course?: CourseCreateNestedOneWithoutQuizzesInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
    classroomResources?: ClassroomResourceCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutChapterInput = {
    id?: number
    courseId?: number | null
    title: string
    visibility?: string
    questions: string
    settings?: string | null
    quizType?: string
    attemptLimit?: number | null
    scoreReleaseMode?: string
    createdAt?: Date | string
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
    classroomResources?: ClassroomResourceUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutChapterInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutChapterInput, QuizUncheckedCreateWithoutChapterInput>
  }

  export type QuizCreateManyChapterInputEnvelope = {
    data: QuizCreateManyChapterInput | QuizCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type BlockProgressCreateWithoutChapterInput = {
    blockId: string
    blockType: string
    completed?: boolean
    score?: number | null
    attempts?: number
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBlockProgressInput
  }

  export type BlockProgressUncheckedCreateWithoutChapterInput = {
    id?: number
    userId: number
    blockId: string
    blockType: string
    completed?: boolean
    score?: number | null
    attempts?: number
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockProgressCreateOrConnectWithoutChapterInput = {
    where: BlockProgressWhereUniqueInput
    create: XOR<BlockProgressCreateWithoutChapterInput, BlockProgressUncheckedCreateWithoutChapterInput>
  }

  export type BlockProgressCreateManyChapterInputEnvelope = {
    data: BlockProgressCreateManyChapterInput | BlockProgressCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutChaptersInput = {
    update: XOR<CourseUpdateWithoutChaptersInput, CourseUncheckedUpdateWithoutChaptersInput>
    create: XOR<CourseCreateWithoutChaptersInput, CourseUncheckedCreateWithoutChaptersInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutChaptersInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutChaptersInput, CourseUncheckedUpdateWithoutChaptersInput>
  }

  export type CourseUpdateWithoutChaptersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUpdateManyWithoutCourseNestedInput
    creator?: UserUpdateOneRequiredWithoutCoursesNestedInput
    classroomResources?: ClassroomResourceUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutChaptersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUncheckedUpdateManyWithoutCourseNestedInput
    classroomResources?: ClassroomResourceUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type QuizUpsertWithWhereUniqueWithoutChapterInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutChapterInput, QuizUncheckedUpdateWithoutChapterInput>
    create: XOR<QuizCreateWithoutChapterInput, QuizUncheckedCreateWithoutChapterInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutChapterInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutChapterInput, QuizUncheckedUpdateWithoutChapterInput>
  }

  export type QuizUpdateManyWithWhereWithoutChapterInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutChapterInput>
  }

  export type BlockProgressUpsertWithWhereUniqueWithoutChapterInput = {
    where: BlockProgressWhereUniqueInput
    update: XOR<BlockProgressUpdateWithoutChapterInput, BlockProgressUncheckedUpdateWithoutChapterInput>
    create: XOR<BlockProgressCreateWithoutChapterInput, BlockProgressUncheckedCreateWithoutChapterInput>
  }

  export type BlockProgressUpdateWithWhereUniqueWithoutChapterInput = {
    where: BlockProgressWhereUniqueInput
    data: XOR<BlockProgressUpdateWithoutChapterInput, BlockProgressUncheckedUpdateWithoutChapterInput>
  }

  export type BlockProgressUpdateManyWithWhereWithoutChapterInput = {
    where: BlockProgressScalarWhereInput
    data: XOR<BlockProgressUpdateManyMutationInput, BlockProgressUncheckedUpdateManyWithoutChapterInput>
  }

  export type CourseCreateWithoutQuizzesInput = {
    title: string
    description?: string | null
    slug: string
    visibility?: string
    createdAt?: Date | string
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    creator: UserCreateNestedOneWithoutCoursesInput
    classroomResources?: ClassroomResourceCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutQuizzesInput = {
    id?: number
    title: string
    description?: string | null
    slug: string
    visibility?: string
    createdBy: number
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    classroomResources?: ClassroomResourceUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutQuizzesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutQuizzesInput, CourseUncheckedCreateWithoutQuizzesInput>
  }

  export type ChapterCreateWithoutQuizzesInput = {
    title: string
    order: number
    content?: string | null
    blocks?: string | null
    course: CourseCreateNestedOneWithoutChaptersInput
    blockProgress?: BlockProgressCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutQuizzesInput = {
    id?: number
    courseId: number
    title: string
    order: number
    content?: string | null
    blocks?: string | null
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutQuizzesInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutQuizzesInput, ChapterUncheckedCreateWithoutQuizzesInput>
  }

  export type QuizAttemptCreateWithoutQuizInput = {
    answers: string
    score: number
    totalQuestions: number
    correctAnswers: number
    percentage: number
    timeSpent: number
    detailedResults: string
    completedAt?: Date | string
    scoreReleasedAt?: Date | string | null
    endReason?: string
    user: UserCreateNestedOneWithoutAttemptsInput
  }

  export type QuizAttemptUncheckedCreateWithoutQuizInput = {
    id?: number
    userId: number
    answers: string
    score: number
    totalQuestions: number
    correctAnswers: number
    percentage: number
    timeSpent: number
    detailedResults: string
    completedAt?: Date | string
    scoreReleasedAt?: Date | string | null
    endReason?: string
  }

  export type QuizAttemptCreateOrConnectWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput>
  }

  export type QuizAttemptCreateManyQuizInputEnvelope = {
    data: QuizAttemptCreateManyQuizInput | QuizAttemptCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomResourceCreateWithoutQuizInput = {
    pinnedAt?: Date | string | null
    classroom: ClassroomCreateNestedOneWithoutResourcesInput
    course?: CourseCreateNestedOneWithoutClassroomResourcesInput
    addedByUser: UserCreateNestedOneWithoutClassroomResourcesAddedInput
  }

  export type ClassroomResourceUncheckedCreateWithoutQuizInput = {
    id?: number
    classroomId: number
    courseId?: number | null
    pinnedAt?: Date | string | null
    addedBy: number
  }

  export type ClassroomResourceCreateOrConnectWithoutQuizInput = {
    where: ClassroomResourceWhereUniqueInput
    create: XOR<ClassroomResourceCreateWithoutQuizInput, ClassroomResourceUncheckedCreateWithoutQuizInput>
  }

  export type ClassroomResourceCreateManyQuizInputEnvelope = {
    data: ClassroomResourceCreateManyQuizInput | ClassroomResourceCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutQuizzesInput = {
    update: XOR<CourseUpdateWithoutQuizzesInput, CourseUncheckedUpdateWithoutQuizzesInput>
    create: XOR<CourseCreateWithoutQuizzesInput, CourseUncheckedCreateWithoutQuizzesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutQuizzesInput, CourseUncheckedUpdateWithoutQuizzesInput>
  }

  export type CourseUpdateWithoutQuizzesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    creator?: UserUpdateOneRequiredWithoutCoursesNestedInput
    classroomResources?: ClassroomResourceUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    classroomResources?: ClassroomResourceUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ChapterUpsertWithoutQuizzesInput = {
    update: XOR<ChapterUpdateWithoutQuizzesInput, ChapterUncheckedUpdateWithoutQuizzesInput>
    create: XOR<ChapterCreateWithoutQuizzesInput, ChapterUncheckedCreateWithoutQuizzesInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutQuizzesInput, ChapterUncheckedUpdateWithoutQuizzesInput>
  }

  export type ChapterUpdateWithoutQuizzesInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutChaptersNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: NullableStringFieldUpdateOperationsInput | string | null
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutQuizInput, QuizAttemptUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutQuizInput, QuizAttemptUncheckedUpdateWithoutQuizInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutQuizInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutQuizInput>
  }

  export type ClassroomResourceUpsertWithWhereUniqueWithoutQuizInput = {
    where: ClassroomResourceWhereUniqueInput
    update: XOR<ClassroomResourceUpdateWithoutQuizInput, ClassroomResourceUncheckedUpdateWithoutQuizInput>
    create: XOR<ClassroomResourceCreateWithoutQuizInput, ClassroomResourceUncheckedCreateWithoutQuizInput>
  }

  export type ClassroomResourceUpdateWithWhereUniqueWithoutQuizInput = {
    where: ClassroomResourceWhereUniqueInput
    data: XOR<ClassroomResourceUpdateWithoutQuizInput, ClassroomResourceUncheckedUpdateWithoutQuizInput>
  }

  export type ClassroomResourceUpdateManyWithWhereWithoutQuizInput = {
    where: ClassroomResourceScalarWhereInput
    data: XOR<ClassroomResourceUpdateManyMutationInput, ClassroomResourceUncheckedUpdateManyWithoutQuizInput>
  }

  export type UserCreateWithoutAttemptsInput = {
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseCreateNestedManyWithoutCreatorInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceCreateNestedManyWithoutAddedByUserInput
  }

  export type UserUncheckedCreateWithoutAttemptsInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostUncheckedCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentUncheckedCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceUncheckedCreateNestedManyWithoutAddedByUserInput
  }

  export type UserCreateOrConnectWithoutAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttemptsInput, UserUncheckedCreateWithoutAttemptsInput>
  }

  export type QuizCreateWithoutAttemptsInput = {
    title: string
    visibility?: string
    questions: string
    settings?: string | null
    quizType?: string
    attemptLimit?: number | null
    scoreReleaseMode?: string
    createdAt?: Date | string
    course?: CourseCreateNestedOneWithoutQuizzesInput
    chapter?: ChapterCreateNestedOneWithoutQuizzesInput
    classroomResources?: ClassroomResourceCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutAttemptsInput = {
    id?: number
    courseId?: number | null
    chapterId?: number | null
    title: string
    visibility?: string
    questions: string
    settings?: string | null
    quizType?: string
    attemptLimit?: number | null
    scoreReleaseMode?: string
    createdAt?: Date | string
    classroomResources?: ClassroomResourceUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutAttemptsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
  }

  export type UserUpsertWithoutAttemptsInput = {
    update: XOR<UserUpdateWithoutAttemptsInput, UserUncheckedUpdateWithoutAttemptsInput>
    create: XOR<UserCreateWithoutAttemptsInput, UserUncheckedCreateWithoutAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttemptsInput, UserUncheckedUpdateWithoutAttemptsInput>
  }

  export type UserUpdateWithoutAttemptsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUncheckedUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUncheckedUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUncheckedUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUncheckedUpdateManyWithoutAddedByUserNestedInput
  }

  export type QuizUpsertWithoutAttemptsInput = {
    update: XOR<QuizUpdateWithoutAttemptsInput, QuizUncheckedUpdateWithoutAttemptsInput>
    create: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutAttemptsInput, QuizUncheckedUpdateWithoutAttemptsInput>
  }

  export type QuizUpdateWithoutAttemptsInput = {
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutQuizzesNestedInput
    chapter?: ChapterUpdateOneWithoutQuizzesNestedInput
    classroomResources?: ClassroomResourceUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroomResources?: ClassroomResourceUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptCreateNestedManyWithoutUserInput
    blockProgress?: BlockProgressCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceCreateNestedManyWithoutAddedByUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostUncheckedCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentUncheckedCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceUncheckedCreateNestedManyWithoutAddedByUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUncheckedUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUncheckedUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUncheckedUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUncheckedUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceCreateNestedManyWithoutAddedByUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostUncheckedCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentUncheckedCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceUncheckedCreateNestedManyWithoutAddedByUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUncheckedUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUncheckedUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUncheckedUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUncheckedUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceCreateNestedManyWithoutAddedByUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostUncheckedCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentUncheckedCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceUncheckedCreateNestedManyWithoutAddedByUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUncheckedUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUncheckedUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUncheckedUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUncheckedUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceCreateNestedManyWithoutAddedByUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostUncheckedCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentUncheckedCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceUncheckedCreateNestedManyWithoutAddedByUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUncheckedUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUncheckedUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUncheckedUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUncheckedUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserCreateWithoutBlockProgressInput = {
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceCreateNestedManyWithoutAddedByUserInput
  }

  export type UserUncheckedCreateWithoutBlockProgressInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostUncheckedCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentUncheckedCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceUncheckedCreateNestedManyWithoutAddedByUserInput
  }

  export type UserCreateOrConnectWithoutBlockProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockProgressInput, UserUncheckedCreateWithoutBlockProgressInput>
  }

  export type ChapterCreateWithoutBlockProgressInput = {
    title: string
    order: number
    content?: string | null
    blocks?: string | null
    course: CourseCreateNestedOneWithoutChaptersInput
    quizzes?: QuizCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutBlockProgressInput = {
    id?: number
    courseId: number
    title: string
    order: number
    content?: string | null
    blocks?: string | null
    quizzes?: QuizUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutBlockProgressInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutBlockProgressInput, ChapterUncheckedCreateWithoutBlockProgressInput>
  }

  export type UserUpsertWithoutBlockProgressInput = {
    update: XOR<UserUpdateWithoutBlockProgressInput, UserUncheckedUpdateWithoutBlockProgressInput>
    create: XOR<UserCreateWithoutBlockProgressInput, UserUncheckedCreateWithoutBlockProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockProgressInput, UserUncheckedUpdateWithoutBlockProgressInput>
  }

  export type UserUpdateWithoutBlockProgressInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUncheckedUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUncheckedUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUncheckedUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUncheckedUpdateManyWithoutAddedByUserNestedInput
  }

  export type ChapterUpsertWithoutBlockProgressInput = {
    update: XOR<ChapterUpdateWithoutBlockProgressInput, ChapterUncheckedUpdateWithoutBlockProgressInput>
    create: XOR<ChapterCreateWithoutBlockProgressInput, ChapterUncheckedCreateWithoutBlockProgressInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutBlockProgressInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutBlockProgressInput, ChapterUncheckedUpdateWithoutBlockProgressInput>
  }

  export type ChapterUpdateWithoutBlockProgressInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutChaptersNestedInput
    quizzes?: QuizUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutBlockProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type UserCreateWithoutClassroomsCreatedInput = {
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    classroomMemberships?: ClassroomMembershipCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceCreateNestedManyWithoutAddedByUserInput
  }

  export type UserUncheckedCreateWithoutClassroomsCreatedInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    classroomMemberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostUncheckedCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentUncheckedCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceUncheckedCreateNestedManyWithoutAddedByUserInput
  }

  export type UserCreateOrConnectWithoutClassroomsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassroomsCreatedInput, UserUncheckedCreateWithoutClassroomsCreatedInput>
  }

  export type ClassroomMembershipCreateWithoutClassroomInput = {
    role?: string
    status?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutClassroomMembershipsInput
  }

  export type ClassroomMembershipUncheckedCreateWithoutClassroomInput = {
    id?: number
    userId: number
    role?: string
    status?: string
    createdAt?: Date | string
  }

  export type ClassroomMembershipCreateOrConnectWithoutClassroomInput = {
    where: ClassroomMembershipWhereUniqueInput
    create: XOR<ClassroomMembershipCreateWithoutClassroomInput, ClassroomMembershipUncheckedCreateWithoutClassroomInput>
  }

  export type ClassroomMembershipCreateManyClassroomInputEnvelope = {
    data: ClassroomMembershipCreateManyClassroomInput | ClassroomMembershipCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomPostCreateWithoutClassroomInput = {
    content: string
    pinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutClassroomPostsInput
    comments?: ClassroomCommentCreateNestedManyWithoutPostInput
  }

  export type ClassroomPostUncheckedCreateWithoutClassroomInput = {
    id?: number
    authorId: number
    content: string
    pinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ClassroomCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type ClassroomPostCreateOrConnectWithoutClassroomInput = {
    where: ClassroomPostWhereUniqueInput
    create: XOR<ClassroomPostCreateWithoutClassroomInput, ClassroomPostUncheckedCreateWithoutClassroomInput>
  }

  export type ClassroomPostCreateManyClassroomInputEnvelope = {
    data: ClassroomPostCreateManyClassroomInput | ClassroomPostCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomResourceCreateWithoutClassroomInput = {
    pinnedAt?: Date | string | null
    course?: CourseCreateNestedOneWithoutClassroomResourcesInput
    quiz?: QuizCreateNestedOneWithoutClassroomResourcesInput
    addedByUser: UserCreateNestedOneWithoutClassroomResourcesAddedInput
  }

  export type ClassroomResourceUncheckedCreateWithoutClassroomInput = {
    id?: number
    courseId?: number | null
    quizId?: number | null
    pinnedAt?: Date | string | null
    addedBy: number
  }

  export type ClassroomResourceCreateOrConnectWithoutClassroomInput = {
    where: ClassroomResourceWhereUniqueInput
    create: XOR<ClassroomResourceCreateWithoutClassroomInput, ClassroomResourceUncheckedCreateWithoutClassroomInput>
  }

  export type ClassroomResourceCreateManyClassroomInputEnvelope = {
    data: ClassroomResourceCreateManyClassroomInput | ClassroomResourceCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClassroomsCreatedInput = {
    update: XOR<UserUpdateWithoutClassroomsCreatedInput, UserUncheckedUpdateWithoutClassroomsCreatedInput>
    create: XOR<UserCreateWithoutClassroomsCreatedInput, UserUncheckedCreateWithoutClassroomsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassroomsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassroomsCreatedInput, UserUncheckedUpdateWithoutClassroomsCreatedInput>
  }

  export type UserUpdateWithoutClassroomsCreatedInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    classroomMemberships?: ClassroomMembershipUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClassroomsCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    classroomMemberships?: ClassroomMembershipUncheckedUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUncheckedUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUncheckedUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUncheckedUpdateManyWithoutAddedByUserNestedInput
  }

  export type ClassroomMembershipUpsertWithWhereUniqueWithoutClassroomInput = {
    where: ClassroomMembershipWhereUniqueInput
    update: XOR<ClassroomMembershipUpdateWithoutClassroomInput, ClassroomMembershipUncheckedUpdateWithoutClassroomInput>
    create: XOR<ClassroomMembershipCreateWithoutClassroomInput, ClassroomMembershipUncheckedCreateWithoutClassroomInput>
  }

  export type ClassroomMembershipUpdateWithWhereUniqueWithoutClassroomInput = {
    where: ClassroomMembershipWhereUniqueInput
    data: XOR<ClassroomMembershipUpdateWithoutClassroomInput, ClassroomMembershipUncheckedUpdateWithoutClassroomInput>
  }

  export type ClassroomMembershipUpdateManyWithWhereWithoutClassroomInput = {
    where: ClassroomMembershipScalarWhereInput
    data: XOR<ClassroomMembershipUpdateManyMutationInput, ClassroomMembershipUncheckedUpdateManyWithoutClassroomInput>
  }

  export type ClassroomPostUpsertWithWhereUniqueWithoutClassroomInput = {
    where: ClassroomPostWhereUniqueInput
    update: XOR<ClassroomPostUpdateWithoutClassroomInput, ClassroomPostUncheckedUpdateWithoutClassroomInput>
    create: XOR<ClassroomPostCreateWithoutClassroomInput, ClassroomPostUncheckedCreateWithoutClassroomInput>
  }

  export type ClassroomPostUpdateWithWhereUniqueWithoutClassroomInput = {
    where: ClassroomPostWhereUniqueInput
    data: XOR<ClassroomPostUpdateWithoutClassroomInput, ClassroomPostUncheckedUpdateWithoutClassroomInput>
  }

  export type ClassroomPostUpdateManyWithWhereWithoutClassroomInput = {
    where: ClassroomPostScalarWhereInput
    data: XOR<ClassroomPostUpdateManyMutationInput, ClassroomPostUncheckedUpdateManyWithoutClassroomInput>
  }

  export type ClassroomResourceUpsertWithWhereUniqueWithoutClassroomInput = {
    where: ClassroomResourceWhereUniqueInput
    update: XOR<ClassroomResourceUpdateWithoutClassroomInput, ClassroomResourceUncheckedUpdateWithoutClassroomInput>
    create: XOR<ClassroomResourceCreateWithoutClassroomInput, ClassroomResourceUncheckedCreateWithoutClassroomInput>
  }

  export type ClassroomResourceUpdateWithWhereUniqueWithoutClassroomInput = {
    where: ClassroomResourceWhereUniqueInput
    data: XOR<ClassroomResourceUpdateWithoutClassroomInput, ClassroomResourceUncheckedUpdateWithoutClassroomInput>
  }

  export type ClassroomResourceUpdateManyWithWhereWithoutClassroomInput = {
    where: ClassroomResourceScalarWhereInput
    data: XOR<ClassroomResourceUpdateManyMutationInput, ClassroomResourceUncheckedUpdateManyWithoutClassroomInput>
  }

  export type ClassroomCreateWithoutMembershipsInput = {
    title: string
    description?: string | null
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutClassroomsCreatedInput
    posts?: ClassroomPostCreateNestedManyWithoutClassroomInput
    resources?: ClassroomResourceCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutMembershipsInput = {
    id?: number
    title: string
    description?: string | null
    isPrivate?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: ClassroomPostUncheckedCreateNestedManyWithoutClassroomInput
    resources?: ClassroomResourceUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutMembershipsInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutMembershipsInput, ClassroomUncheckedCreateWithoutMembershipsInput>
  }

  export type UserCreateWithoutClassroomMembershipsInput = {
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomPosts?: ClassroomPostCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceCreateNestedManyWithoutAddedByUserInput
  }

  export type UserUncheckedCreateWithoutClassroomMembershipsInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomPosts?: ClassroomPostUncheckedCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentUncheckedCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceUncheckedCreateNestedManyWithoutAddedByUserInput
  }

  export type UserCreateOrConnectWithoutClassroomMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassroomMembershipsInput, UserUncheckedCreateWithoutClassroomMembershipsInput>
  }

  export type ClassroomUpsertWithoutMembershipsInput = {
    update: XOR<ClassroomUpdateWithoutMembershipsInput, ClassroomUncheckedUpdateWithoutMembershipsInput>
    create: XOR<ClassroomCreateWithoutMembershipsInput, ClassroomUncheckedCreateWithoutMembershipsInput>
    where?: ClassroomWhereInput
  }

  export type ClassroomUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: ClassroomWhereInput
    data: XOR<ClassroomUpdateWithoutMembershipsInput, ClassroomUncheckedUpdateWithoutMembershipsInput>
  }

  export type ClassroomUpdateWithoutMembershipsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutClassroomsCreatedNestedInput
    posts?: ClassroomPostUpdateManyWithoutClassroomNestedInput
    resources?: ClassroomResourceUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutMembershipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ClassroomPostUncheckedUpdateManyWithoutClassroomNestedInput
    resources?: ClassroomResourceUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type UserUpsertWithoutClassroomMembershipsInput = {
    update: XOR<UserUpdateWithoutClassroomMembershipsInput, UserUncheckedUpdateWithoutClassroomMembershipsInput>
    create: XOR<UserCreateWithoutClassroomMembershipsInput, UserUncheckedCreateWithoutClassroomMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassroomMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassroomMembershipsInput, UserUncheckedUpdateWithoutClassroomMembershipsInput>
  }

  export type UserUpdateWithoutClassroomMembershipsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomPosts?: ClassroomPostUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClassroomMembershipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomPosts?: ClassroomPostUncheckedUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUncheckedUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUncheckedUpdateManyWithoutAddedByUserNestedInput
  }

  export type ClassroomCreateWithoutPostsInput = {
    title: string
    description?: string | null
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutClassroomsCreatedInput
    memberships?: ClassroomMembershipCreateNestedManyWithoutClassroomInput
    resources?: ClassroomResourceCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutPostsInput = {
    id?: number
    title: string
    description?: string | null
    isPrivate?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutClassroomInput
    resources?: ClassroomResourceUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutPostsInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutPostsInput, ClassroomUncheckedCreateWithoutPostsInput>
  }

  export type UserCreateWithoutClassroomPostsInput = {
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipCreateNestedManyWithoutUserInput
    classroomComments?: ClassroomCommentCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceCreateNestedManyWithoutAddedByUserInput
  }

  export type UserUncheckedCreateWithoutClassroomPostsInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutUserInput
    classroomComments?: ClassroomCommentUncheckedCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceUncheckedCreateNestedManyWithoutAddedByUserInput
  }

  export type UserCreateOrConnectWithoutClassroomPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassroomPostsInput, UserUncheckedCreateWithoutClassroomPostsInput>
  }

  export type ClassroomCommentCreateWithoutPostInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutClassroomCommentsInput
  }

  export type ClassroomCommentUncheckedCreateWithoutPostInput = {
    id?: number
    authorId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomCommentCreateOrConnectWithoutPostInput = {
    where: ClassroomCommentWhereUniqueInput
    create: XOR<ClassroomCommentCreateWithoutPostInput, ClassroomCommentUncheckedCreateWithoutPostInput>
  }

  export type ClassroomCommentCreateManyPostInputEnvelope = {
    data: ClassroomCommentCreateManyPostInput | ClassroomCommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomUpsertWithoutPostsInput = {
    update: XOR<ClassroomUpdateWithoutPostsInput, ClassroomUncheckedUpdateWithoutPostsInput>
    create: XOR<ClassroomCreateWithoutPostsInput, ClassroomUncheckedCreateWithoutPostsInput>
    where?: ClassroomWhereInput
  }

  export type ClassroomUpdateToOneWithWhereWithoutPostsInput = {
    where?: ClassroomWhereInput
    data: XOR<ClassroomUpdateWithoutPostsInput, ClassroomUncheckedUpdateWithoutPostsInput>
  }

  export type ClassroomUpdateWithoutPostsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutClassroomsCreatedNestedInput
    memberships?: ClassroomMembershipUpdateManyWithoutClassroomNestedInput
    resources?: ClassroomResourceUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: ClassroomMembershipUncheckedUpdateManyWithoutClassroomNestedInput
    resources?: ClassroomResourceUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type UserUpsertWithoutClassroomPostsInput = {
    update: XOR<UserUpdateWithoutClassroomPostsInput, UserUncheckedUpdateWithoutClassroomPostsInput>
    create: XOR<UserCreateWithoutClassroomPostsInput, UserUncheckedCreateWithoutClassroomPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassroomPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassroomPostsInput, UserUncheckedUpdateWithoutClassroomPostsInput>
  }

  export type UserUpdateWithoutClassroomPostsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUpdateManyWithoutUserNestedInput
    classroomComments?: ClassroomCommentUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClassroomPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUncheckedUpdateManyWithoutUserNestedInput
    classroomComments?: ClassroomCommentUncheckedUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUncheckedUpdateManyWithoutAddedByUserNestedInput
  }

  export type ClassroomCommentUpsertWithWhereUniqueWithoutPostInput = {
    where: ClassroomCommentWhereUniqueInput
    update: XOR<ClassroomCommentUpdateWithoutPostInput, ClassroomCommentUncheckedUpdateWithoutPostInput>
    create: XOR<ClassroomCommentCreateWithoutPostInput, ClassroomCommentUncheckedCreateWithoutPostInput>
  }

  export type ClassroomCommentUpdateWithWhereUniqueWithoutPostInput = {
    where: ClassroomCommentWhereUniqueInput
    data: XOR<ClassroomCommentUpdateWithoutPostInput, ClassroomCommentUncheckedUpdateWithoutPostInput>
  }

  export type ClassroomCommentUpdateManyWithWhereWithoutPostInput = {
    where: ClassroomCommentScalarWhereInput
    data: XOR<ClassroomCommentUpdateManyMutationInput, ClassroomCommentUncheckedUpdateManyWithoutPostInput>
  }

  export type ClassroomPostCreateWithoutCommentsInput = {
    content: string
    pinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    classroom: ClassroomCreateNestedOneWithoutPostsInput
    author: UserCreateNestedOneWithoutClassroomPostsInput
  }

  export type ClassroomPostUncheckedCreateWithoutCommentsInput = {
    id?: number
    classroomId: number
    authorId: number
    content: string
    pinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomPostCreateOrConnectWithoutCommentsInput = {
    where: ClassroomPostWhereUniqueInput
    create: XOR<ClassroomPostCreateWithoutCommentsInput, ClassroomPostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutClassroomCommentsInput = {
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceCreateNestedManyWithoutAddedByUserInput
  }

  export type UserUncheckedCreateWithoutClassroomCommentsInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostUncheckedCreateNestedManyWithoutAuthorInput
    classroomResourcesAdded?: ClassroomResourceUncheckedCreateNestedManyWithoutAddedByUserInput
  }

  export type UserCreateOrConnectWithoutClassroomCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassroomCommentsInput, UserUncheckedCreateWithoutClassroomCommentsInput>
  }

  export type ClassroomPostUpsertWithoutCommentsInput = {
    update: XOR<ClassroomPostUpdateWithoutCommentsInput, ClassroomPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<ClassroomPostCreateWithoutCommentsInput, ClassroomPostUncheckedCreateWithoutCommentsInput>
    where?: ClassroomPostWhereInput
  }

  export type ClassroomPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ClassroomPostWhereInput
    data: XOR<ClassroomPostUpdateWithoutCommentsInput, ClassroomPostUncheckedUpdateWithoutCommentsInput>
  }

  export type ClassroomPostUpdateWithoutCommentsInput = {
    content?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: ClassroomUpdateOneRequiredWithoutPostsNestedInput
    author?: UserUpdateOneRequiredWithoutClassroomPostsNestedInput
  }

  export type ClassroomPostUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutClassroomCommentsInput = {
    update: XOR<UserUpdateWithoutClassroomCommentsInput, UserUncheckedUpdateWithoutClassroomCommentsInput>
    create: XOR<UserCreateWithoutClassroomCommentsInput, UserUncheckedCreateWithoutClassroomCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassroomCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassroomCommentsInput, UserUncheckedUpdateWithoutClassroomCommentsInput>
  }

  export type UserUpdateWithoutClassroomCommentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUpdateManyWithoutAddedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClassroomCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUncheckedUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUncheckedUpdateManyWithoutAuthorNestedInput
    classroomResourcesAdded?: ClassroomResourceUncheckedUpdateManyWithoutAddedByUserNestedInput
  }

  export type ClassroomCreateWithoutResourcesInput = {
    title: string
    description?: string | null
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutClassroomsCreatedInput
    memberships?: ClassroomMembershipCreateNestedManyWithoutClassroomInput
    posts?: ClassroomPostCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutResourcesInput = {
    id?: number
    title: string
    description?: string | null
    isPrivate?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutClassroomInput
    posts?: ClassroomPostUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutResourcesInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutResourcesInput, ClassroomUncheckedCreateWithoutResourcesInput>
  }

  export type CourseCreateWithoutClassroomResourcesInput = {
    title: string
    description?: string | null
    slug: string
    visibility?: string
    createdAt?: Date | string
    chapters?: ChapterCreateNestedManyWithoutCourseInput
    quizzes?: QuizCreateNestedManyWithoutCourseInput
    creator: UserCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutClassroomResourcesInput = {
    id?: number
    title: string
    description?: string | null
    slug: string
    visibility?: string
    createdBy: number
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutCourseInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutClassroomResourcesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutClassroomResourcesInput, CourseUncheckedCreateWithoutClassroomResourcesInput>
  }

  export type QuizCreateWithoutClassroomResourcesInput = {
    title: string
    visibility?: string
    questions: string
    settings?: string | null
    quizType?: string
    attemptLimit?: number | null
    scoreReleaseMode?: string
    createdAt?: Date | string
    course?: CourseCreateNestedOneWithoutQuizzesInput
    chapter?: ChapterCreateNestedOneWithoutQuizzesInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutClassroomResourcesInput = {
    id?: number
    courseId?: number | null
    chapterId?: number | null
    title: string
    visibility?: string
    questions: string
    settings?: string | null
    quizType?: string
    attemptLimit?: number | null
    scoreReleaseMode?: string
    createdAt?: Date | string
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutClassroomResourcesInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutClassroomResourcesInput, QuizUncheckedCreateWithoutClassroomResourcesInput>
  }

  export type UserCreateWithoutClassroomResourcesAddedInput = {
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutClassroomResourcesAddedInput = {
    id?: number
    email: string
    password?: string | null
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    role?: string
    apiKey?: string | null
    createdAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    blockProgress?: BlockProgressUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    classroomsCreated?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomMemberships?: ClassroomMembershipUncheckedCreateNestedManyWithoutUserInput
    classroomPosts?: ClassroomPostUncheckedCreateNestedManyWithoutAuthorInput
    classroomComments?: ClassroomCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutClassroomResourcesAddedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassroomResourcesAddedInput, UserUncheckedCreateWithoutClassroomResourcesAddedInput>
  }

  export type ClassroomUpsertWithoutResourcesInput = {
    update: XOR<ClassroomUpdateWithoutResourcesInput, ClassroomUncheckedUpdateWithoutResourcesInput>
    create: XOR<ClassroomCreateWithoutResourcesInput, ClassroomUncheckedCreateWithoutResourcesInput>
    where?: ClassroomWhereInput
  }

  export type ClassroomUpdateToOneWithWhereWithoutResourcesInput = {
    where?: ClassroomWhereInput
    data: XOR<ClassroomUpdateWithoutResourcesInput, ClassroomUncheckedUpdateWithoutResourcesInput>
  }

  export type ClassroomUpdateWithoutResourcesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutClassroomsCreatedNestedInput
    memberships?: ClassroomMembershipUpdateManyWithoutClassroomNestedInput
    posts?: ClassroomPostUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: ClassroomMembershipUncheckedUpdateManyWithoutClassroomNestedInput
    posts?: ClassroomPostUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type CourseUpsertWithoutClassroomResourcesInput = {
    update: XOR<CourseUpdateWithoutClassroomResourcesInput, CourseUncheckedUpdateWithoutClassroomResourcesInput>
    create: XOR<CourseCreateWithoutClassroomResourcesInput, CourseUncheckedCreateWithoutClassroomResourcesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutClassroomResourcesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutClassroomResourcesInput, CourseUncheckedUpdateWithoutClassroomResourcesInput>
  }

  export type CourseUpdateWithoutClassroomResourcesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUpdateManyWithoutCourseNestedInput
    creator?: UserUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutClassroomResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type QuizUpsertWithoutClassroomResourcesInput = {
    update: XOR<QuizUpdateWithoutClassroomResourcesInput, QuizUncheckedUpdateWithoutClassroomResourcesInput>
    create: XOR<QuizCreateWithoutClassroomResourcesInput, QuizUncheckedCreateWithoutClassroomResourcesInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutClassroomResourcesInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutClassroomResourcesInput, QuizUncheckedUpdateWithoutClassroomResourcesInput>
  }

  export type QuizUpdateWithoutClassroomResourcesInput = {
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutQuizzesNestedInput
    chapter?: ChapterUpdateOneWithoutQuizzesNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutClassroomResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type UserUpsertWithoutClassroomResourcesAddedInput = {
    update: XOR<UserUpdateWithoutClassroomResourcesAddedInput, UserUncheckedUpdateWithoutClassroomResourcesAddedInput>
    create: XOR<UserCreateWithoutClassroomResourcesAddedInput, UserUncheckedCreateWithoutClassroomResourcesAddedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassroomResourcesAddedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassroomResourcesAddedInput, UserUncheckedUpdateWithoutClassroomResourcesAddedInput>
  }

  export type UserUpdateWithoutClassroomResourcesAddedInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutClassroomResourcesAddedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    classroomsCreated?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomMemberships?: ClassroomMembershipUncheckedUpdateManyWithoutUserNestedInput
    classroomPosts?: ClassroomPostUncheckedUpdateManyWithoutAuthorNestedInput
    classroomComments?: ClassroomCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CourseCreateManyCreatorInput = {
    id?: number
    title: string
    description?: string | null
    slug: string
    visibility?: string
    createdAt?: Date | string
  }

  export type QuizAttemptCreateManyUserInput = {
    id?: number
    quizId: number
    answers: string
    score: number
    totalQuestions: number
    correctAnswers: number
    percentage: number
    timeSpent: number
    detailedResults: string
    completedAt?: Date | string
    scoreReleasedAt?: Date | string | null
    endReason?: string
  }

  export type BlockProgressCreateManyUserInput = {
    id?: number
    chapterId: number
    blockId: string
    blockType: string
    completed?: boolean
    score?: number | null
    attempts?: number
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: number
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: number
    sessionToken: string
    expires: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
  }

  export type ClassroomCreateManyCreatorInput = {
    id?: number
    title: string
    description?: string | null
    isPrivate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomMembershipCreateManyUserInput = {
    id?: number
    classroomId: number
    role?: string
    status?: string
    createdAt?: Date | string
  }

  export type ClassroomPostCreateManyAuthorInput = {
    id?: number
    classroomId: number
    content: string
    pinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomCommentCreateManyAuthorInput = {
    id?: number
    postId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomResourceCreateManyAddedByUserInput = {
    id?: number
    classroomId: number
    courseId?: number | null
    quizId?: number | null
    pinnedAt?: Date | string | null
  }

  export type CourseUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUpdateManyWithoutCourseNestedInput
    classroomResources?: ClassroomResourceUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutCourseNestedInput
    classroomResources?: ClassroomResourceUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAttemptUpdateWithoutUserInput = {
    answers?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    percentage?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    detailedResults?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scoreReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endReason?: StringFieldUpdateOperationsInput | string
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    percentage?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    detailedResults?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scoreReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endReason?: StringFieldUpdateOperationsInput | string
  }

  export type QuizAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    percentage?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    detailedResults?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scoreReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endReason?: StringFieldUpdateOperationsInput | string
  }

  export type BlockProgressUpdateWithoutUserInput = {
    blockId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutBlockProgressNestedInput
  }

  export type BlockProgressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    blockId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockProgressUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    blockId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassroomUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: ClassroomMembershipUpdateManyWithoutClassroomNestedInput
    posts?: ClassroomPostUpdateManyWithoutClassroomNestedInput
    resources?: ClassroomResourceUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: ClassroomMembershipUncheckedUpdateManyWithoutClassroomNestedInput
    posts?: ClassroomPostUncheckedUpdateManyWithoutClassroomNestedInput
    resources?: ClassroomResourceUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomMembershipUpdateWithoutUserInput = {
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: ClassroomUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type ClassroomMembershipUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomMembershipUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomPostUpdateWithoutAuthorInput = {
    content?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: ClassroomUpdateOneRequiredWithoutPostsNestedInput
    comments?: ClassroomCommentUpdateManyWithoutPostNestedInput
  }

  export type ClassroomPostUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ClassroomCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ClassroomPostUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomCommentUpdateWithoutAuthorInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: ClassroomPostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ClassroomCommentUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomCommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomResourceUpdateWithoutAddedByUserInput = {
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: ClassroomUpdateOneRequiredWithoutResourcesNestedInput
    course?: CourseUpdateOneWithoutClassroomResourcesNestedInput
    quiz?: QuizUpdateOneWithoutClassroomResourcesNestedInput
  }

  export type ClassroomResourceUncheckedUpdateWithoutAddedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassroomResourceUncheckedUpdateManyWithoutAddedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChapterCreateManyCourseInput = {
    id?: number
    title: string
    order: number
    content?: string | null
    blocks?: string | null
  }

  export type QuizCreateManyCourseInput = {
    id?: number
    chapterId?: number | null
    title: string
    visibility?: string
    questions: string
    settings?: string | null
    quizType?: string
    attemptLimit?: number | null
    scoreReleaseMode?: string
    createdAt?: Date | string
  }

  export type ClassroomResourceCreateManyCourseInput = {
    id?: number
    classroomId: number
    quizId?: number | null
    pinnedAt?: Date | string | null
    addedBy: number
  }

  export type ChapterUpdateWithoutCourseInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUpdateManyWithoutChapterNestedInput
    blockProgress?: BlockProgressUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUncheckedUpdateManyWithoutChapterNestedInput
    blockProgress?: BlockProgressUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    blocks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizUpdateWithoutCourseInput = {
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneWithoutQuizzesNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
    classroomResources?: ClassroomResourceUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
    classroomResources?: ClassroomResourceUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapterId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomResourceUpdateWithoutCourseInput = {
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: ClassroomUpdateOneRequiredWithoutResourcesNestedInput
    quiz?: QuizUpdateOneWithoutClassroomResourcesNestedInput
    addedByUser?: UserUpdateOneRequiredWithoutClassroomResourcesAddedNestedInput
  }

  export type ClassroomResourceUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedBy?: IntFieldUpdateOperationsInput | number
  }

  export type ClassroomResourceUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedBy?: IntFieldUpdateOperationsInput | number
  }

  export type QuizCreateManyChapterInput = {
    id?: number
    courseId?: number | null
    title: string
    visibility?: string
    questions: string
    settings?: string | null
    quizType?: string
    attemptLimit?: number | null
    scoreReleaseMode?: string
    createdAt?: Date | string
  }

  export type BlockProgressCreateManyChapterInput = {
    id?: number
    userId: number
    blockId: string
    blockType: string
    completed?: boolean
    score?: number | null
    attempts?: number
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUpdateWithoutChapterInput = {
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutQuizzesNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
    classroomResources?: ClassroomResourceUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
    classroomResources?: ClassroomResourceUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    questions?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    quizType?: StringFieldUpdateOperationsInput | string
    attemptLimit?: NullableIntFieldUpdateOperationsInput | number | null
    scoreReleaseMode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockProgressUpdateWithoutChapterInput = {
    blockId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlockProgressNestedInput
  }

  export type BlockProgressUncheckedUpdateWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    blockId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockProgressUncheckedUpdateManyWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    blockId?: StringFieldUpdateOperationsInput | string
    blockType?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAttemptCreateManyQuizInput = {
    id?: number
    userId: number
    answers: string
    score: number
    totalQuestions: number
    correctAnswers: number
    percentage: number
    timeSpent: number
    detailedResults: string
    completedAt?: Date | string
    scoreReleasedAt?: Date | string | null
    endReason?: string
  }

  export type ClassroomResourceCreateManyQuizInput = {
    id?: number
    classroomId: number
    courseId?: number | null
    pinnedAt?: Date | string | null
    addedBy: number
  }

  export type QuizAttemptUpdateWithoutQuizInput = {
    answers?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    percentage?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    detailedResults?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scoreReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endReason?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    percentage?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    detailedResults?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scoreReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endReason?: StringFieldUpdateOperationsInput | string
  }

  export type QuizAttemptUncheckedUpdateManyWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    percentage?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    detailedResults?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scoreReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endReason?: StringFieldUpdateOperationsInput | string
  }

  export type ClassroomResourceUpdateWithoutQuizInput = {
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: ClassroomUpdateOneRequiredWithoutResourcesNestedInput
    course?: CourseUpdateOneWithoutClassroomResourcesNestedInput
    addedByUser?: UserUpdateOneRequiredWithoutClassroomResourcesAddedNestedInput
  }

  export type ClassroomResourceUncheckedUpdateWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedBy?: IntFieldUpdateOperationsInput | number
  }

  export type ClassroomResourceUncheckedUpdateManyWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedBy?: IntFieldUpdateOperationsInput | number
  }

  export type ClassroomMembershipCreateManyClassroomInput = {
    id?: number
    userId: number
    role?: string
    status?: string
    createdAt?: Date | string
  }

  export type ClassroomPostCreateManyClassroomInput = {
    id?: number
    authorId: number
    content: string
    pinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomResourceCreateManyClassroomInput = {
    id?: number
    courseId?: number | null
    quizId?: number | null
    pinnedAt?: Date | string | null
    addedBy: number
  }

  export type ClassroomMembershipUpdateWithoutClassroomInput = {
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClassroomMembershipsNestedInput
  }

  export type ClassroomMembershipUncheckedUpdateWithoutClassroomInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomMembershipUncheckedUpdateManyWithoutClassroomInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomPostUpdateWithoutClassroomInput = {
    content?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutClassroomPostsNestedInput
    comments?: ClassroomCommentUpdateManyWithoutPostNestedInput
  }

  export type ClassroomPostUncheckedUpdateWithoutClassroomInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ClassroomCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ClassroomPostUncheckedUpdateManyWithoutClassroomInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomResourceUpdateWithoutClassroomInput = {
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneWithoutClassroomResourcesNestedInput
    quiz?: QuizUpdateOneWithoutClassroomResourcesNestedInput
    addedByUser?: UserUpdateOneRequiredWithoutClassroomResourcesAddedNestedInput
  }

  export type ClassroomResourceUncheckedUpdateWithoutClassroomInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedBy?: IntFieldUpdateOperationsInput | number
  }

  export type ClassroomResourceUncheckedUpdateManyWithoutClassroomInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    pinnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedBy?: IntFieldUpdateOperationsInput | number
  }

  export type ClassroomCommentCreateManyPostInput = {
    id?: number
    authorId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomCommentUpdateWithoutPostInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutClassroomCommentsNestedInput
  }

  export type ClassroomCommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomCommentUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCountOutputTypeDefaultArgs instead
     */
    export type CourseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChapterCountOutputTypeDefaultArgs instead
     */
    export type ChapterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChapterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizCountOutputTypeDefaultArgs instead
     */
    export type QuizCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassroomCountOutputTypeDefaultArgs instead
     */
    export type ClassroomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassroomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassroomPostCountOutputTypeDefaultArgs instead
     */
    export type ClassroomPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassroomPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseDefaultArgs instead
     */
    export type CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChapterDefaultArgs instead
     */
    export type ChapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChapterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizDefaultArgs instead
     */
    export type QuizArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizAttemptDefaultArgs instead
     */
    export type QuizAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizAttemptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationTokenDefaultArgs instead
     */
    export type VerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetTokenDefaultArgs instead
     */
    export type PasswordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockProgressDefaultArgs instead
     */
    export type BlockProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassroomDefaultArgs instead
     */
    export type ClassroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassroomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassroomMembershipDefaultArgs instead
     */
    export type ClassroomMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassroomMembershipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassroomPostDefaultArgs instead
     */
    export type ClassroomPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassroomPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassroomCommentDefaultArgs instead
     */
    export type ClassroomCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassroomCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassroomResourceDefaultArgs instead
     */
    export type ClassroomResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassroomResourceDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}