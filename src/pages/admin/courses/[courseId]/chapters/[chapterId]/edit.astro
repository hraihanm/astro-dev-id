---
export const prerender = false;

import Layout from '../../../../../../components/Layout.astro';
import { prisma } from '../../../../../../lib/db';

const { courseId, chapterId } = Astro.params;

if (!courseId || !chapterId) {
  return Astro.redirect('/admin/courses');
}

const chapter = await prisma.chapter.findUnique({
  where: { id: parseInt(chapterId) },
  include: {
    course: true
  }
});

if (!chapter || chapter.courseId !== parseInt(courseId)) {
  return Astro.redirect(`/admin/courses/${courseId}/edit`);
}

// Get all chapters for this course to show order options
const allChapters = await prisma.chapter.findMany({
  where: { courseId: parseInt(courseId) },
  orderBy: { order: 'asc' }
});
---

<Layout title={`Edit ${chapter.title}`}>
  <!-- Preload marked.js and KaTeX for faster preview rendering -->
  <script is:inline>
    // Preload marked.js
    if (!window.marked) {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js';
      script.async = true;
      document.head.appendChild(script);
    }
    
    // Preload KaTeX CSS
    if (!document.getElementById('katex-css')) {
      const link = document.createElement('link');
      link.id = 'katex-css';
      link.rel = 'stylesheet';
      link.href = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css';
      document.head.appendChild(link);
    }
    
    // Preload KaTeX JS
    if (!window.katex && !document.getElementById('katex-js')) {
      const script = document.createElement('script');
      script.id = 'katex-js';
      script.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';
      script.async = true;
      script.onload = () => {
        console.log('KaTeX preloaded in head');
      };
      document.head.appendChild(script);
    }
  </script>
  <div class="min-h-screen bg-slate-50">
    <!-- Header -->
    <div class="bg-white border-b border-slate-200 sticky top-0 z-20">
      <div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex justify-between items-center h-16">
          <div class="flex items-center gap-4">
            <a href={`/admin/courses/${courseId}/edit`} class="text-slate-600 hover:text-slate-900 transition-colors">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
              </svg>
            </a>
            <div>
              <h1 class="text-xl font-bold text-slate-900">Edit Bab</h1>
              <p class="text-xs text-slate-500">Kursus: {chapter.course.title}</p>
            </div>
          </div>
          <div class="flex items-center gap-3">
            <a href="/admin/tutorial" target="_blank" class="text-sm text-blue-600 hover:text-blue-700 font-medium flex items-center gap-1">
              <span>üìö</span>
              <span>Tutorial Formatting</span>
            </a>
          </div>
        </div>
      </div>
    </div>

    <!-- Main Content: Split View -->
    <form id="chapter-form" class="h-[calc(100vh-4rem)] flex flex-col">
      <input type="hidden" name="chapterId" value={chapter.id} />
      
      <!-- Top Bar: Chapter Info -->
      <div class="bg-white border-b border-slate-200 px-4 sm:px-6 lg:px-8 py-3">
        <div class="flex flex-wrap items-center gap-4">
          <div class="flex-1 min-w-[200px]">
            <label for="title" class="block text-xs font-medium text-slate-700 mb-1">
              Judul Bab *
            </label>
            <input
              type="text"
              name="title"
              id="title"
              required
              value={chapter.title}
              class="w-full px-3 py-1.5 text-sm border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              placeholder="Bab 1: Pengenalan"
            />
          </div>
          <div class="w-32">
            <label for="order" class="block text-xs font-medium text-slate-700 mb-1">
              Urutan *
            </label>
            <select
              name="order"
              id="order"
              required
              class="w-full px-3 py-1.5 text-sm border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            >
              {Array.from({ length: allChapters.length + 5 }, (_, i) => i + 1).map((num) => (
                <option value={num} selected={num === chapter.order}>
                  {num}
                </option>
              ))}
            </select>
          </div>
          <div class="flex items-end gap-2">
            <p id="content-size" class="text-xs text-slate-500 mb-1">
              Ukuran: 0 KB
            </p>
          </div>
        </div>
      </div>

      <!-- Split View: Editor | Preview -->
      <div class="flex-1 flex overflow-hidden">
        <!-- Left: Editor -->
        <div class="flex-1 flex flex-col border-r border-slate-200 bg-white min-h-0">
          <div class="px-4 py-2 bg-slate-50 border-b border-slate-200 flex items-center justify-between flex-shrink-0">
            <div class="flex items-center gap-2">
              <svg class="w-4 h-4 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
              </svg>
              <span class="text-sm font-medium text-slate-700">Editor</span>
            </div>
            <div class="flex items-center gap-2">
              <a
                href="#tools-section"
                class="text-xs text-slate-600 hover:text-slate-900 font-medium px-2 py-1 hover:bg-slate-100 rounded transition-colors"
                title="Lihat Tools & Template"
              >
                Tools & Template ‚Üì
              </a>
            </div>
          </div>
          <!-- Hidden textarea for form submission -->
          <textarea
            name="content"
            id="content"
            style="display: none;"
          >{chapter.content || ''}</textarea>
          <!-- Monaco Editor container -->
          <div id="monaco-editor-container" class="flex-1 min-h-0" style="height: 100%;"></div>
          <div class="px-4 py-2 bg-slate-50 border-t border-slate-200">
            <p class="text-xs text-slate-500">
              Mendukung Markdown & LaTeX. Gunakan <code class="bg-slate-200 px-1 rounded">$...$</code> untuk inline dan <code class="bg-slate-200 px-1 rounded">$$...$$</code> untuk display math.
            </p>
          </div>
        </div>

        <!-- Right: Preview -->
        <div class="flex-1 flex flex-col bg-white">
          <div class="px-4 py-2 bg-slate-50 border-b border-slate-200 flex items-center justify-between">
            <div class="flex items-center gap-2">
              <svg class="w-4 h-4 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
              </svg>
              <span class="text-sm font-medium text-slate-700">Pratinjau</span>
            </div>
            <button
              type="button"
              id="preview-btn"
              class="text-xs text-blue-600 hover:text-blue-700 font-medium px-2 py-1 hover:bg-blue-50 rounded transition-colors"
            >
              Segarkan
            </button>
          </div>
          <div id="preview-content" class="flex-1 overflow-y-auto p-6 prose prose-slate max-w-none">
            <p class="text-slate-400 italic text-sm">Mulai mengetik untuk melihat pratinjau konten Anda...</p>
          </div>
        </div>
      </div>

      <!-- Bottom Bar: Actions -->
      <div class="bg-white border-t border-slate-200 px-4 sm:px-6 lg:px-8 py-4 flex items-center justify-between">
        <button
          type="button"
          id="delete-btn"
          class="px-4 py-2 text-sm font-medium text-red-600 hover:text-red-700 hover:bg-red-50 rounded-md transition-colors"
        >
          Hapus Bab
        </button>
        <div class="flex items-center gap-3">
          <a
            href={`/admin/courses/${courseId}/edit`}
            class="px-4 py-2 text-sm font-medium text-slate-700 hover:text-slate-900 hover:bg-slate-100 rounded-md transition-colors"
          >
            Batal
          </a>
          <button
            type="submit"
            class="px-6 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-md shadow-sm transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            Simpan Perubahan
          </button>
        </div>
      </div>
    </form>

    <!-- Tools & Reference Section -->
    <div id="tools-section" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 space-y-6">
      <!-- Interactive Block Tools -->
      <div class="bg-gradient-to-br from-green-50 to-emerald-50 border border-green-200 rounded-xl p-6 shadow-sm">
        <div class="flex items-center justify-between mb-4">
          <div>
            <h3 class="text-lg font-semibold text-green-900 mb-1">Interactive Block Tools</h3>
            <p class="text-sm text-green-700">
              Sisipkan elemen interaktif (kuis, simulasi, dll.) pada posisi kursor
            </p>
          </div>
          <a
            href="/admin/tutorial"
            target="_blank"
            class="text-sm text-green-700 hover:text-green-800 font-medium flex items-center gap-1 underline decoration-green-300 hover:decoration-green-500 transition-colors"
          >
            Lihat Tutorial Lengkap
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
          </a>
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3">
          <button
            type="button"
            id="insert-quiz"
            class="group flex flex-col items-center p-4 bg-white hover:bg-green-100 rounded-lg border-2 border-green-200 hover:border-green-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Blok Kuis"
          >
            <div class="w-10 h-10 bg-green-100 group-hover:bg-green-200 rounded-lg flex items-center justify-center mb-2 transition-colors">
              <svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
              </svg>
            </div>
            <span class="text-sm font-medium text-green-800">Kuis</span>
          </button>

          <button
            type="button"
            id="insert-simulation"
            class="group flex flex-col items-center p-4 bg-white hover:bg-purple-100 rounded-lg border-2 border-purple-200 hover:border-purple-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Blok Simulasi"
          >
            <div class="w-10 h-10 bg-purple-100 group-hover:bg-purple-200 rounded-lg flex items-center justify-center mb-2 transition-colors">
              <svg class="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <span class="text-sm font-medium text-purple-800">Simulasi</span>
          </button>

          <button
            type="button"
            id="insert-code-editor"
            class="group flex flex-col items-center p-4 bg-white hover:bg-indigo-100 rounded-lg border-2 border-indigo-200 hover:border-indigo-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Editor Kode"
          >
            <div class="w-10 h-10 bg-indigo-100 group-hover:bg-indigo-200 rounded-lg flex items-center justify-center mb-2 transition-colors">
              <svg class="w-5 h-5 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
              </svg>
            </div>
            <span class="text-sm font-medium text-indigo-800">Editor Kode</span>
          </button>

          <button
            type="button"
            id="insert-diagram"
            class="group flex flex-col items-center p-4 bg-white hover:bg-cyan-100 rounded-lg border-2 border-cyan-200 hover:border-cyan-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Diagram Interaktif"
          >
            <div class="w-10 h-10 bg-cyan-100 group-hover:bg-cyan-200 rounded-lg flex items-center justify-center mb-2 transition-colors">
              <svg class="w-5 h-5 text-cyan-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17V7m0 10a2 2 0 01-2 2H5a2 2 0 01-2-2V7a2 2 0 012-2h2a2 2 0 012 2m0 10a2 2 0 002 2h2a2 2 0 002-2M9 7a2 2 0 012-2h2a2 2 0 012 2m0 10V7m0 10a2 2 0 002 2h2a2 2 0 002-2V7a2 2 0 00-2-2h-2a2 2 0 00-2 2" />
              </svg>
            </div>
            <span class="text-sm font-medium text-cyan-800">Diagram</span>
          </button>
        </div>
      </div>

      <!-- Content Templates -->
      <div class="bg-gradient-to-br from-blue-50 to-sky-50 border border-blue-200 rounded-xl p-6 shadow-sm">
        <div class="mb-4">
          <h3 class="text-lg font-semibold text-blue-900 mb-1">Template Konten</h3>
          <p class="text-sm text-blue-700">
            Sisipkan blok konten yang sudah distyling pada posisi kursor
          </p>
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
          <button
            type="button"
            id="insert-definition"
            class="group flex items-center p-4 bg-white hover:bg-blue-100 rounded-lg border-2 border-blue-200 hover:border-blue-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Blok Definisi"
          >
            <div class="w-10 h-10 bg-blue-100 group-hover:bg-blue-200 rounded-lg flex items-center justify-center mr-3 transition-colors">
              <span class="text-xl">üìò</span>
            </div>
            <span class="text-sm font-medium text-blue-800">Definisi</span>
          </button>

          <button
            type="button"
            id="insert-theorem"
            class="group flex items-center p-4 bg-white hover:bg-emerald-100 rounded-lg border-2 border-emerald-200 hover:border-emerald-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Blok Teorema"
          >
            <div class="w-10 h-10 bg-emerald-100 group-hover:bg-emerald-200 rounded-lg flex items-center justify-center mr-3 transition-colors">
              <span class="text-xl">‚ö°</span>
            </div>
            <span class="text-sm font-medium text-emerald-800">Teorema</span>
          </button>

          <button
            type="button"
            id="insert-example"
            class="group flex items-center p-4 bg-white hover:bg-amber-100 rounded-lg border-2 border-amber-200 hover:border-amber-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Blok Contoh"
          >
            <div class="w-10 h-10 bg-amber-100 group-hover:bg-amber-200 rounded-lg flex items-center justify-center mr-3 transition-colors">
              <span class="text-xl">üìù</span>
            </div>
            <span class="text-sm font-medium text-amber-800">Contoh</span>
          </button>
        </div>
      </div>

      <!-- Quick Reference -->
      <div class="bg-gradient-to-br from-slate-50 to-gray-50 border border-slate-200 rounded-xl p-6 shadow-sm">
        <h3 class="text-lg font-semibold text-slate-900 mb-4">Referensi Cepat Markdown & LaTeX</h3>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div class="bg-white rounded-lg p-4 border border-slate-200">
            <h4 class="text-sm font-semibold text-slate-800 mb-3 flex items-center gap-2">
              <svg class="w-4 h-4 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" />
              </svg>
              Markdown
            </h4>
            <ul class="space-y-2 text-xs text-slate-700">
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">‚Ä¢</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">**tebal**</code> atau <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">__tebal__</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">‚Ä¢</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">*miring*</code> atau <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">_miring_</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">‚Ä¢</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800"># Heading 1</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">‚Ä¢</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">## Heading 2</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">‚Ä¢</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">[link](url)</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">‚Ä¢</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">![gambar](url)</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">‚Ä¢</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">`kode`</code> atau <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">```blok kode```</code></span>
              </li>
            </ul>
          </div>
          <div class="bg-white rounded-lg p-4 border border-slate-200">
            <h4 class="text-sm font-semibold text-slate-800 mb-3 flex items-center gap-2">
              <svg class="w-4 h-4 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 20l4-16m2 16l4-16M6 9h14M4 15h14" />
              </svg>
              LaTeX
            </h4>
            <ul class="space-y-2 text-xs text-slate-700">
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">‚Ä¢</span>
                <span>Inline: <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">$x^2 + y^2 = z^2$</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">‚Ä¢</span>
                <span>Display: <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">$$\int_0^1 x^2 dx$$</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">‚Ä¢</span>
                <span>Pecahan: <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">$\frac&#123;a&#125;&#123;b&#125;$</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">‚Ä¢</span>
                <span>Yunani: <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">$\alpha, \beta, \gamma$</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">‚Ä¢</span>
                <span>Akar: <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">$\sqrt&#123;x&#125;$</code></span>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</Layout>

<script define:vars={{ chapterId: chapter.id, courseId: parseInt(courseId) }}>
  // Track content size
  function updateContentSize() {
    const content = monacoEditor ? monacoEditor.getValue() : (document.getElementById('content')?.value || '');
    const size = new Blob([content]).size;
    const sizeDisplay = document.getElementById('content-size');

    if (!sizeDisplay) return;

    if (size < 1024) {
      sizeDisplay.textContent = `Size: ${size} bytes`;
      sizeDisplay.className = 'text-xs text-gray-400';
    } else if (size < 1024 * 1024) {
      sizeDisplay.textContent = `Size: ${(size / 1024).toFixed(1)} KB`;
      sizeDisplay.className = 'text-xs text-gray-400';
    } else if (size < 5 * 1024 * 1024) {
      sizeDisplay.textContent = `Size: ${(size / 1024 / 1024).toFixed(2)} MB`;
      sizeDisplay.className = 'text-xs text-yellow-600 font-medium';
    } else {
      sizeDisplay.textContent = `Size: ${(size / 1024 / 1024).toFixed(2)} MB (Large!)`;
      sizeDisplay.className = 'text-xs text-red-600 font-bold';
    }
  }

  // Generate unique block ID
  function generateBlockId() {
    return 'block-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  }

  // Monaco Editor instance
  let monacoEditor = null;

  // Load Monaco Editor from CDN
  async function loadMonacoEditor() {
    return new Promise((resolve, reject) => {
      if (window.monaco && window.monaco.editor) {
        resolve();
        return;
      }

      // Check if loader is already being loaded
      if (document.querySelector('script[src*="monaco-editor"]')) {
        // Wait for it to load
        const checkInterval = setInterval(() => {
          if (window.monaco && window.monaco.editor) {
            clearInterval(checkInterval);
            resolve();
          }
        }, 100);
        setTimeout(() => {
          clearInterval(checkInterval);
          if (!window.monaco || !window.monaco.editor) {
            reject(new Error('Monaco Editor failed to load'));
          }
        }, 10000);
        return;
      }

      // Load Monaco Editor using AMD loader approach
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.min.js';
      script.onload = () => {
        if (typeof require !== 'undefined') {
          require.config({ 
            paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' },
            'vs/nls': { availableLanguages: { '*': 'en' } }
          });
          require(['vs/editor/editor.main'], () => {
            console.log('Monaco Editor loaded successfully');
            resolve();
          }, (err) => {
            console.error('Monaco Editor load error:', err);
            reject(err);
          });
        } else {
          reject(new Error('require is not defined'));
        }
      };
      script.onerror = (err) => {
        console.error('Failed to load Monaco Editor script:', err);
        reject(err);
      };
      document.head.appendChild(script);
    });
  }

  // Initialize Monaco Editor
  async function initMonacoEditor() {
    try {
      const container = document.getElementById('monaco-editor-container');
      const hiddenTextarea = document.getElementById('content');
      
      if (!container || !hiddenTextarea) {
        console.error('Monaco Editor container or textarea not found');
        return;
      }

      // Ensure container has height
      if (container.offsetHeight === 0) {
        container.style.height = '500px';
      }

      console.log('Loading Monaco Editor...');
      await loadMonacoEditor();
      
      if (!window.monaco || !window.monaco.editor) {
        throw new Error('Monaco Editor not available after loading');
      }

      // Ensure container has proper dimensions
      const containerHeight = container.offsetHeight || container.clientHeight || 500;
      if (containerHeight < 100) {
        container.style.height = '500px';
      }
      
      // Wait a bit for container to be fully rendered
      await new Promise(resolve => setTimeout(resolve, 100));

      console.log('Creating Monaco Editor instance...');
      // Initialize Monaco Editor
      monacoEditor = window.monaco.editor.create(container, {
        value: hiddenTextarea.value || '',
        language: 'markdown',
        theme: 'vs',
        fontSize: 14,
        lineNumbers: 'on',
        roundedSelection: false,
        scrollBeyondLastLine: false,
        readOnly: false,
        minimap: { enabled: true },
        tabSize: 2,
        insertSpaces: true,
        wordWrap: 'on',
        automaticLayout: true,
        formatOnPaste: true,
        formatOnType: true,
        suggestOnTriggerCharacters: true,
        acceptSuggestionOnEnter: 'on',
        quickSuggestions: true,
        // Enable VSCode-like features
        codeLens: false,
        folding: true,
        bracketPairColorization: { enabled: true },
        // LaTeX support
        wordBasedSuggestions: 'allDocuments',
      });

      // Sync Monaco Editor content to hidden textarea and auto-update preview
      let previewUpdateTimeout;
      monacoEditor.onDidChangeModelContent(() => {
        const value = monacoEditor.getValue();
        hiddenTextarea.value = value;
        updateContentSize();
        
        // Debounce preview updates (update 500ms after user stops typing)
        clearTimeout(previewUpdateTimeout);
        previewUpdateTimeout = setTimeout(async () => {
          try {
            await updatePreview();
          } catch (error) {
            console.error('Error updating preview:', error);
          }
        }, 500);
      });

      // Update content size on initialization
      updateContentSize();

      console.log('Monaco Editor initialized successfully');
    } catch (error) {
      console.error('Failed to initialize Monaco Editor:', error);
      // Fallback to textarea if Monaco fails
      const container = document.getElementById('monaco-editor-container');
      const hiddenTextarea = document.getElementById('content');
      if (container && hiddenTextarea) {
        container.innerHTML = `<textarea id="content-fallback" class="w-full h-full p-3 border-0 font-mono text-sm" style="resize: none;">${hiddenTextarea.value || ''}</textarea>`;
        const fallback = document.getElementById('content-fallback');
        fallback.addEventListener('input', () => {
          hiddenTextarea.value = fallback.value;
          updateContentSize();
          updatePreview();
        });
      }
    }
  }

  // Insert text at cursor position (works with Monaco Editor or textarea)
  function insertAtCursor(element, text) {
    if (monacoEditor) {
      // Monaco Editor
      const selection = monacoEditor.getSelection();
      const range = new monaco.Range(
        selection.startLineNumber,
        selection.startColumn,
        selection.endLineNumber,
        selection.endColumn
      );
      const op = { range, text };
      monacoEditor.executeEdits('insert-text', [op]);
      monacoEditor.focus();
    } else if (element && element.tagName === 'TEXTAREA') {
      // Fallback to textarea
      const start = element.selectionStart;
      const end = element.selectionEnd;
      const before = element.value.substring(0, start);
      const after = element.value.substring(end);

      element.value = before + text + after;
      element.selectionStart = element.selectionEnd = start + text.length;
      element.focus();
      updateContentSize();
    }
  }

  // Block insertion handlers
  function setupBlockInsertion() {
    // Interactive blocks
    document.getElementById('insert-quiz')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const blockId = generateBlockId();
        const marker = `\n\n<!-- BLOCK:quiz:${blockId} -->\n\n`;
        insertAtCursor(editor, marker);
        updatePreview();
      }
    });

    document.getElementById('insert-simulation')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const blockId = generateBlockId();
        const marker = `\n\n<!-- BLOCK:simulation:${blockId} -->\n\n`;
        insertAtCursor(editor, marker);
        updatePreview();
      }
    });

    document.getElementById('insert-code-editor')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const blockId = generateBlockId();
        const marker = `\n\n<!-- BLOCK:code-editor:${blockId} -->\n\n`;
        insertAtCursor(editor, marker);
        updatePreview();
      }
    });

    document.getElementById('insert-diagram')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const blockId = generateBlockId();
        const marker = `\n\n<!-- BLOCK:interactive-diagram:${blockId} -->\n\n`;
        insertAtCursor(editor, marker);
        updatePreview();
      }
    });

    // Content templates
    document.getElementById('insert-definition')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const template = `<div class="definition-block">
  <div class="definition-header">üìò Definisi: [Judul Definisi]</div>
  <div class="definition-content">
    [Konten definisi di sini]
  </div>
</div>

`;
        insertAtCursor(editor, template);
        updatePreview();
      }
    });

    document.getElementById('insert-theorem')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const template = `<div class="theorem-block">
  <div class="theorem-header">‚ö° Teorema: [Nama Teorema]</div>
  <div class="theorem-content">
    $$[persamaan matematika]$$
  </div>
</div>

`;
        insertAtCursor(editor, template);
        updatePreview();
      }
    });

    document.getElementById('insert-example')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const template = `<div class="example-block">
  <div class="example-header">üìù Contoh [nomor]</div>
  <div class="example-problem">
    [Permasalahan atau soal]
  </div>
  <details>
    <summary>Lihat Solusi</summary>
    <div class="example-solution">
      [Solusi lengkap di sini]
    </div>
  </details>
</div>

`;
        insertAtCursor(editor, template);
        updatePreview();
      }
    });
  }
  
  // Load Marked (Markdown) from CDN once
  let markedLoadPromise;
  function loadMarkedAssets() {
    if (markedLoadPromise) return markedLoadPromise;
    markedLoadPromise = new Promise((resolve, reject) => {
      // Check if already loaded
      if (window.marked && typeof window.marked.parse === 'function') {
        try { 
          window.marked.setOptions({ 
            gfm: true, 
            breaks: true,
            headerIds: false,
            mangle: false
          }); 
        } catch (e) {
          console.warn('Error setting marked options:', e);
        }
        resolve();
        return;
      }
      
      // Check if script is already being loaded
      const existingScript = document.getElementById('marked-js');
      if (existingScript) {
        // Wait for it to load
        existingScript.onload = () => {
          if (window.marked && typeof window.marked.parse === 'function') {
            try {
              window.marked.setOptions({ 
                gfm: true, 
                breaks: true,
                headerIds: false,
                mangle: false
              });
            } catch (e) {
              console.warn('Error setting marked options:', e);
            }
            resolve();
          } else {
            reject(new Error('Marked.js loaded but not available'));
          }
        };
        existingScript.onerror = () => reject(new Error('Failed to load marked.js'));
        return;
      }
      
      // Create and load script
      const script = document.createElement('script');
      script.id = 'marked-js';
      script.src = 'https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js';
      script.onload = () => {
        // Wait a bit to ensure marked is available
        const checkMarked = () => {
          if (window.marked && typeof window.marked.parse === 'function') {
            try { 
              window.marked.setOptions({ 
                gfm: true, 
                breaks: true,
                headerIds: false,
                mangle: false
              }); 
            } catch (e) {
              console.warn('Error setting marked options:', e);
            }
            resolve();
          } else {
            // Retry after a short delay
            setTimeout(checkMarked, 50);
          }
        };
        checkMarked();
      };
      script.onerror = (e) => {
        console.error('Failed to load marked.js:', e);
        reject(new Error('Failed to load marked.js from CDN'));
      };
      document.head.appendChild(script);
    });
    return markedLoadPromise;
  }

  // Process LaTeX BEFORE markdown parsing (most reliable approach)
  function processLatexBeforeMarkdown(text) {
    if (!text) return text;
    
    // Step 1: Process display math blocks ($$...$$) FIRST
    const displayMathBlocks = [];
    text = text.replace(/\$\$([\s\S]*?)\$\$/g, (match, latex) => {
      const cleanLatex = sanitizeLatex((latex || '').trim());
      const placeholder = `__DISPLAY_MATH_${displayMathBlocks.length}__`;
      displayMathBlocks.push(cleanLatex);
      return placeholder;
    });
    
    // Step 2: Process inline math ($...$) - match single $...$ but not $$...$$
    const inlineMathBlocks = [];
    text = text.replace(/\$([^$\n]+?)\$/g, (match, latex) => {
      const cleanLatex = sanitizeLatex((latex || '').trim());
      const placeholder = `__INLINE_MATH_${inlineMathBlocks.length}__`;
      inlineMathBlocks.push(cleanLatex);
      return placeholder;
    });
    
    // Store blocks for later restoration
    text.__displayMathBlocks = displayMathBlocks;
    text.__inlineMathBlocks = inlineMathBlocks;
    
    return text;
  }
  
  // Restore LaTeX AFTER markdown parsing
  function restoreLatexAfterMarkdown(html, displayMathBlocks, inlineMathBlocks) {
    if (!html) return html;
    
    console.log('Restoring LaTeX:', displayMathBlocks.length, 'display,', inlineMathBlocks.length, 'inline');
    console.log('HTML before restoration (first 500 chars):', html.substring(0, 500));
    
    // Check what placeholders exist in HTML
    const displayPlaceholders = html.match(/\u200B\u200BDISPLAYMATH\d+\u200B\u200B/g) || [];
    const inlinePlaceholders = html.match(/\u200B\u200BINLINEMATH\d+\u200B\u200B/g) || [];
    console.log('Found placeholders in HTML:', displayPlaceholders.length, 'display,', inlinePlaceholders.length, 'inline');
    
    // Restore display math blocks
    displayMathBlocks.forEach((latex, index) => {
      const escapedLatex = latex.replace(/"/g, '&quot;');
      const mathDiv = `<div class="math-display" data-latex="${escapedLatex}"></div>`;
      const placeholder = `\u200B\u200BDISPLAYMATH${index}\u200B\u200B`;
      
      // Count occurrences before replacement
      const beforeCount = (html.match(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
      
      // Direct string replacement (most reliable)
      html = html.split(placeholder).join(mathDiv);
      
      // Also try with HTML-escaped zero-width spaces
      const escapedPlaceholder = placeholder.replace(/\u200B/g, '&#8203;');
      html = html.split(escapedPlaceholder).join(mathDiv);
      
      if (beforeCount > 0) {
        console.log(`Replaced ${beforeCount} occurrence(s) of DISPLAYMATH${index}`);
      }
    });
    
    // Restore inline math blocks
    inlineMathBlocks.forEach((latex, index) => {
      const escapedLatex = latex.replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      const mathSpan = `<span class="math-inline" data-latex="${escapedLatex}"></span>`;
      const placeholder = `\u200B\u200BINLINEMATH${index}\u200B\u200B`;
      
      // Count occurrences before replacement
      const beforeCount = (html.match(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
      
      // Direct string replacement (most reliable)
      html = html.split(placeholder).join(mathSpan);
      
      // Also try with HTML-escaped zero-width spaces
      const escapedPlaceholder = placeholder.replace(/\u200B/g, '&#8203;');
      html = html.split(escapedPlaceholder).join(mathSpan);
      
      if (beforeCount > 0) {
        console.log(`Replaced ${beforeCount} occurrence(s) of INLINEMATH${index}`);
      }
    });
    
    // Fix any escaped HTML entities
    html = html.replace(/&lt;span class="math-inline" data-latex="([^"]+)"&gt;&lt;\/span&gt;/g, 
      '<span class="math-inline" data-latex="$1"></span>');
    
    html = html.replace(/&lt;span class='math-inline' data-latex='([^']+)'&gt;&lt;\/span&gt;/g, 
      '<span class="math-inline" data-latex="$1"></span>');
    
    html = html.replace(/&lt;div class="math-display" data-latex="([^"]+)"&gt;&lt;\/div&gt;/g,
      '<div class="math-display" data-latex="$1"></div>');
    
    // Check if placeholders still exist (for debugging)
    const remainingDisplay = (html.match(/\u200B\u200BDISPLAYMATH\d+\u200B\u200B/g) || []).length;
    const remainingInline = (html.match(/\u200B\u200BINLINEMATH\d+\u200B\u200B/g) || []).length;
    const finalMathInline = (html.match(/<span class="math-inline"/g) || []).length;
    const finalMathDisplay = (html.match(/<div class="math-display"/g) || []).length;
    
    console.log('After restoration:', finalMathDisplay, 'display math elements,', finalMathInline, 'inline math elements');
    if (remainingDisplay > 0 || remainingInline > 0) {
      console.warn('WARNING: Still have unreplaced placeholders:', remainingDisplay, 'display,', remainingInline, 'inline');
    }
    
    return html;
  }
  
  // Process LaTeX in HTML string (after markdown parsing)
  function processLatexInHTMLString(html) {
    if (!html) return html;
    
    // First, unescape any HTML-escaped dollar signs (marked.js might escape them)
    html = html.replace(/&#36;/g, '$');
    html = html.replace(/&dollar;/g, '$');
    
    // Step 1: Process display math blocks first ($$...$$)
    // Replace with temporary markers
    const displayMathBlocks = [];
    html = html.replace(/\$\$([\s\S]*?)\$\$/g, (match, latex) => {
      const cleanLatex = sanitizeLatex((latex || '').trim());
      const escapedLatex = cleanLatex.replace(/"/g, '&quot;');
      const placeholder = `__DISPLAY_MATH_${displayMathBlocks.length}__`;
      displayMathBlocks.push(`<div class="math-display" data-latex="${escapedLatex}"></div>`);
      return placeholder;
    });
    
    // Step 2: Process inline math ($...$) - simple match, display math already replaced
    const inlineMathBlocks = [];
    html = html.replace(/\$([^$\n]+?)\$/g, (match, latex) => {
      const cleanLatex = sanitizeLatex((latex || '').trim());
      const escapedLatex = cleanLatex.replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      const placeholder = `__INLINE_MATH_${inlineMathBlocks.length}__`;
      inlineMathBlocks.push(`<span class="math-inline" data-latex="${escapedLatex}"></span>`);
      return placeholder;
    });
    
    // Step 3: Restore display math
    displayMathBlocks.forEach((block, index) => {
      html = html.split(`__DISPLAY_MATH_${index}__`).join(block);
    });
    
    // Step 4: Restore inline math
    inlineMathBlocks.forEach((block, index) => {
      html = html.split(`__INLINE_MATH_${index}__`).join(block);
    });
    
    // Step 5: Fix any escaped HTML entities (marked.js might escape our spans)
    html = html.replace(/&lt;span class="math-inline" data-latex="([^"]+)"&gt;&lt;\/span&gt;/g, 
      '<span class="math-inline" data-latex="$1"></span>');
    
    html = html.replace(/&lt;span class='math-inline' data-latex='([^']+)'&gt;&lt;\/span&gt;/g, 
      '<span class="math-inline" data-latex="$1"></span>');
    
    html = html.replace(/&lt;div class="math-display" data-latex="([^"]+)"&gt;&lt;\/div&gt;/g,
      '<div class="math-display" data-latex="$1"></div>');
    
    return html;
  }
  
  // Simple markdown renderer - returns {html, displayMathBlocks, inlineMathBlocks}
  function renderMarkdown(text) {
    if (!text) return {html: '', displayMathBlocks: [], inlineMathBlocks: []};
    
    // Normalize newlines
    let processed = String(text).replace(/\r\n?|\u2028|\u2029/g, '\n');
    
    // Fix tabs in list items
    processed = processed.split('\n').map(line => {
      if (/^(\s*[-*+]|\s*\d+\.)\s*\t/.test(line)) {
        return line.replace(/\t/g, '    ');
      }
      return line;
    }).join('\n');

    // Count LaTeX before processing (simple count, not exact)
    const displayMathCount = (processed.match(/\$\$[\s\S]*?\$\$/g) || []).length;
    // Count inline math by counting $ signs that aren't part of $$
    let inlineMathCount = 0;
    const tempProcessed = processed.replace(/\$\$[\s\S]*?\$\$/g, ''); // Remove display math first
    inlineMathCount = (tempProcessed.match(/\$[^$\n]+?\$/g) || []).length;
    console.log('Found LaTeX in markdown:', displayMathCount, 'display,', inlineMathCount, 'inline');

    // Parse markdown to HTML FIRST
    let html;
    try {
      if (window.marked) {
        window.marked.setOptions({
          gfm: true,
          breaks: true,
          headerIds: false,
          mangle: false
        });
        html = window.marked.parse(processed);
      } else {
        html = processed;
      }
    } catch (e) {
      console.warn('Marked parse failed:', e);
      html = processed;
    }

    // Process LaTeX in the HTML string AFTER markdown parsing
    html = processLatexInHTMLString(html);
    
    // Count math elements created
    const mathInlineCount = (html.match(/<span class="math-inline"/g) || []).length;
    const mathDisplayCount = (html.match(/<div class="math-display"/g) || []).length;
    console.log('Created math elements:', mathDisplayCount, 'display,', mathInlineCount, 'inline');
    
    return {html, displayMathBlocks: [], inlineMathBlocks: []};
  }
  
  // Process any remaining placeholders in the DOM (fallback)
  function processRemainingPlaceholders(container, displayMathBlocks, inlineMathBlocks) {
    if (!container || !displayMathBlocks || !inlineMathBlocks) return;
    
    // Find and replace any remaining placeholders
    const walker = document.createTreeWalker(
      container,
      NodeFilter.SHOW_TEXT,
      null
    );
    
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
      const text = node.textContent;
      if (text.includes('DISPLAYMATH') || text.includes('INLINEMATH') || 
          text.includes('__DISPLAY_MATH_') || text.includes('__INLINE_MATH_')) {
        textNodes.push(node);
      }
    }
    
    if (textNodes.length > 0) {
      console.log('Found', textNodes.length, 'text nodes with placeholders, processing...');
    }
    
    textNodes.forEach(textNode => {
      let text = textNode.textContent;
      const parent = textNode.parentElement;
      if (!parent) return;
      
      // Process display math placeholders
      displayMathBlocks.forEach((latex, index) => {
        const oldPlaceholder = `__DISPLAY_MATH_${index}__`;
        const newPlaceholder = `\u200B\u200BDISPLAYMATH${index}\u200B\u200B`;
        const escapedLatex = latex.replace(/"/g, '&quot;');
        const mathDiv = `<div class="math-display" data-latex="${escapedLatex}"></div>`;
        
        if (text.includes(oldPlaceholder)) {
          text = text.split(oldPlaceholder).join(mathDiv);
        }
        if (text.includes(newPlaceholder)) {
          text = text.split(newPlaceholder).join(mathDiv);
        }
      });
      
      // Process inline math placeholders
      inlineMathBlocks.forEach((latex, index) => {
        const oldPlaceholder = `__INLINE_MATH_${index}__`;
        const newPlaceholder = `\u200B\u200BINLINEMATH${index}\u200B\u200B`;
        const escapedLatex = latex.replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        const mathSpan = `<span class="math-inline" data-latex="${escapedLatex}"></span>`;
        
        if (text.includes(oldPlaceholder)) {
          text = text.split(oldPlaceholder).join(mathSpan);
        }
        if (text.includes(newPlaceholder)) {
          text = text.split(newPlaceholder).join(mathSpan);
        }
      });
      
      // If text changed, replace the node
      if (text !== textNode.textContent) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = text;
        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
          fragment.appendChild(tempDiv.firstChild);
        }
        parent.replaceChild(fragment, textNode);
      }
    });
  }
  
  // Process LaTeX in the DOM (fallback for any missed cases)
  function processLatexInDOM(container) {
    if (!container) return;
    
    // Only process text nodes that still contain $ signs
    const walker = document.createTreeWalker(
      container,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: function(node) {
          const parent = node.parentElement;
          // Skip code blocks, scripts, styles, and existing math elements
          if (parent && (
            parent.tagName === 'SCRIPT' || 
            parent.tagName === 'STYLE' || 
            parent.tagName === 'CODE' || 
            parent.tagName === 'PRE' ||
            parent.classList.contains('math-inline') ||
            parent.classList.contains('math-display') ||
            parent.classList.contains('katex')
          )) {
            return NodeFilter.FILTER_REJECT;
          }
          // Only process nodes with $ signs
          if (!node.textContent || !node.textContent.includes('$')) {
            return NodeFilter.FILTER_REJECT;
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      }
    );
    
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
      textNodes.push(node);
    }
    
    if (textNodes.length > 0) {
      console.log('Processing', textNodes.length, 'remaining text nodes with LaTeX');
    }
    
    // Process each text node
    textNodes.forEach(textNode => {
      const text = textNode.textContent;
      const parent = textNode.parentElement;
      if (!parent) return;
      
      // Process display math first
      const displayMathRegex = /\$\$([\s\S]*?)\$\$/g;
      if (displayMathRegex.test(text)) {
        displayMathRegex.lastIndex = 0;
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        let match;
        
        while ((match = displayMathRegex.exec(text)) !== null) {
          if (match.index > lastIndex) {
            fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
          }
          
          const div = document.createElement('div');
          div.className = 'math-display';
          div.setAttribute('data-latex', sanitizeLatex(match[1].trim()));
          fragment.appendChild(div);
          
          lastIndex = match.index + match[0].length;
        }
        
        if (lastIndex < text.length) {
          fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
        }
        
        parent.replaceChild(fragment, textNode);
        return;
      }
      
      // Process inline math
      const inlineMathRegex = /(?<!\$)\$([^$\n]+?)\$(?!\$)/g;
      if (inlineMathRegex.test(text)) {
        inlineMathRegex.lastIndex = 0;
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        let match;
        
        while ((match = inlineMathRegex.exec(text)) !== null) {
          if (match.index > lastIndex) {
            fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
          }
          
          const span = document.createElement('span');
          span.className = 'math-inline';
          span.setAttribute('data-latex', sanitizeLatex(match[1].trim()));
          fragment.appendChild(span);
          
          lastIndex = match.index + match[0].length;
        }
        
        if (lastIndex < text.length) {
          fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
        }
        
        parent.replaceChild(fragment, textNode);
      }
    });
  }

  // Base path for images placed in public/uploads
  const imageBasePath = `/uploads/courses/${courseId}/chapters/${chapterId}/`;

  // Rewrite relative <img src> to point to our uploads base
  function rewriteImageSrcs(html) {
    return html.replace(/<img([^>]+)src=["']([^"']+)["']([^>]*)>/g, (match, pre, src, post) => {
      const isAbsolute = /^(?:[a-z]+:)?\/\//i.test(src) || src.startsWith('/') || src.startsWith('data:');
      const normalized = isAbsolute ? src : imageBasePath + src.replace(/^\.?\//, '');
      return `<img${pre}src="${normalized}"${post}>`;
    });
  }
  
  // Load KaTeX CSS/JS once and cache the promise
  let katexLoadPromise;
  function loadKatexAssets() {
    // If already loaded, return immediately
    if (window.katex && typeof window.katex.render === 'function') {
      return Promise.resolve();
    }
    
    if (katexLoadPromise) return katexLoadPromise;
    
    katexLoadPromise = new Promise((resolve, reject) => {
      // CSS - ensure it's loaded
      if (!document.getElementById('katex-css')) {
        const link = document.createElement('link');
        link.id = 'katex-css';
        link.rel = 'stylesheet';
        link.href = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css';
        document.head.appendChild(link);
      }
      
      // Check if script already exists (preloaded in head)
      const existingScript = document.getElementById('katex-js');
      
      // Function to wait for KaTeX to become available
      const waitForKaTeX = (maxAttempts = 100) => {
        let attempts = 0;
        const checkInterval = setInterval(() => {
          attempts++;
          if (window.katex && typeof window.katex.render === 'function') {
            clearInterval(checkInterval);
            console.log('KaTeX is now available');
            resolve();
          } else if (attempts >= maxAttempts) {
            clearInterval(checkInterval);
            console.error('KaTeX not available after', maxAttempts * 100, 'ms');
            console.error('window.katex:', window.katex);
            console.error('Script element:', existingScript);
            console.error('Script complete:', existingScript?.complete);
            reject(new Error('KaTeX failed to load - window.katex not available'));
          }
        }, 100);
      };
      
      if (existingScript) {
        // Script exists, wait for it to load
        if (existingScript.complete) {
          // Script already loaded, wait for KaTeX to initialize
          waitForKaTeX();
        } else {
          // Script is still loading
          existingScript.onload = () => {
            waitForKaTeX();
          };
          existingScript.onerror = (e) => {
            console.error('KaTeX script failed to load:', e);
            reject(new Error('Failed to load KaTeX script'));
          };
        }
      } else {
        // Load the script
        const script = document.createElement('script');
        script.id = 'katex-js';
        script.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';
        script.async = true;
        
        script.onload = () => {
          console.log('KaTeX script loaded, waiting for initialization...');
          waitForKaTeX();
        };
        
        script.onerror = (e) => {
          console.error('Failed to load KaTeX script:', e);
          reject(new Error('Failed to load KaTeX script from CDN'));
        };
        
        document.head.appendChild(script);
      }
    });
    
    return katexLoadPromise;
  }

  // Load Highlight.js CSS/JS for code syntax highlighting
  let hljsLoadPromise;
  function loadHighlightAssets() {
    if (hljsLoadPromise) return hljsLoadPromise;
    hljsLoadPromise = new Promise((resolve, reject) => {
      // CSS
      if (!document.getElementById('hljs-css')) {
        const link = document.createElement('link');
        link.id = 'hljs-css';
        link.rel = 'stylesheet';
        link.href = 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github-dark.min.css';
        document.head.appendChild(link);
      }
      // JS
      if (window.hljs) {
        resolve();
        return;
      }
      const script = document.createElement('script');
      script.id = 'hljs-js';
      script.src = 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js';
      script.defer = true;
      script.onload = () => resolve();
      script.onerror = (e) => reject(e);
      document.head.appendChild(script);
    });
    return hljsLoadPromise;
  }

  // Sanitize LaTeX content to remove problematic Unicode characters
  function sanitizeLatex(latex) {
    if (!latex) return '';
    return latex
      // Remove zero-width spaces (8203)
      .replace(/\u200B/g, '')
      // Remove thin spaces (8201, 202F) - replace with regular space
      .replace(/[\u2009\u202F\u200A]/g, ' ')
      // Remove non-breaking spaces (160) - replace with regular space  
      .replace(/\u00A0/g, ' ')
      // Remove combining marks (arrows, accents, etc.) (8400-842F range, including 8407)
      .replace(/[\u0300-\u036F\u20D0-\u20FF]/g, '')
      // Normalize line endings
      .replace(/\r\n?|\u2028|\u2029/g, '\n')
      // Clean up multiple spaces (but preserve intentional spacing in math)
      .replace(/[ \t]+/g, ' ')
      .trim();
  }

  // Enhanced LaTeX renderer for better math display (KaTeX) - DEPRECATED, use renderLatexWithKaTeX instead
  async function renderLatexPreview() {
    return renderLatexWithKaTeX();
  }
  
  // Basic LaTeX renderer for common math symbols
  function renderBasicLatex(latex) {
    return latex
      // Fractions
      .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '<span class="frac"><span class="numerator">$1</span><span class="denominator">$2</span></span>')
      // Superscripts
      .replace(/\^(\d+)/g, '<sup>$1</sup>')
      .replace(/\^\{([^}]+)\}/g, '<sup>$1</sup>')
      // Subscripts
      .replace(/_(\d+)/g, '<sub>$1</sub>')
      .replace(/_\{([^}]+)\}/g, '<sub>$1</sub>')
      // Greek letters
      .replace(/\\alpha/g, 'Œ±')
      .replace(/\\beta/g, 'Œ≤')
      .replace(/\\gamma/g, 'Œ≥')
      .replace(/\\delta/g, 'Œ¥')
      .replace(/\\epsilon/g, 'Œµ')
      .replace(/\\theta/g, 'Œ∏')
      .replace(/\\lambda/g, 'Œª')
      .replace(/\\mu/g, 'Œº')
      .replace(/\\pi/g, 'œÄ')
      .replace(/\\sigma/g, 'œÉ')
      .replace(/\\tau/g, 'œÑ')
      .replace(/\\phi/g, 'œÜ')
      .replace(/\\omega/g, 'œâ')
      // Math symbols
      .replace(/\\infty/g, '‚àû')
      .replace(/\\sum/g, '‚àë')
      .replace(/\\int/g, '‚à´')
      .replace(/\\sqrt/g, '‚àö')
      .replace(/\\pm/g, '¬±')
      .replace(/\\times/g, '√ó')
      .replace(/\\div/g, '√∑')
      .replace(/\\leq/g, '‚â§')
      .replace(/\\geq/g, '‚â•')
      .replace(/\\neq/g, '‚â†')
      .replace(/\\approx/g, '‚âà')
      .replace(/\\rightarrow/g, '‚Üí')
      .replace(/\\leftarrow/g, '‚Üê')
      .replace(/\\leftrightarrow/g, '‚Üî')
      // Parentheses
      .replace(/\\left\(/g, '(')
      .replace(/\\right\)/g, ')')
      .replace(/\\left\[/g, '[')
      .replace(/\\right\]/g, ']')
      .replace(/\\left\{/g, '{')
      .replace(/\\right\}/g, '}');
  }
  
  // Update preview function - clean and simple
  async function updatePreview() {
    const content = monacoEditor ? monacoEditor.getValue() : (document.getElementById('content')?.value || '');
    const previewDiv = document.getElementById('preview-content');
    
    if (!previewDiv) return;
    
    if (!content || content.trim() === '') {
      previewDiv.innerHTML = '<p class="text-slate-400 italic text-sm">Mulai mengetik untuk melihat pratinjau konten Anda...</p>';
      return;
    }
    
    try {
      // Load libraries
      await loadMarkedAssets();
      await loadHighlightAssets();
      await loadKatexAssets();
      
      // Render markdown (LaTeX is processed inside renderMarkdown)
      const renderResult = renderMarkdown(content);
      let html = renderResult.html;
      html = rewriteImageSrcs(html);
      
      // Debug: Check math elements in HTML
      const mathInlineCount = (html.match(/<span class="math-inline"/g) || []).length;
      const mathDisplayCount = (html.match(/<div class="math-display"/g) || []).length;
      console.log('Math elements in HTML:', mathInlineCount, 'inline,', mathDisplayCount, 'display');
      
      // Insert HTML
      previewDiv.innerHTML = html;
      
      // Fallback: Process any remaining placeholders or LaTeX in DOM
      processRemainingPlaceholders(previewDiv, renderResult.displayMathBlocks, renderResult.inlineMathBlocks);
      processLatexInDOM(previewDiv);
      
      // Render math with KaTeX
      await renderLatexWithKaTeX();
      
      // Highlight code
      const codeBlocks = previewDiv.querySelectorAll('pre code');
      if (codeBlocks.length > 0 && window.hljs) {
        codeBlocks.forEach(block => window.hljs.highlightElement(block));
      }
      
      // Final check
      const finalMathInline = previewDiv.querySelectorAll('.math-inline');
      const finalMathDisplay = previewDiv.querySelectorAll('.math-display');
      console.log('Final math elements:', finalMathInline.length, 'inline,', finalMathDisplay.length, 'display');
    } catch (error) {
      console.error('Preview error:', error);
      previewDiv.innerHTML = `<p class="text-red-600">Error: ${error.message}</p>`;
    }
  }
  
  // Render LaTeX with KaTeX
  async function renderLatexWithKaTeX() {
    const previewDiv = document.getElementById('preview-content');
    if (!previewDiv) return;
    
    try {
      await loadKatexAssets();
      
      // Additional wait and check
      let retries = 0;
      const maxRetries = 20;
      while (retries < maxRetries) {
        if (window.katex && typeof window.katex.render === 'function') {
          break;
        }
        await new Promise(resolve => setTimeout(resolve, 100));
        retries++;
      }
      
      if (!window.katex || typeof window.katex.render !== 'function') {
        console.error('KaTeX not available after loading.');
        console.error('window.katex:', window.katex);
        console.error('typeof window.katex:', typeof window.katex);
        console.error('window.katex?.render:', window.katex?.render);
        
        // Check if script tag exists
        const scriptTag = document.getElementById('katex-js');
        console.error('KaTeX script tag:', scriptTag);
        console.error('Script src:', scriptTag?.src);
        console.error('Script loaded:', scriptTag?.complete);
        
        // Try direct injection as fallback
        console.log('Attempting direct KaTeX injection...');
        const directScript = document.createElement('script');
        directScript.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';
        directScript.async = false;
        await new Promise((resolve, reject) => {
          directScript.onload = () => {
            setTimeout(() => {
              if (window.katex && typeof window.katex.render === 'function') {
                console.log('KaTeX loaded via direct injection');
                resolve();
              } else {
                reject(new Error('Direct injection failed'));
              }
            }, 500);
          };
          directScript.onerror = reject;
          document.head.appendChild(directScript);
        });
      }
      
      if (!window.katex || typeof window.katex.render !== 'function') {
        throw new Error('KaTeX is not available. Please check browser console for details.');
      }
      
      console.log('KaTeX is available, rendering math...');
      
      const mathElements = previewDiv.querySelectorAll('.math-display, .math-inline');
      console.log('Rendering', mathElements.length, 'math elements with KaTeX');
      
      mathElements.forEach((element, index) => {
        const latexRaw = element.getAttribute('data-latex') || '';
        if (!latexRaw) {
          console.warn(`Math element ${index} has no data-latex attribute`);
          return;
        }
        
        const sanitizedLatex = sanitizeLatex(latexRaw);
        const latex = sanitizedLatex.replace(/\\rm\s*/g, '\\mathrm ');
        const displayMode = element.classList.contains('math-display');
        
        try {
          element.innerHTML = '';
          window.katex.render(latex, element, {
            displayMode,
            throwOnError: false,
            trust: true,
            strict: false,
            macros: {
              '\\degree': '^{\\circ}'
            }
          });
        } catch (err) {
          console.warn(`KaTeX render error for element ${index}:`, err);
          element.innerHTML = `<span class="text-red-600">$${latex}$</span>`;
        }
      });
      
      // Highlight code blocks
      const codeBlocks = previewDiv.querySelectorAll('pre code');
      if (codeBlocks.length > 0 && window.hljs) {
        codeBlocks.forEach((block) => {
          window.hljs.highlightElement(block);
        });
      }
    } catch (error) {
      console.error('KaTeX rendering error:', error);
    }
  }

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', async function() {
    // Initialize Monaco Editor
    await initMonacoEditor();
    
    // Update size on load
    updateContentSize();
    
    // Initial preview update
    await updatePreview();
    
    // Preview button functionality
    const previewBtn = document.getElementById('preview-btn');
    if (previewBtn) {
      previewBtn.addEventListener('click', async function() {
        await updatePreview();
      });
    }
    
    // Initialize block insertion
    setupBlockInsertion();

    // Form submission with large file handling
    const form = document.getElementById('chapter-form');
    if (form) {
      form.addEventListener('submit', async function(e) {
        e.preventDefault();
        
        const formData = new FormData(form);
        const content = formData.get('content');
        
        // Check content size and warn if large
        const contentSize = new Blob([content]).size;
        const sizeMB = (contentSize / 1024 / 1024).toFixed(2);
        
        if (contentSize > 5 * 1024 * 1024) { // > 5MB
          if (!confirm(`This chapter is ${sizeMB}MB. Large files may take longer to save and load. Continue?`)) {
            return;
          }
        }
        
        const chapterData = {
          title: formData.get('title'),
          order: parseInt(formData.get('order')),
          content: content
        };
        
        // Show loading indicator
        const submitBtn = form.querySelector('button[type="submit"]');
        const originalText = submitBtn.textContent;
        submitBtn.textContent = 'Saving...';
        submitBtn.disabled = true;
        
        try {
          console.log('Sending chapter data:', chapterData);
          
          const response = await fetch(`/api/admin/chapters/${chapterId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(chapterData)
          });
          
          console.log('Response status:', response.status);
          console.log('Response headers:', response.headers);
          
          if (response.ok) {
            const result = await response.json();
            console.log('Success:', result);
            window.location.href = `/admin/courses/${courseId}/edit`;
          } else {
            const errorText = await response.text();
            console.error('Error response:', errorText);
            
            let errorMessage = 'Unknown error';
            try {
              const errorData = JSON.parse(errorText);
              errorMessage = errorData.error || errorData.message || errorText;
            } catch (e) {
              errorMessage = errorText || `HTTP ${response.status}: ${response.statusText}`;
            }
            
            alert(`Error updating chapter: ${errorMessage}`);
            submitBtn.textContent = originalText;
            submitBtn.disabled = false;
          }
        } catch (error) {
          console.error('Chapter update error:', error);
          if (error.message.includes('431') || error.message.includes('header')) {
            alert('Content is too large. Please reduce the file size or split into multiple chapters.');
          } else {
            alert(`Error updating chapter: ${error.message || 'Network error. Please try again.'}`);
          }
          submitBtn.textContent = originalText;
          submitBtn.disabled = false;
        }
      });
    }

    // Delete confirmation
    const deleteBtn = document.getElementById('delete-btn');
    if (deleteBtn) {
      deleteBtn.addEventListener('click', async function() {
        if (!confirm('Are you sure you want to delete this chapter? This action cannot be undone.')) {
          return;
        }

        try {
          const response = await fetch(`/api/admin/chapters/${chapterId}`, {
            method: 'DELETE'
          });
          
          if (response.ok) {
            window.location.href = `/admin/courses/${courseId}/edit`;
          } else {
            const error = await response.json();
            alert(`Error deleting chapter: ${error.error || 'Unknown error'}`);
          }
        } catch (error) {
          console.error('Chapter deletion error:', error);
          alert('Error deleting chapter. Please try again.');
        }
      });
    }
  });

</script>

<style>
  #content {
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 14px;
    line-height: 1.5;
  }

  .prose .math-display,
  .prose .math-inline {
    background-color: #f8fafc;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    padding: 8px 12px;
    margin: 8px 0;
    font-family: 'Times New Roman', 'Computer Modern', serif;
  }

  /* Table styles for GFM tables */
  .prose table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
  }
  .prose table th,
  .prose table td {
    border: 1px solid #e2e8f0;
    padding: 0.5rem 0.75rem;
    text-align: left;
  }
  .prose table thead th {
    background-color: #f1f5f9;
    font-weight: 600;
  }

  /* Images */
  .prose img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 0.5rem 0;
    border-radius: 4px;
  }
  
  .prose .math-display {
    display: block;
    text-align: center;
    margin: 16px 0;
    padding: 16px;
    font-size: 1.2em;
  }
  
  .prose .math-inline {
    display: inline;
    font-size: 1em;
    margin: 0 2px;
  }
  
  .math-content {
    position: relative;
  }
  
  .math-raw {
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.8em;
    color: #64748b;
    margin-bottom: 4px;
    opacity: 0.7;
  }
  
  .math-rendered {
    font-size: 1.1em;
    color: #1e293b;
    font-weight: 500;
  }
  
  .frac {
    display: inline-block;
    text-align: center;
    vertical-align: middle;
  }
  
  .frac .numerator {
    display: block;
    border-bottom: 1px solid #1e293b;
    padding-bottom: 2px;
    margin-bottom: 2px;
  }
  
  .frac .denominator {
    display: block;
    padding-top: 2px;
  }
  
  sup, sub {
    font-size: 0.8em;
    font-weight: bold;
  }
  
  sup {
    vertical-align: super;
  }
  
  sub {
    vertical-align: sub;
  }
  
  /* List styles for preview content */
  .prose ul {
    list-style-type: disc;
    padding-left: 1.5rem;
    margin: 1rem 0;
  }
  
  .prose ol {
    list-style-type: decimal;
    padding-left: 1.5rem;
    margin: 1rem 0;
  }
  
  .prose li {
    display: list-item;
    margin: 0.5rem 0;
  }
  
  .prose ul ul {
    list-style-type: circle;
  }
  
  .prose ol ol {
    list-style-type: lower-alpha;
  }
  
  .prose ol ol ol {
    list-style-type: lower-roman;
  }
</style>

