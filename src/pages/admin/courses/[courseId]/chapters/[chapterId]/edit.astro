---
export const prerender = false;

import Layout from '../../../../../../components/Layout.astro';
import Icon from '../../../../../../components/icons/Icon.astro';
import { prisma } from '../../../../../../lib/db';
import { requireAdmin } from '../../../../../../lib/auth-guard';

const user = await requireAdmin(Astro.cookies);
if (!user) {
  return Astro.redirect('/');
}

const { courseId, chapterId } = Astro.params;

if (!courseId || !chapterId) {
  return Astro.redirect('/admin/courses');
}

const chapter = await prisma.chapter.findUnique({
  where: { id: parseInt(chapterId) },
  include: {
    course: true
  }
});

if (!chapter || chapter.courseId !== parseInt(courseId)) {
  return Astro.redirect(`/admin/courses/${courseId}/edit`);
}

// Get all chapters for this course to show order options
const allChapters = await prisma.chapter.findMany({
  where: { courseId: parseInt(courseId) },
  orderBy: { order: 'asc' }
});
---

<Layout title={`Edit ${chapter.title}`}>
  <!-- Preload marked.js and KaTeX for faster preview rendering -->
  <script is:inline>
    // Preload marked.js
    if (!window.marked) {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js';
      script.async = true;
      document.head.appendChild(script);
    }
    
    // Preload KaTeX CSS
    if (!document.getElementById('katex-css')) {
      const link = document.createElement('link');
      link.id = 'katex-css';
      link.rel = 'stylesheet';
      link.href = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css';
      document.head.appendChild(link);
    }
    
    // Preload KaTeX JS
    if (!window.katex && !document.getElementById('katex-js')) {
      const script = document.createElement('script');
      script.id = 'katex-js';
      script.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';
      script.async = true;
      script.onload = () => {
        console.log('KaTeX preloaded in head');
      };
      document.head.appendChild(script);
    }
  </script>
  
  <!-- Apply widescreen mode immediately before render -->
  <script is:inline>
    (function() {
      if (localStorage.getItem('admin-widescreen-mode') === 'true') {
        document.documentElement.classList.add('system-widescreen-mode');
        if (document.body) {
          document.body.classList.add('system-widescreen-mode');
        } else {
          document.addEventListener('DOMContentLoaded', function() {
            document.body.classList.add('system-widescreen-mode');
          });
        }
      }
    })();
  </script>
  
  <div class="min-h-screen bg-slate-50">
    <!-- Header -->
    <div class="bg-white border-b border-slate-200 sticky top-0 z-20 shadow-sm">
      <div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex justify-between items-center h-16">
          <div class="flex items-center gap-4">
            <a href={`/admin/courses/${courseId}/edit`} id="header-back-link" class="text-slate-600 hover:text-slate-900 transition-colors">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
              </svg>
            </a>
            <div>
              <h1 class="text-xl font-bold text-slate-900">Edit Bab</h1>
              <p class="text-xs text-slate-500">Kursus: {chapter.course.title}</p>
            </div>
            <div id="header-unsaved-indicator" class="hidden items-center gap-2 px-3 py-1 bg-amber-50 border border-amber-200 rounded-lg text-amber-700 text-xs">
              <span class="w-1.5 h-1.5 bg-amber-500 rounded-full animate-pulse"></span>
              <span class="font-medium">Belum disimpan</span>
            </div>
          </div>
          <div class="flex items-center gap-3">
            <button
              id="system-widescreen-toggle"
              class="inline-flex items-center gap-1.5 px-3 py-2 text-sm font-medium text-gray-700 bg-gray-50 hover:bg-gray-100 border border-gray-200 rounded-lg transition-colors"
              title="Toggle widescreen mode (system-wide)"
            >
              <svg id="system-widescreen-icon-normal" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path>
              </svg>
              <svg id="system-widescreen-icon-wide" class="w-4 h-4 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17V7m0 10a2 2 0 01-2 2H5a2 2 0 01-2-2V7a2 2 0 012-2h2a2 2 0 012 2m0 10a2 2 0 002 2h2a2 2 0 002-2M9 7a2 2 0 012-2h2a2 2 0 012 2m0 10V7m0 10a2 2 0 002 2h2a2 2 0 002-2V7a2 2 0 00-2-2h-2a2 2 0 00-2 2"></path>
              </svg>
              <span class="hidden sm:inline">Widescreen</span>
            </button>
            <a href="/admin/tutorial" target="_blank" class="text-sm text-blue-600 hover:text-blue-700 font-medium flex items-center gap-1 px-2 py-1 hover:bg-blue-50 rounded transition-colors">
              <Icon name="book-stack" class="w-4 h-4" />
              <span>Tutorial Formatting</span>
            </a>
          </div>
        </div>
      </div>
    </div>

    <!-- Main Content: Split View -->
    <form id="chapter-form" class="h-[calc(100vh-4rem)] flex flex-col">
      <input type="hidden" name="chapterId" value={chapter.id} />
      
      <!-- Top Bar: Chapter Info -->
      <div class="bg-white border-b border-slate-200 px-4 sm:px-6 lg:px-8 py-3">
        <div class="flex flex-wrap items-center gap-4">
          <div class="flex-1 min-w-[200px]">
            <label for="title" class="block text-xs font-medium text-slate-700 mb-1">
              Judul Bab *
            </label>
            <input
              type="text"
              name="title"
              id="title"
              required
              value={chapter.title}
              class="w-full px-3 py-1.5 text-sm border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              placeholder="Bab 1: Pengenalan"
            />
          </div>
          <div class="w-32">
            <label for="order" class="block text-xs font-medium text-slate-700 mb-1">
              Urutan *
            </label>
            <select
              name="order"
              id="order"
              required
              class="w-full px-3 py-1.5 text-sm border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            >
              {Array.from({ length: allChapters.length + 5 }, (_, i) => i + 1).map((num) => (
                <option value={num} selected={num === chapter.order}>
                  {num}
                </option>
              ))}
            </select>
          </div>
          <div class="flex items-end gap-2">
            <p id="content-size" class="text-xs text-slate-500 mb-1">
              Ukuran: 0 KB
            </p>
          </div>
        </div>
      </div>

      <!-- Split View: Editor | Preview -->
      <div class="flex-1 flex overflow-hidden">
        <!-- Left: Editor -->
        <div class="flex-1 flex flex-col border-r border-slate-200 bg-white min-h-0">
          <div class="px-4 py-2 bg-slate-50 border-b border-slate-200 flex items-center justify-between flex-shrink-0">
            <div class="flex items-center gap-2">
              <svg class="w-4 h-4 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
              </svg>
              <span class="text-sm font-medium text-slate-700">Editor</span>
            </div>
            <div class="flex items-center gap-2">
              <a
                href="#tools-section"
                class="text-xs text-slate-600 hover:text-slate-900 font-medium px-2 py-1 hover:bg-slate-100 rounded transition-colors"
                title="Lihat Tools & Template"
              >
                Tools & Template ↓
              </a>
            </div>
          </div>
          <!-- Hidden textarea for form submission -->
          <textarea
            name="content"
            id="content"
            style="display: none;"
          >{chapter.content || ''}</textarea>
          <!-- Monaco Editor container -->
          <div id="monaco-editor-container" class="flex-1 min-h-0" style="min-height: 400px; height: 100%;"></div>
          <div class="px-4 py-2 bg-slate-50 border-t border-slate-200">
            <p class="text-xs text-slate-500">
              Mendukung Markdown & LaTeX. Gunakan <code class="bg-slate-200 px-1 rounded">$...$</code> untuk inline dan <code class="bg-slate-200 px-1 rounded">$$...$$</code> untuk display math.
            </p>
          </div>
        </div>

        <!-- Right: Preview -->
        <div class="flex-1 flex flex-col bg-white">
          <div class="px-4 py-2 bg-slate-50 border-b border-slate-200 flex items-center justify-between">
            <div class="flex items-center gap-2">
              <svg class="w-4 h-4 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
              </svg>
              <span class="text-sm font-medium text-slate-700">Pratinjau</span>
            </div>
            <button
              type="button"
              id="preview-btn"
              class="text-xs text-blue-600 hover:text-blue-700 font-medium px-2 py-1 hover:bg-blue-50 rounded transition-colors"
            >
              Segarkan
            </button>
          </div>
          <div id="preview-content" class="flex-1 overflow-y-auto p-6 prose prose-slate max-w-none">
            <p class="text-slate-400 italic text-sm">Mulai mengetik untuk melihat pratinjau konten Anda...</p>
          </div>
        </div>
      </div>

      <!-- Bottom Bar: Actions -->
      <div class="bg-white border-t border-slate-200 shadow-lg">
        <div class="px-4 sm:px-6 lg:px-8 py-4">
          <div class="flex items-center justify-between gap-4">
            <!-- Left: Delete & Unsaved Indicator -->
            <div class="flex items-center gap-4">
              <button
                type="button"
                id="delete-btn"
                class="inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-red-600 hover:text-red-700 hover:bg-red-50 rounded-lg transition-all border border-red-200 hover:border-red-300"
              >
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
                Hapus Bab
              </button>
              <div id="unsaved-indicator" class="hidden items-center gap-2 px-3 py-1.5 bg-amber-50 border border-amber-200 rounded-lg text-amber-700 text-sm">
                <span class="w-2 h-2 bg-amber-500 rounded-full animate-pulse"></span>
                <span class="font-medium">Perubahan belum disimpan</span>
              </div>
            </div>
            
            <!-- Right: Cancel & Save -->
            <div class="flex items-center gap-3">
              <a
                href={`/admin/courses/${courseId}/edit`}
                id="cancel-link"
                class="px-4 py-2 text-sm font-medium text-slate-700 hover:text-slate-900 hover:bg-slate-100 rounded-lg transition-all border border-slate-200 hover:border-slate-300"
              >
                Batal
              </a>
              <button
                type="submit"
                id="save-btn"
                class="inline-flex items-center gap-2 px-6 py-2 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-lg shadow-sm hover:shadow-md transition-all focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <svg id="save-icon" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                </svg>
                <span id="save-text">Simpan Perubahan</span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </form>

    <!-- Tools & Reference Section -->
    <div id="tools-section" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 space-y-6">
      <!-- Interactive Block Tools -->
      <div class="bg-gradient-to-br from-green-50 to-emerald-50 border border-green-200 rounded-xl p-6 shadow-sm">
        <div class="flex items-center justify-between mb-4">
          <div>
            <h3 class="text-lg font-semibold text-green-900 mb-1">Interactive Block Tools</h3>
            <p class="text-sm text-green-700">
              Sisipkan elemen interaktif (kuis, simulasi, dll.) pada posisi kursor
            </p>
          </div>
          <a
            href="/admin/tutorial"
            target="_blank"
            class="text-sm text-green-700 hover:text-green-800 font-medium flex items-center gap-1 underline decoration-green-300 hover:decoration-green-500 transition-colors"
          >
            Lihat Tutorial Lengkap
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
          </a>
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3">
          <button
            type="button"
            id="insert-quiz"
            class="group flex flex-col items-center p-4 bg-white hover:bg-green-100 rounded-lg border-2 border-green-200 hover:border-green-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Blok Kuis"
          >
            <div class="w-10 h-10 bg-green-100 group-hover:bg-green-200 rounded-lg flex items-center justify-center mb-2 transition-colors">
              <svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
              </svg>
            </div>
            <span class="text-sm font-medium text-green-800">Kuis</span>
          </button>

          <button
            type="button"
            id="insert-simulation"
            class="group flex flex-col items-center p-4 bg-white hover:bg-purple-100 rounded-lg border-2 border-purple-200 hover:border-purple-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Blok Simulasi"
          >
            <div class="w-10 h-10 bg-purple-100 group-hover:bg-purple-200 rounded-lg flex items-center justify-center mb-2 transition-colors">
              <svg class="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <span class="text-sm font-medium text-purple-800">Simulasi</span>
          </button>

          <button
            type="button"
            id="insert-code-editor"
            class="group flex flex-col items-center p-4 bg-white hover:bg-indigo-100 rounded-lg border-2 border-indigo-200 hover:border-indigo-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Editor Kode"
          >
            <div class="w-10 h-10 bg-indigo-100 group-hover:bg-indigo-200 rounded-lg flex items-center justify-center mb-2 transition-colors">
              <svg class="w-5 h-5 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
              </svg>
            </div>
            <span class="text-sm font-medium text-indigo-800">Editor Kode</span>
          </button>

          <button
            type="button"
            id="insert-diagram"
            class="group flex flex-col items-center p-4 bg-white hover:bg-cyan-100 rounded-lg border-2 border-cyan-200 hover:border-cyan-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Diagram Interaktif"
          >
            <div class="w-10 h-10 bg-cyan-100 group-hover:bg-cyan-200 rounded-lg flex items-center justify-center mb-2 transition-colors">
              <svg class="w-5 h-5 text-cyan-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17V7m0 10a2 2 0 01-2 2H5a2 2 0 01-2-2V7a2 2 0 012-2h2a2 2 0 012 2m0 10a2 2 0 002 2h2a2 2 0 002-2M9 7a2 2 0 012-2h2a2 2 0 012 2m0 10V7m0 10a2 2 0 002 2h2a2 2 0 002-2V7a2 2 0 00-2-2h-2a2 2 0 00-2 2" />
              </svg>
            </div>
            <span class="text-sm font-medium text-cyan-800">Diagram</span>
          </button>
        </div>
      </div>

      <!-- Content Templates -->
      <div class="bg-gradient-to-br from-blue-50 to-sky-50 border border-blue-200 rounded-xl p-6 shadow-sm">
        <div class="mb-4">
          <h3 class="text-lg font-semibold text-blue-900 mb-1">Template Konten</h3>
          <p class="text-sm text-blue-700">
            Sisipkan blok konten yang sudah distyling pada posisi kursor
          </p>
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
          <button
            type="button"
            id="insert-definition"
            class="group flex items-center p-4 bg-white hover:bg-blue-100 rounded-lg border-2 border-blue-200 hover:border-blue-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Blok Definisi"
          >
            <div class="w-10 h-10 bg-blue-100 group-hover:bg-blue-200 rounded-lg flex items-center justify-center mr-3 transition-colors">
              <Icon name="book-stack" class="w-5 h-5 text-blue-700" />
            </div>
            <span class="text-sm font-medium text-blue-800">Definisi</span>
          </button>

          <button
            type="button"
            id="insert-theorem"
            class="group flex items-center p-4 bg-white hover:bg-emerald-100 rounded-lg border-2 border-emerald-200 hover:border-emerald-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Blok Teorema"
          >
            <div class="w-10 h-10 bg-emerald-100 group-hover:bg-emerald-200 rounded-lg flex items-center justify-center mr-3 transition-colors">
              <span class="text-xl">⚡</span>
            </div>
            <span class="text-sm font-medium text-emerald-800">Teorema</span>
          </button>

          <button
            type="button"
            id="insert-example"
            class="group flex items-center p-4 bg-white hover:bg-amber-100 rounded-lg border-2 border-amber-200 hover:border-amber-300 transition-all shadow-sm hover:shadow-md"
            title="Sisipkan Blok Contoh"
          >
            <div class="w-10 h-10 bg-amber-100 group-hover:bg-amber-200 rounded-lg flex items-center justify-center mr-3 transition-colors">
              <Icon name="pencil" class="w-5 h-5 text-amber-700" />
            </div>
            <span class="text-sm font-medium text-amber-800">Contoh</span>
          </button>
        </div>
      </div>

      <!-- Quick Reference -->
      <div class="bg-gradient-to-br from-slate-50 to-gray-50 border border-slate-200 rounded-xl p-6 shadow-sm">
        <h3 class="text-lg font-semibold text-slate-900 mb-4">Referensi Cepat Markdown & LaTeX</h3>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div class="bg-white rounded-lg p-4 border border-slate-200">
            <h4 class="text-sm font-semibold text-slate-800 mb-3 flex items-center gap-2">
              <svg class="w-4 h-4 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" />
              </svg>
              Markdown
            </h4>
            <ul class="space-y-2 text-xs text-slate-700">
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">•</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">**tebal**</code> atau <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">__tebal__</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">•</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">*miring*</code> atau <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">_miring_</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">•</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800"># Heading 1</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">•</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">## Heading 2</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">•</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">[link](url)</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">•</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">![gambar](url)</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">•</span>
                <span><code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">`kode`</code> atau <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">```blok kode```</code></span>
              </li>
            </ul>
          </div>
          <div class="bg-white rounded-lg p-4 border border-slate-200">
            <h4 class="text-sm font-semibold text-slate-800 mb-3 flex items-center gap-2">
              <svg class="w-4 h-4 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 20l4-16m2 16l4-16M6 9h14M4 15h14" />
              </svg>
              LaTeX
            </h4>
            <ul class="space-y-2 text-xs text-slate-700">
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">•</span>
                <span>Inline: <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">$x^2 + y^2 = z^2$</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">•</span>
                <span>Display: <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">$$\int_0^1 x^2 dx$$</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">•</span>
                <span>Pecahan: <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">$\frac&#123;a&#125;&#123;b&#125;$</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">•</span>
                <span>Yunani: <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">$\alpha, \beta, \gamma$</code></span>
              </li>
              <li class="flex items-start gap-2">
                <span class="text-slate-400 mt-0.5">•</span>
                <span>Akar: <code class="bg-slate-100 px-1.5 py-0.5 rounded text-slate-800">$\sqrt&#123;x&#125;$</code></span>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</Layout>

<script define:vars={{ chapterId: chapter.id, courseId: parseInt(courseId), originalContent: chapter.content || '', originalTitle: chapter.title, originalOrder: chapter.order }}>
  // System-wide Widescreen mode toggle - Initialize immediately
  (function initSystemWidescreen() {
    // Load system-wide widescreen preference from localStorage
    const savedMode = localStorage.getItem('admin-widescreen-mode');
    const isSystemWidescreen = savedMode === 'true';
    
    // Apply immediately on page load
    if (isSystemWidescreen) {
      document.body.classList.add('system-widescreen-mode');
    }
    
    // Set up toggle after DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      const systemWidescreenToggle = document.getElementById('system-widescreen-toggle');
      const systemWidescreenIconNormal = document.getElementById('system-widescreen-icon-normal');
      const systemWidescreenIconWide = document.getElementById('system-widescreen-icon-wide');
      
      let currentMode = isSystemWidescreen;
      
      function updateSystemWidescreenMode() {
        if (currentMode) {
          document.body.classList.add('system-widescreen-mode');
          systemWidescreenIconNormal?.classList.add('hidden');
          systemWidescreenIconWide?.classList.remove('hidden');
        } else {
          document.body.classList.remove('system-widescreen-mode');
          systemWidescreenIconNormal?.classList.remove('hidden');
          systemWidescreenIconWide?.classList.add('hidden');
        }
      }
      
      systemWidescreenToggle?.addEventListener('click', () => {
        currentMode = !currentMode;
        localStorage.setItem('admin-widescreen-mode', String(currentMode));
        updateSystemWidescreenMode();
      });
      
      // Update icons on load
      updateSystemWidescreenMode();
    });
  })();

  // Track content size
  function updateContentSize() {
    const content = monacoEditor ? monacoEditor.getValue() : (document.getElementById('content')?.value || '');
    const size = new Blob([content]).size;
    const sizeDisplay = document.getElementById('content-size');

    if (!sizeDisplay) return;

    if (size < 1024) {
      sizeDisplay.textContent = `Size: ${size} bytes`;
      sizeDisplay.className = 'text-xs text-gray-400';
    } else if (size < 1024 * 1024) {
      sizeDisplay.textContent = `Size: ${(size / 1024).toFixed(1)} KB`;
      sizeDisplay.className = 'text-xs text-gray-400';
    } else if (size < 5 * 1024 * 1024) {
      sizeDisplay.textContent = `Size: ${(size / 1024 / 1024).toFixed(2)} MB`;
      sizeDisplay.className = 'text-xs text-yellow-600 font-medium';
    } else {
      sizeDisplay.textContent = `Size: ${(size / 1024 / 1024).toFixed(2)} MB (Large!)`;
      sizeDisplay.className = 'text-xs text-red-600 font-bold';
    }
  }

  // Generate unique block ID
  function generateBlockId() {
    return 'block-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  }

  // Monaco Editor instance
  let monacoEditor = null;

  // Load Monaco Editor from CDN
  async function loadMonacoEditor() {
    return new Promise((resolve, reject) => {
      if (window.monaco && window.monaco.editor) {
        resolve();
        return;
      }

      // Check if loader is already being loaded
      if (document.querySelector('script[src*="monaco-editor"]')) {
        // Wait for it to load
        const checkInterval = setInterval(() => {
          if (window.monaco && window.monaco.editor) {
            clearInterval(checkInterval);
            resolve();
          }
        }, 100);
        setTimeout(() => {
          clearInterval(checkInterval);
          if (!window.monaco || !window.monaco.editor) {
            reject(new Error('Monaco Editor failed to load'));
          }
        }, 10000);
        return;
      }

      // Load Monaco Editor using AMD loader approach
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.min.js';
      script.onload = () => {
        if (typeof require !== 'undefined') {
          require.config({ 
            paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' },
            'vs/nls': { availableLanguages: { '*': 'en' } }
          });
          require(['vs/editor/editor.main'], () => {
            console.log('Monaco Editor loaded successfully');
            resolve();
          }, (err) => {
            console.error('Monaco Editor load error:', err);
            reject(err);
          });
        } else {
          reject(new Error('require is not defined'));
        }
      };
      script.onerror = (err) => {
        console.error('Failed to load Monaco Editor script:', err);
        reject(err);
      };
      document.head.appendChild(script);
    });
  }

  // Initialize Monaco Editor
  async function initMonacoEditor() {
    try {
      const container = document.getElementById('monaco-editor-container');
      const hiddenTextarea = document.getElementById('content');
      
      if (!container || !hiddenTextarea) {
        console.error('Monaco Editor container or textarea not found');
        return;
      }

      // Ensure container has height - check multiple ways
      const computedStyle = window.getComputedStyle(container);
      const parentHeight = container.parentElement?.offsetHeight || 0;
      
      console.log('Container check:', {
        offsetHeight: container.offsetHeight,
        clientHeight: container.clientHeight,
        parentHeight: parentHeight,
        computedHeight: computedStyle.height
      });
      
      // Force a minimum height if container has no height
      if (container.offsetHeight === 0 && container.clientHeight === 0) {
        container.style.height = '500px';
        container.style.minHeight = '500px';
        console.log('Set container height to 500px');
      }

      console.log('Loading Monaco Editor...');
      await loadMonacoEditor();
      
      if (!window.monaco || !window.monaco.editor) {
        throw new Error('Monaco Editor not available after loading');
      }

      // Ensure container has proper dimensions before creating editor
      const containerHeight = container.offsetHeight || container.clientHeight || 500;
      if (containerHeight < 100) {
        container.style.height = '500px';
        container.style.minHeight = '500px';
        console.log('Container too small, set to 500px');
      }
      
      // Wait a bit for container to be fully rendered and layout to settle
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Final check before creating editor
      if (container.offsetHeight === 0 && container.clientHeight === 0) {
        console.warn('Container still has no height, forcing 500px');
        container.style.height = '500px';
        container.style.minHeight = '500px';
      }

      console.log('Creating Monaco Editor instance...');
      // Initialize Monaco Editor
      monacoEditor = window.monaco.editor.create(container, {
        value: hiddenTextarea.value || '',
        language: 'markdown',
        theme: 'vs',
        fontSize: 14,
        lineNumbers: 'on',
        roundedSelection: false,
        scrollBeyondLastLine: false,
        readOnly: false,
        minimap: { enabled: true },
        tabSize: 2,
        insertSpaces: true,
        wordWrap: 'on',
        automaticLayout: true,
        formatOnPaste: true,
        formatOnType: true,
        suggestOnTriggerCharacters: true,
        acceptSuggestionOnEnter: 'on',
        quickSuggestions: true,
        // Enable VSCode-like features
        codeLens: false,
        folding: true,
        bracketPairColorization: { enabled: true },
        // LaTeX support
        wordBasedSuggestions: 'allDocuments',
      });

      // Sync Monaco Editor content to hidden textarea and auto-update preview
      let previewUpdateTimeout;
      monacoEditor.onDidChangeModelContent(() => {
        const value = monacoEditor.getValue();
        hiddenTextarea.value = value;
        updateContentSize();
        
        // Debounce preview updates (update 500ms after user stops typing)
        clearTimeout(previewUpdateTimeout);
        previewUpdateTimeout = setTimeout(async () => {
          try {
            await updatePreview();
          } catch (error) {
            console.error('Error updating preview:', error);
          }
        }, 500);
      });

      // Update content size on initialization
      updateContentSize();

      console.log('Monaco Editor initialized successfully');
    } catch (error) {
      console.error('Failed to initialize Monaco Editor:', error);
      console.error('Error details:', error.stack);
      
      // Fallback to textarea if Monaco fails
      const container = document.getElementById('monaco-editor-container');
      const hiddenTextarea = document.getElementById('content');
      
      if (container && hiddenTextarea) {
        console.log('Setting up fallback textarea editor...');
        const contentValue = hiddenTextarea.value || '';
        container.innerHTML = `
          <textarea 
            id="content-fallback" 
            class="w-full h-full p-4 border-0 font-mono text-sm focus:outline-none" 
            style="resize: none; min-height: 400px;"
            placeholder="Mulai mengetik konten Anda di sini..."
          >${contentValue}</textarea>
        `;
        
        const fallback = document.getElementById('content-fallback');
        if (fallback) {
          // Sync to hidden textarea
          fallback.addEventListener('input', () => {
            hiddenTextarea.value = fallback.value;
            updateContentSize();
            // Update preview with debounce
            clearTimeout(window.previewTimeout);
            window.previewTimeout = setTimeout(() => {
              updatePreview().catch(err => console.error('Preview update error:', err));
            }, 500);
          });
          
          // Track changes for unsaved indicator
          fallback.addEventListener('input', checkForChanges);
          
          console.log('Fallback textarea editor ready');
        }
      } else {
        console.error('Container or textarea not found for fallback');
      }
    }
  }

  // Insert text at cursor position (works with Monaco Editor or textarea)
  function insertAtCursor(element, text) {
    if (monacoEditor) {
      // Monaco Editor
      const selection = monacoEditor.getSelection();
      const range = new monaco.Range(
        selection.startLineNumber,
        selection.startColumn,
        selection.endLineNumber,
        selection.endColumn
      );
      const op = { range, text };
      monacoEditor.executeEdits('insert-text', [op]);
      monacoEditor.focus();
    } else if (element && element.tagName === 'TEXTAREA') {
      // Fallback to textarea
      const start = element.selectionStart;
      const end = element.selectionEnd;
      const before = element.value.substring(0, start);
      const after = element.value.substring(end);

      element.value = before + text + after;
      element.selectionStart = element.selectionEnd = start + text.length;
      element.focus();
      updateContentSize();
    }
  }

  // Block insertion handlers
  function setupBlockInsertion() {
    // Interactive blocks
    document.getElementById('insert-quiz')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const blockId = generateBlockId();
        const marker = `\n\n<!-- BLOCK:quiz:${blockId} -->\n\n`;
        insertAtCursor(editor, marker);
        updatePreview();
      }
    });

    document.getElementById('insert-simulation')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const blockId = generateBlockId();
        const marker = `\n\n<!-- BLOCK:simulation:${blockId} -->\n\n`;
        insertAtCursor(editor, marker);
        updatePreview();
      }
    });

    document.getElementById('insert-code-editor')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const blockId = generateBlockId();
        const marker = `\n\n<!-- BLOCK:code-editor:${blockId} -->\n\n`;
        insertAtCursor(editor, marker);
        updatePreview();
      }
    });

    document.getElementById('insert-diagram')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const blockId = generateBlockId();
        const marker = `\n\n<!-- BLOCK:interactive-diagram:${blockId} -->\n\n`;
        insertAtCursor(editor, marker);
        updatePreview();
      }
    });

    // Content templates
    document.getElementById('insert-definition')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const template = `<div class="definition-block">
  <div class="definition-header">Definisi: [Judul Definisi]</div>
  <div class="definition-content">
    [Konten definisi di sini]
  </div>
</div>

`;
        insertAtCursor(editor, template);
        updatePreview();
      }
    });

    document.getElementById('insert-theorem')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const template = `<div class="theorem-block">
  <div class="theorem-header">⚡ Teorema: [Nama Teorema]</div>
  <div class="theorem-content">
    $$[persamaan matematika]$$
  </div>
</div>

`;
        insertAtCursor(editor, template);
        updatePreview();
      }
    });

    document.getElementById('insert-example')?.addEventListener('click', () => {
      const editor = monacoEditor || document.getElementById('content') || document.getElementById('content-fallback');
      if (editor) {
        const template = `<div class="example-block">
  <div class="example-header">Contoh [nomor]</div>
  <div class="example-problem">
    [Permasalahan atau soal]
  </div>
  <details>
    <summary>Lihat Solusi</summary>
    <div class="example-solution">
      [Solusi lengkap di sini]
    </div>
  </details>
</div>

`;
        insertAtCursor(editor, template);
        updatePreview();
      }
    });
  }
  
  // Load Marked (Markdown) from CDN once
  let markedLoadPromise;
  function loadMarkedAssets() {
    if (markedLoadPromise) return markedLoadPromise;
    markedLoadPromise = new Promise((resolve, reject) => {
      // Check if already loaded
      if (window.marked && typeof window.marked.parse === 'function') {
        try { 
          window.marked.setOptions({ 
            gfm: true, 
            breaks: true,
            headerIds: false,
            mangle: false
          }); 
        } catch (e) {
          console.warn('Error setting marked options:', e);
        }
        resolve();
        return;
      }
      
      // Check if script is already being loaded
      const existingScript = document.getElementById('marked-js');
      if (existingScript) {
        // Wait for it to load
        existingScript.onload = () => {
          if (window.marked && typeof window.marked.parse === 'function') {
            try {
              window.marked.setOptions({ 
                gfm: true, 
                breaks: true,
                headerIds: false,
                mangle: false
              });
            } catch (e) {
              console.warn('Error setting marked options:', e);
            }
            resolve();
          } else {
            reject(new Error('Marked.js loaded but not available'));
          }
        };
        existingScript.onerror = () => reject(new Error('Failed to load marked.js'));
        return;
      }
      
      // Create and load script
      const script = document.createElement('script');
      script.id = 'marked-js';
      script.src = 'https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js';
      script.onload = () => {
        // Wait a bit to ensure marked is available
        const checkMarked = () => {
          if (window.marked && typeof window.marked.parse === 'function') {
            try { 
              window.marked.setOptions({ 
                gfm: true, 
                breaks: true,
                headerIds: false,
                mangle: false
              }); 
            } catch (e) {
              console.warn('Error setting marked options:', e);
            }
            resolve();
          } else {
            // Retry after a short delay
            setTimeout(checkMarked, 50);
          }
        };
        checkMarked();
      };
      script.onerror = (e) => {
        console.error('Failed to load marked.js:', e);
        reject(new Error('Failed to load marked.js from CDN'));
      };
      document.head.appendChild(script);
    });
    return markedLoadPromise;
  }

  // Process LaTeX BEFORE markdown parsing (most reliable approach)
  function processLatexBeforeMarkdown(text) {
    if (!text) return text;
    
    // Step 1: Process display math blocks ($$...$$) FIRST
    const displayMathBlocks = [];
    text = text.replace(/\$\$([\s\S]*?)\$\$/g, (match, latex) => {
      const cleanLatex = sanitizeLatex((latex || '').trim());
      const placeholder = `__DISPLAY_MATH_${displayMathBlocks.length}__`;
      displayMathBlocks.push(cleanLatex);
      return placeholder;
    });
    
    // Step 2: Process inline math ($...$) - match single $...$ but not $$...$$
    const inlineMathBlocks = [];
    text = text.replace(/\$([^$\n]+?)\$/g, (match, latex) => {
      const cleanLatex = sanitizeLatex((latex || '').trim());
      const placeholder = `__INLINE_MATH_${inlineMathBlocks.length}__`;
      inlineMathBlocks.push(cleanLatex);
      return placeholder;
    });
    
    // Store blocks for later restoration
    text.__displayMathBlocks = displayMathBlocks;
    text.__inlineMathBlocks = inlineMathBlocks;
    
    return text;
  }
  
  // Restore LaTeX AFTER markdown parsing
  function restoreLatexAfterMarkdown(html, displayMathBlocks, inlineMathBlocks) {
    if (!html) return html;
    
    console.log('Restoring LaTeX:', displayMathBlocks.length, 'display,', inlineMathBlocks.length, 'inline');
    console.log('HTML before restoration (first 500 chars):', html.substring(0, 500));
    
    // Check what placeholders exist in HTML
    const displayPlaceholders = html.match(/\u200B\u200BDISPLAYMATH\d+\u200B\u200B/g) || [];
    const inlinePlaceholders = html.match(/\u200B\u200BINLINEMATH\d+\u200B\u200B/g) || [];
    console.log('Found placeholders in HTML:', displayPlaceholders.length, 'display,', inlinePlaceholders.length, 'inline');
    
    // Restore display math blocks
    displayMathBlocks.forEach((latex, index) => {
      const escapedLatex = latex.replace(/"/g, '&quot;');
      const mathDiv = `<div class="math-display" data-latex="${escapedLatex}"></div>`;
      const placeholder = `\u200B\u200BDISPLAYMATH${index}\u200B\u200B`;
      
      // Count occurrences before replacement
      const beforeCount = (html.match(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
      
      // Direct string replacement (most reliable)
      html = html.split(placeholder).join(mathDiv);
      
      // Also try with HTML-escaped zero-width spaces
      const escapedPlaceholder = placeholder.replace(/\u200B/g, '&#8203;');
      html = html.split(escapedPlaceholder).join(mathDiv);
      
      if (beforeCount > 0) {
        console.log(`Replaced ${beforeCount} occurrence(s) of DISPLAYMATH${index}`);
      }
    });
    
    // Restore inline math blocks
    inlineMathBlocks.forEach((latex, index) => {
      const escapedLatex = latex.replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      const mathSpan = `<span class="math-inline" data-latex="${escapedLatex}"></span>`;
      const placeholder = `\u200B\u200BINLINEMATH${index}\u200B\u200B`;
      
      // Count occurrences before replacement
      const beforeCount = (html.match(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
      
      // Direct string replacement (most reliable)
      html = html.split(placeholder).join(mathSpan);
      
      // Also try with HTML-escaped zero-width spaces
      const escapedPlaceholder = placeholder.replace(/\u200B/g, '&#8203;');
      html = html.split(escapedPlaceholder).join(mathSpan);
      
      if (beforeCount > 0) {
        console.log(`Replaced ${beforeCount} occurrence(s) of INLINEMATH${index}`);
      }
    });
    
    // Fix any escaped HTML entities
    html = html.replace(/&lt;span class="math-inline" data-latex="([^"]+)"&gt;&lt;\/span&gt;/g, 
      '<span class="math-inline" data-latex="$1"></span>');
    
    html = html.replace(/&lt;span class='math-inline' data-latex='([^']+)'&gt;&lt;\/span&gt;/g, 
      '<span class="math-inline" data-latex="$1"></span>');
    
    html = html.replace(/&lt;div class="math-display" data-latex="([^"]+)"&gt;&lt;\/div&gt;/g,
      '<div class="math-display" data-latex="$1"></div>');
    
    // Check if placeholders still exist (for debugging)
    const remainingDisplay = (html.match(/\u200B\u200BDISPLAYMATH\d+\u200B\u200B/g) || []).length;
    const remainingInline = (html.match(/\u200B\u200BINLINEMATH\d+\u200B\u200B/g) || []).length;
    const finalMathInline = (html.match(/<span class="math-inline"/g) || []).length;
    const finalMathDisplay = (html.match(/<div class="math-display"/g) || []).length;
    
    console.log('After restoration:', finalMathDisplay, 'display math elements,', finalMathInline, 'inline math elements');
    if (remainingDisplay > 0 || remainingInline > 0) {
      console.warn('WARNING: Still have unreplaced placeholders:', remainingDisplay, 'display,', remainingInline, 'inline');
    }
    
    return html;
  }
  
  // Process LaTeX in HTML string (after markdown parsing)
  function processLatexInHTMLString(html) {
    if (!html) return html;
    
    // First, unescape any HTML-escaped dollar signs (marked.js might escape them)
    html = html.replace(/&#36;/g, '$');
    html = html.replace(/&dollar;/g, '$');
    
    // Step 1: Process display math blocks first ($$...$$)
    // Replace with temporary markers
    const displayMathBlocks = [];
    html = html.replace(/\$\$([\s\S]*?)\$\$/g, (match, latex) => {
      const cleanLatex = sanitizeLatex((latex || '').trim());
      const escapedLatex = cleanLatex.replace(/"/g, '&quot;');
      const placeholder = `__DISPLAY_MATH_${displayMathBlocks.length}__`;
      displayMathBlocks.push(`<div class="math-display" data-latex="${escapedLatex}"></div>`);
      return placeholder;
    });
    
    // Step 2: Process inline math ($...$) - simple match, display math already replaced
    const inlineMathBlocks = [];
    html = html.replace(/\$([^$\n]+?)\$/g, (match, latex) => {
      const cleanLatex = sanitizeLatex((latex || '').trim());
      const escapedLatex = cleanLatex.replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      const placeholder = `__INLINE_MATH_${inlineMathBlocks.length}__`;
      inlineMathBlocks.push(`<span class="math-inline" data-latex="${escapedLatex}"></span>`);
      return placeholder;
    });
    
    // Step 3: Restore display math
    displayMathBlocks.forEach((block, index) => {
      html = html.split(`__DISPLAY_MATH_${index}__`).join(block);
    });
    
    // Step 4: Restore inline math
    inlineMathBlocks.forEach((block, index) => {
      html = html.split(`__INLINE_MATH_${index}__`).join(block);
    });
    
    // Step 5: Fix any escaped HTML entities (marked.js might escape our spans)
    html = html.replace(/&lt;span class="math-inline" data-latex="([^"]+)"&gt;&lt;\/span&gt;/g, 
      '<span class="math-inline" data-latex="$1"></span>');
    
    html = html.replace(/&lt;span class='math-inline' data-latex='([^']+)'&gt;&lt;\/span&gt;/g, 
      '<span class="math-inline" data-latex="$1"></span>');
    
    html = html.replace(/&lt;div class="math-display" data-latex="([^"]+)"&gt;&lt;\/div&gt;/g,
      '<div class="math-display" data-latex="$1"></div>');
    
    return html;
  }
  
  // Process markdown and LaTeX inside HTML block content
  function processHtmlBlockContent(content) {
    if (!content) return '';
    
    // Process display math blocks
    const displayMathBlocks = [];
    let processed = content.replace(/\$\$([\s\S]*?)\$\$/g, (match, latex) => {
      const cleanLatex = sanitizeLatex((latex || '').trim());
      const placeholder = `\u200B\u200BDISPLAYMATH${displayMathBlocks.length}\u200B\u200B`;
      displayMathBlocks.push(cleanLatex);
      return placeholder;
    });

    // Process inline math
    const inlineMathBlocks = [];
    processed = processed.replace(/(?<!\$)\$([^$\n]+?)\$(?!\$)/g, (match, latex) => {
      const cleanLatex = sanitizeLatex((latex || '').trim());
      const placeholder = `\u200B\u200BINLINEMATH${inlineMathBlocks.length}\u200B\u200B`;
      inlineMathBlocks.push(cleanLatex);
      return placeholder;
    });

    // Process markdown inside the HTML block
    let html;
    try {
      if (window.marked) {
        window.marked.setOptions({
          gfm: true,
          breaks: true,
          headerIds: false,
          mangle: false
        });
        html = window.marked.parse(processed);
      } else {
        html = processed;
      }
    } catch (e) {
      console.warn('Marked parse failed for HTML block:', e);
      html = processed;
    }

    // Restore display math
    displayMathBlocks.forEach((latex, index) => {
      const escapedLatex = latex.replace(/"/g, '&quot;');
      const mathDiv = `<div class="math-display" data-latex="${escapedLatex}"></div>`;
      const placeholder = `\u200B\u200BDISPLAYMATH${index}\u200B\u200B`;
      html = html.split(placeholder).join(mathDiv);
      const escapedPlaceholder = placeholder.replace(/\u200B/g, '&#8203;');
      html = html.split(escapedPlaceholder).join(mathDiv);
    });

    // Restore inline math
    inlineMathBlocks.forEach((latex, index) => {
      const escapedLatex = latex.replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      const mathSpan = `<span class="math-inline" data-latex="${escapedLatex}"></span>`;
      const placeholder = `\u200B\u200BINLINEMATH${index}\u200B\u200B`;
      html = html.split(placeholder).join(mathSpan);
      const escapedPlaceholder = placeholder.replace(/\u200B/g, '&#8203;');
      html = html.split(escapedPlaceholder).join(mathSpan);
    });

    return html;
  }

  // Escape HTML entities
  function escapeHtml(text) {
    if (!text) return '';
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return String(text).replace(/[&<>"']/g, m => map[m]);
  }

  // Simple markdown renderer - returns {html, displayMathBlocks, inlineMathBlocks}
  function renderMarkdown(text) {
    if (!text) return {html: '', displayMathBlocks: [], inlineMathBlocks: []};
    
    // Normalize newlines
    let processed = String(text).replace(/\r\n?|\u2028|\u2029/g, '\n');
    
    // Fix tabs in list items
    processed = processed.split('\n').map(line => {
      if (/^(\s*[-*+]|\s*\d+\.)\s*\t/.test(line)) {
        return line.replace(/\t/g, '    ');
      }
      return line;
    }).join('\n');

    // CRITICAL: Extract and process HTML blocks BEFORE markdown parsing
    // This prevents marked.js from treating content inside HTML blocks as code blocks
    // NOTE: Keep in sync with HTML_BLOCK_CLASSES in src/lib/markdown-blocks.ts
    const htmlBlocks = [];
    const htmlBlockClasses = ['definition-block', 'info-block', 'warning-block', 'tip-block', 'note-block', 'example-block', 'theorem-block'];
    const classPattern = htmlBlockClasses.join('|');
    
    // Match HTML blocks with nested divs - use a balanced match approach
    processed = processed.replace(new RegExp(`(<div\\s+class="(${classPattern})"[^>]*>)([\\s\\S]*?)(<\\/div>)`, 'gi'), (match, openTag, className, content, closeTag) => {
      // Check if this is actually the matching closing tag (simple check)
      // Count opening and closing divs in content
      const openDivs = (content.match(/<div/gi) || []).length;
      const closeDivs = (content.match(/<\/div>/gi) || []).length;
      
      // If content has balanced divs, this is likely the correct match
      // Otherwise, we'll process what we have (marked.js will handle the rest)
      if (openDivs === closeDivs || openDivs === 0) {
        // Process markdown and LaTeX inside the HTML block
        const processedContent = processHtmlBlockContent(content);
        const placeholder = `\u200B\u200BHTMLBLOCK${htmlBlocks.length}\u200B\u200B`;
        htmlBlocks.push(`${openTag}${processedContent}${closeTag}`);
        return placeholder;
      }
      
      // If divs aren't balanced, return original (let marked.js handle it)
      return match;
    });

    // Count LaTeX before processing (simple count, not exact)
    const displayMathCount = (processed.match(/\$\$[\s\S]*?\$\$/g) || []).length;
    // Count inline math by counting $ signs that aren't part of $$
    let inlineMathCount = 0;
    const tempProcessed = processed.replace(/\$\$[\s\S]*?\$\$/g, ''); // Remove display math first
    inlineMathCount = (tempProcessed.match(/\$[^$\n]+?\$/g) || []).length;
    console.log('Found LaTeX in markdown:', displayMathCount, 'display,', inlineMathCount, 'inline');

    // Process images with Pandoc-style attributes BEFORE markdown parsing
    // Pattern: ![](image.png){width=300px class=diagram align=center}
    processed = processed.replace(/!\[([^\]]*)\]\(([^)]+)\)\{([^}]+)\}/g, (match, alt, src, attrs) => {
      // Parse attributes (supports key=value pairs, quoted values)
      const attrObj = {};
      let current = '';
      let inQuotes = false;
      let quoteChar = '';
      
      for (let i = 0; i < attrs.length; i++) {
        const char = attrs[i];
        if ((char === '"' || char === "'") && !inQuotes) {
          inQuotes = true;
          quoteChar = char;
          current += char;
        } else if (char === quoteChar && inQuotes) {
          inQuotes = false;
          quoteChar = '';
          current += char;
        } else if (char === ' ' && !inQuotes) {
          if (current.trim()) {
            const [key, ...valueParts] = current.split('=');
            if (key && valueParts.length > 0) {
              let value = valueParts.join('=').trim();
              if ((value.startsWith('"') && value.endsWith('"')) ||
                  (value.startsWith("'") && value.endsWith("'"))) {
                value = value.slice(1, -1);
              }
              attrObj[key.toLowerCase().trim()] = value;
            }
            current = '';
          }
        } else {
          current += char;
        }
      }
      
      if (current.trim()) {
        const [key, ...valueParts] = current.split('=');
        if (key && valueParts.length > 0) {
          let value = valueParts.join('=').trim();
          if ((value.startsWith('"') && value.endsWith('"')) ||
              (value.startsWith("'") && value.endsWith("'"))) {
            value = value.slice(1, -1);
          }
          attrObj[key.toLowerCase().trim()] = value;
        }
      }
      
      // Build style
      const styles = [];
      if (attrObj.width) styles.push(`width: ${escapeHtml(attrObj.width)}`);
      if (attrObj.height) styles.push(`height: ${escapeHtml(attrObj.height)}`);
      if (attrObj.scale) {
        const scale = parseFloat(attrObj.scale);
        if (!isNaN(scale) && scale !== 1) {
          styles.push(`transform: scale(${scale})`);
        }
      }
      if (attrObj.align === 'left') styles.push('float: left; margin-right: 1rem');
      else if (attrObj.align === 'right') styles.push('float: right; margin-left: 1rem');
      else if (attrObj.align === 'center') styles.push('display: block; margin-left: auto; margin-right: auto');
      if (!styles.some(s => s.includes('max-width'))) styles.push('max-width: 100%');
      if (!attrObj.height && !styles.some(s => s.includes('height'))) styles.push('height: auto');
      if (attrObj.style) styles.push(attrObj.style);
      
      // Build img tag
      const parts = [`src="${escapeHtml(src)}"`];
      if (alt) parts.push(`alt="${escapeHtml(alt)}"`);
      if (styles.length > 0) parts.push(`style="${styles.join('; ')}"`);
      if (attrObj.class) parts.push(`class="${escapeHtml(attrObj.class)}"`);
      if (attrObj.id) parts.push(`id="${escapeHtml(attrObj.id)}"`);
      
      return `<img ${parts.join(' ')} />`;
    });

    // CRITICAL: Process display math blocks BEFORE markdown parsing
    // Replace $$...$$ with placeholders that won't be processed by marked.js

    const displayMathBlocks = [];
    processed = processed.replace(/\$\$([\s\S]*?)\$\$/g, (match, latex) => {
      const cleanLatex = sanitizeLatex((latex || '').trim());
      const placeholder = `\u200B\u200BDISPLAYMATH${displayMathBlocks.length}\u200B\u200B`;
      displayMathBlocks.push(cleanLatex);
      return placeholder;
    });

    // Also process inline math BEFORE markdown parsing to avoid conflicts
    const inlineMathBlocks = [];
    processed = processed.replace(/(?<!\$)\$([^$\n]+?)\$(?!\$)/g, (match, latex) => {
      const cleanLatex = sanitizeLatex((latex || '').trim());
      const placeholder = `\u200B\u200BINLINEMATH${inlineMathBlocks.length}\u200B\u200B`;
      inlineMathBlocks.push(cleanLatex);
      return placeholder;
    });

    // Parse markdown to HTML
    let html;
    try {
      if (window.marked) {
        window.marked.setOptions({
          gfm: true,
          breaks: true,
          headerIds: false,
          mangle: false
        });
        html = window.marked.parse(processed);
      } else {
        html = processed;
      }
    } catch (e) {
      console.warn('Marked parse failed:', e);
      html = processed;
    }

    // Restore HTML blocks AFTER markdown parsing
    htmlBlocks.forEach((blockHtml, index) => {
      const placeholder = `\u200B\u200BHTMLBLOCK${index}\u200B\u200B`;
      html = html.split(placeholder).join(blockHtml);
      const escapedPlaceholder = placeholder.replace(/\u200B/g, '&#8203;');
      html = html.split(escapedPlaceholder).join(blockHtml);
    });

    // Post-process: Find content divs inside HTML blocks and process their content
    // This handles cases where marked.js wrapped content in <pre><code> tags
    // Process definition-content, info-content, etc. divs specifically
    // NOTE: Keep in sync with CONTENT_DIV_CLASSES in src/lib/markdown-blocks.ts
    const contentDivClasses = ['definition-content', 'info-content', 'warning-content', 'tip-content', 'note-content', 'example-content', 'example-problem', 'example-solution', 'theorem-content'];
    const contentClassPattern = contentDivClasses.join('|');
    
    html = html.replace(new RegExp(`(<div\\s+class="(${contentClassPattern})"[^>]*>)([\\s\\S]*?)(<\\/div>)`, 'gi'), (match, openTag, className, content, closeTag) => {
      // Check if content is wrapped in code blocks or contains unprocessed LaTeX
      if (content.includes('<pre><code') || 
          (content.includes('$$') && !content.includes('math-display')) || 
          (content.includes('$') && !content.includes('math-inline') && !content.includes('math-display'))) {
        
        // Extract all content from <pre><code> blocks
        let processedContent = content;
        const codeBlockRegex = /<pre><code[^>]*>([\s\S]*?)<\/code><\/pre>/gi;
        let codeMatch;
        
        while ((codeMatch = codeBlockRegex.exec(content)) !== null) {
          const codeContent = codeMatch[1];
          // Decode HTML entities
          const decodedContent = codeContent
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&')
            .replace(/&quot;/g, '"')
            .replace(/&#039;/g, "'")
            .replace(/&nbsp;/g, ' ')
            .replace(/<span[^>]*>/g, '') // Remove highlight.js spans
            .replace(/<\/span>/g, '');
          
          // Process the decoded content
          const processed = processHtmlBlockContent(decodedContent);
          // Replace the code block with processed content
          processedContent = processedContent.replace(codeMatch[0], processed);
        }
        
        // If there are still code blocks or unprocessed LaTeX, process everything
        if (processedContent.includes('<pre><code') || 
            (processedContent.includes('$$') && !processedContent.includes('math-display')) ||
            (processedContent.includes('$') && !processedContent.includes('math-inline') && !processedContent.includes('math-display'))) {
          // Remove all code blocks and process the remaining content
          const cleanedContent = processedContent.replace(/<pre><code[^>]*>[\s\S]*?<\/code><\/pre>/gi, '');
          const finalProcessed = processHtmlBlockContent(cleanedContent);
          processedContent = finalProcessed;
        }
        
        return `${openTag}${processedContent}${closeTag}`;
      }
      return match;
    });

    // Restore display math blocks AFTER markdown parsing
    displayMathBlocks.forEach((latex, index) => {
      const escapedLatex = latex.replace(/"/g, '&quot;');
      const mathDiv = `<div class="math-display" data-latex="${escapedLatex}"></div>`;
      const placeholder = `\u200B\u200BDISPLAYMATH${index}\u200B\u200B`;
      html = html.split(placeholder).join(mathDiv);
      // Also try HTML-escaped version
      const escapedPlaceholder = placeholder.replace(/\u200B/g, '&#8203;');
      html = html.split(escapedPlaceholder).join(mathDiv);
    });

    // Restore inline math blocks AFTER markdown parsing
    inlineMathBlocks.forEach((latex, index) => {
      const escapedLatex = latex.replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      const mathSpan = `<span class="math-inline" data-latex="${escapedLatex}"></span>`;
      const placeholder = `\u200B\u200BINLINEMATH${index}\u200B\u200B`;
      html = html.split(placeholder).join(mathSpan);
      // Also try HTML-escaped version
      const escapedPlaceholder = placeholder.replace(/\u200B/g, '&#8203;');
      html = html.split(escapedPlaceholder).join(mathSpan);
    });

    // Fix any escaped HTML entities (marked.js might escape our divs/spans)
    html = html.replace(/&lt;div class="math-display" data-latex="([^"]+)"&gt;&lt;\/div&gt;/g,
      '<div class="math-display" data-latex="$1"></div>');
    html = html.replace(/&lt;span class="math-inline" data-latex="([^"]+)"&gt;&lt;\/span&gt;/g, 
      '<span class="math-inline" data-latex="$1"></span>');
    html = html.replace(/&lt;span class='math-inline' data-latex='([^']+)'&gt;&lt;\/span&gt;/g, 
      '<span class="math-inline" data-latex="$1"></span>');
    
    // Count math elements created
    const mathInlineCount = (html.match(/<span class="math-inline"/g) || []).length;
    const mathDisplayCount = (html.match(/<div class="math-display"/g) || []).length;
    console.log('Created math elements:', mathDisplayCount, 'display,', mathInlineCount, 'inline');
    
    return {html, displayMathBlocks, inlineMathBlocks};
  }
  
  // Process any remaining placeholders in the DOM (fallback)
  function processRemainingPlaceholders(container, displayMathBlocks, inlineMathBlocks) {
    if (!container || !displayMathBlocks || !inlineMathBlocks) return;
    
    // Find and replace any remaining placeholders
    const walker = document.createTreeWalker(
      container,
      NodeFilter.SHOW_TEXT,
      null
    );
    
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
      const text = node.textContent;
      if (text.includes('DISPLAYMATH') || text.includes('INLINEMATH') || 
          text.includes('__DISPLAY_MATH_') || text.includes('__INLINE_MATH_')) {
        textNodes.push(node);
      }
    }
    
    if (textNodes.length > 0) {
      console.log('Found', textNodes.length, 'text nodes with placeholders, processing...');
    }
    
    textNodes.forEach(textNode => {
      let text = textNode.textContent;
      const parent = textNode.parentElement;
      if (!parent) return;
      
      // Process display math placeholders
      displayMathBlocks.forEach((latex, index) => {
        const oldPlaceholder = `__DISPLAY_MATH_${index}__`;
        const newPlaceholder = `\u200B\u200BDISPLAYMATH${index}\u200B\u200B`;
        const escapedLatex = latex.replace(/"/g, '&quot;');
        const mathDiv = `<div class="math-display" data-latex="${escapedLatex}"></div>`;
        
        if (text.includes(oldPlaceholder)) {
          text = text.split(oldPlaceholder).join(mathDiv);
        }
        if (text.includes(newPlaceholder)) {
          text = text.split(newPlaceholder).join(mathDiv);
        }
      });
      
      // Process inline math placeholders
      inlineMathBlocks.forEach((latex, index) => {
        const oldPlaceholder = `__INLINE_MATH_${index}__`;
        const newPlaceholder = `\u200B\u200BINLINEMATH${index}\u200B\u200B`;
        const escapedLatex = latex.replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        const mathSpan = `<span class="math-inline" data-latex="${escapedLatex}"></span>`;
        
        if (text.includes(oldPlaceholder)) {
          text = text.split(oldPlaceholder).join(mathSpan);
        }
        if (text.includes(newPlaceholder)) {
          text = text.split(newPlaceholder).join(mathSpan);
        }
      });
      
      // If text changed, replace the node
      if (text !== textNode.textContent) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = text;
        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
          fragment.appendChild(tempDiv.firstChild);
        }
        parent.replaceChild(fragment, textNode);
      }
    });
  }
  
  // Process LaTeX in the DOM (fallback for any missed cases)
  function processLatexInDOM(container) {
    if (!container) return;
    
    // Only process text nodes that still contain $ signs
    const walker = document.createTreeWalker(
      container,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: function(node) {
          const parent = node.parentElement;
          // Skip code blocks, scripts, styles, and existing math elements
          if (parent && (
            parent.tagName === 'SCRIPT' || 
            parent.tagName === 'STYLE' || 
            parent.tagName === 'CODE' || 
            parent.tagName === 'PRE' ||
            parent.classList.contains('math-inline') ||
            parent.classList.contains('math-display') ||
            parent.classList.contains('katex')
          )) {
            return NodeFilter.FILTER_REJECT;
          }
          // Only process nodes with $ signs
          if (!node.textContent || !node.textContent.includes('$')) {
            return NodeFilter.FILTER_REJECT;
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      }
    );
    
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
      textNodes.push(node);
    }
    
    if (textNodes.length > 0) {
      console.log('Processing', textNodes.length, 'remaining text nodes with LaTeX');
    }
    
    // Process each text node
    textNodes.forEach(textNode => {
      const text = textNode.textContent;
      const parent = textNode.parentElement;
      if (!parent) return;
      
      // Process display math first
      const displayMathRegex = /\$\$([\s\S]*?)\$\$/g;
      if (displayMathRegex.test(text)) {
        displayMathRegex.lastIndex = 0;
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        let match;
        
        while ((match = displayMathRegex.exec(text)) !== null) {
          if (match.index > lastIndex) {
            fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
          }
          
          const div = document.createElement('div');
          div.className = 'math-display';
          div.setAttribute('data-latex', sanitizeLatex(match[1].trim()));
          fragment.appendChild(div);
          
          lastIndex = match.index + match[0].length;
        }
        
        if (lastIndex < text.length) {
          fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
        }
        
        parent.replaceChild(fragment, textNode);
        return;
      }
      
      // Process inline math
      const inlineMathRegex = /(?<!\$)\$([^$\n]+?)\$(?!\$)/g;
      if (inlineMathRegex.test(text)) {
        inlineMathRegex.lastIndex = 0;
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        let match;
        
        while ((match = inlineMathRegex.exec(text)) !== null) {
          if (match.index > lastIndex) {
            fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
          }
          
          const span = document.createElement('span');
          span.className = 'math-inline';
          span.setAttribute('data-latex', sanitizeLatex(match[1].trim()));
          fragment.appendChild(span);
          
          lastIndex = match.index + match[0].length;
        }
        
        if (lastIndex < text.length) {
          fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
        }
        
        parent.replaceChild(fragment, textNode);
      }
    });
  }

  // Base path for images placed in public/uploads
  const imageBasePath = `/uploads/courses/${courseId}/chapters/${chapterId}/`;

  // Rewrite relative <img src> to point to our uploads base
  function rewriteImageSrcs(html) {
    return html.replace(/<img([^>]+)src=["']([^"']+)["']([^>]*)>/g, (match, pre, src, post) => {
      const isAbsolute = /^(?:[a-z]+:)?\/\//i.test(src) || src.startsWith('/') || src.startsWith('data:');
      const normalized = isAbsolute ? src : imageBasePath + src.replace(/^\.?\//, '');
      return `<img${pre}src="${normalized}"${post}>`;
    });
  }
  
  // Load KaTeX CSS/JS once and cache the promise
  let katexLoadPromise;
  function loadKatexAssets() {
    // If already loaded, return immediately
    if (window.katex && typeof window.katex.render === 'function') {
      return Promise.resolve();
    }
    
    if (katexLoadPromise) return katexLoadPromise;
    
    katexLoadPromise = new Promise((resolve, reject) => {
      // CSS - ensure it's loaded
      if (!document.getElementById('katex-css')) {
        const link = document.createElement('link');
        link.id = 'katex-css';
        link.rel = 'stylesheet';
        link.href = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css';
        document.head.appendChild(link);
      }
      
      // Check if script already exists (preloaded in head)
      const existingScript = document.getElementById('katex-js');
      
      // Function to wait for KaTeX to become available
      const waitForKaTeX = (maxAttempts = 100) => {
        let attempts = 0;
        const checkInterval = setInterval(() => {
          attempts++;
          if (window.katex && typeof window.katex.render === 'function') {
            clearInterval(checkInterval);
            console.log('KaTeX is now available');
            resolve();
          } else if (attempts >= maxAttempts) {
            clearInterval(checkInterval);
            console.error('KaTeX not available after', maxAttempts * 100, 'ms');
            console.error('window.katex:', window.katex);
            console.error('Script element:', existingScript);
            console.error('Script complete:', existingScript?.complete);
            reject(new Error('KaTeX failed to load - window.katex not available'));
          }
        }, 100);
      };
      
      if (existingScript) {
        // Script exists, wait for it to load
        if (existingScript.complete) {
          // Script already loaded, wait for KaTeX to initialize
          waitForKaTeX();
        } else {
          // Script is still loading
          existingScript.onload = () => {
            waitForKaTeX();
          };
          existingScript.onerror = (e) => {
            console.error('KaTeX script failed to load:', e);
            reject(new Error('Failed to load KaTeX script'));
          };
        }
      } else {
        // Load the script
        const script = document.createElement('script');
        script.id = 'katex-js';
        script.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';
        script.async = true;
        
        script.onload = () => {
          console.log('KaTeX script loaded, waiting for initialization...');
          waitForKaTeX();
        };
        
        script.onerror = (e) => {
          console.error('Failed to load KaTeX script:', e);
          reject(new Error('Failed to load KaTeX script from CDN'));
        };
        
        document.head.appendChild(script);
      }
    });
    
    return katexLoadPromise;
  }

  // Load Highlight.js CSS/JS for code syntax highlighting
  let hljsLoadPromise;
  function loadHighlightAssets() {
    if (hljsLoadPromise) return hljsLoadPromise;
    hljsLoadPromise = new Promise((resolve, reject) => {
      // CSS
      if (!document.getElementById('hljs-css')) {
        const link = document.createElement('link');
        link.id = 'hljs-css';
        link.rel = 'stylesheet';
        link.href = 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github-dark.min.css';
        document.head.appendChild(link);
      }
      // JS
      if (window.hljs) {
        resolve();
        return;
      }
      const script = document.createElement('script');
      script.id = 'hljs-js';
      script.src = 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js';
      script.defer = true;
      script.onload = () => resolve();
      script.onerror = (e) => reject(e);
      document.head.appendChild(script);
    });
    return hljsLoadPromise;
  }

  // Sanitize LaTeX content to remove problematic Unicode characters
  function sanitizeLatex(latex) {
    if (!latex) return '';
    return latex
      // Remove zero-width spaces (8203)
      .replace(/\u200B/g, '')
      // Remove thin spaces (8201, 202F) - replace with regular space
      .replace(/[\u2009\u202F\u200A]/g, ' ')
      // Remove non-breaking spaces (160) - replace with regular space  
      .replace(/\u00A0/g, ' ')
      // Remove combining marks (arrows, accents, etc.) (8400-842F range, including 8407)
      .replace(/[\u0300-\u036F\u20D0-\u20FF]/g, '')
      // Normalize line endings
      .replace(/\r\n?|\u2028|\u2029/g, '\n')
      // Clean up multiple spaces (but preserve intentional spacing in math)
      .replace(/[ \t]+/g, ' ')
      .trim();
  }

  // Enhanced LaTeX renderer for better math display (KaTeX) - DEPRECATED, use renderLatexWithKaTeX instead
  async function renderLatexPreview() {
    return renderLatexWithKaTeX();
  }
  
  // Basic LaTeX renderer for common math symbols
  function renderBasicLatex(latex) {
    return latex
      // Fractions
      .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '<span class="frac"><span class="numerator">$1</span><span class="denominator">$2</span></span>')
      // Superscripts
      .replace(/\^(\d+)/g, '<sup>$1</sup>')
      .replace(/\^\{([^}]+)\}/g, '<sup>$1</sup>')
      // Subscripts
      .replace(/_(\d+)/g, '<sub>$1</sub>')
      .replace(/_\{([^}]+)\}/g, '<sub>$1</sub>')
      // Greek letters
      .replace(/\\alpha/g, 'α')
      .replace(/\\beta/g, 'β')
      .replace(/\\gamma/g, 'γ')
      .replace(/\\delta/g, 'δ')
      .replace(/\\epsilon/g, 'ε')
      .replace(/\\theta/g, 'θ')
      .replace(/\\lambda/g, 'λ')
      .replace(/\\mu/g, 'μ')
      .replace(/\\pi/g, 'π')
      .replace(/\\sigma/g, 'σ')
      .replace(/\\tau/g, 'τ')
      .replace(/\\phi/g, 'φ')
      .replace(/\\omega/g, 'ω')
      // Math symbols
      .replace(/\\infty/g, '∞')
      .replace(/\\sum/g, '∑')
      .replace(/\\int/g, '∫')
      .replace(/\\sqrt/g, '√')
      .replace(/\\pm/g, '±')
      .replace(/\\times/g, '×')
      .replace(/\\div/g, '÷')
      .replace(/\\leq/g, '≤')
      .replace(/\\geq/g, '≥')
      .replace(/\\neq/g, '≠')
      .replace(/\\approx/g, '≈')
      .replace(/\\rightarrow/g, '→')
      .replace(/\\leftarrow/g, '←')
      .replace(/\\leftrightarrow/g, '↔')
      // Parentheses
      .replace(/\\left\(/g, '(')
      .replace(/\\right\)/g, ')')
      .replace(/\\left\[/g, '[')
      .replace(/\\right\]/g, ']')
      .replace(/\\left\{/g, '{')
      .replace(/\\right\}/g, '}');
  }
  
  // Update preview function - clean and simple
  async function updatePreview() {
    const content = monacoEditor ? monacoEditor.getValue() : (document.getElementById('content')?.value || '');
    const previewDiv = document.getElementById('preview-content');
    
    if (!previewDiv) return;
    
    if (!content || content.trim() === '') {
      previewDiv.innerHTML = '<p class="text-slate-400 italic text-sm">Mulai mengetik untuk melihat pratinjau konten Anda...</p>';
      return;
    }
    
    try {
      // Load libraries
      await loadMarkedAssets();
      await loadHighlightAssets();
      await loadKatexAssets();
      
      // Render markdown (LaTeX is processed inside renderMarkdown)
      const renderResult = renderMarkdown(content);
      let html = renderResult.html;
      html = rewriteImageSrcs(html);
      
      // Debug: Check math elements in HTML
      const mathInlineCount = (html.match(/<span class="math-inline"/g) || []).length;
      const mathDisplayCount = (html.match(/<div class="math-display"/g) || []).length;
      console.log('Math elements in HTML:', mathInlineCount, 'inline,', mathDisplayCount, 'display');
      
      // Insert HTML
      previewDiv.innerHTML = html;
      
      // Fallback: Process any remaining placeholders or LaTeX in DOM
      processRemainingPlaceholders(previewDiv, renderResult.displayMathBlocks, renderResult.inlineMathBlocks);
      processLatexInDOM(previewDiv);
      
      // Render math with KaTeX
      await renderLatexWithKaTeX();
      
      // Highlight code
      const codeBlocks = previewDiv.querySelectorAll('pre code');
      if (codeBlocks.length > 0 && window.hljs) {
        codeBlocks.forEach(block => window.hljs.highlightElement(block));
      }
      
      // Final check
      const finalMathInline = previewDiv.querySelectorAll('.math-inline');
      const finalMathDisplay = previewDiv.querySelectorAll('.math-display');
      console.log('Final math elements:', finalMathInline.length, 'inline,', finalMathDisplay.length, 'display');
    } catch (error) {
      console.error('Preview error:', error);
      previewDiv.innerHTML = `<p class="text-red-600">Error: ${error.message}</p>`;
    }
  }
  
  // Render LaTeX with KaTeX
  async function renderLatexWithKaTeX() {
    const previewDiv = document.getElementById('preview-content');
    if (!previewDiv) return;
    
    try {
      await loadKatexAssets();
      
      // Additional wait and check
      let retries = 0;
      const maxRetries = 20;
      while (retries < maxRetries) {
        if (window.katex && typeof window.katex.render === 'function') {
          break;
        }
        await new Promise(resolve => setTimeout(resolve, 100));
        retries++;
      }
      
      if (!window.katex || typeof window.katex.render !== 'function') {
        console.error('KaTeX not available after loading.');
        console.error('window.katex:', window.katex);
        console.error('typeof window.katex:', typeof window.katex);
        console.error('window.katex?.render:', window.katex?.render);
        
        // Check if script tag exists
        const scriptTag = document.getElementById('katex-js');
        console.error('KaTeX script tag:', scriptTag);
        console.error('Script src:', scriptTag?.src);
        console.error('Script loaded:', scriptTag?.complete);
        
        // Try direct injection as fallback
        console.log('Attempting direct KaTeX injection...');
        const directScript = document.createElement('script');
        directScript.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';
        directScript.async = false;
        await new Promise((resolve, reject) => {
          directScript.onload = () => {
            setTimeout(() => {
              if (window.katex && typeof window.katex.render === 'function') {
                console.log('KaTeX loaded via direct injection');
                resolve();
              } else {
                reject(new Error('Direct injection failed'));
              }
            }, 500);
          };
          directScript.onerror = reject;
          document.head.appendChild(directScript);
        });
      }
      
      if (!window.katex || typeof window.katex.render !== 'function') {
        throw new Error('KaTeX is not available. Please check browser console for details.');
      }
      
      console.log('KaTeX is available, rendering math...');
      
      const mathElements = previewDiv.querySelectorAll('.math-display, .math-inline');
      console.log('Rendering', mathElements.length, 'math elements with KaTeX');
      
      mathElements.forEach((element, index) => {
        const latexRaw = element.getAttribute('data-latex') || '';
        if (!latexRaw) {
          console.warn(`Math element ${index} has no data-latex attribute`);
          return;
        }
        
        const sanitizedLatex = sanitizeLatex(latexRaw);
        const latex = sanitizedLatex.replace(/\\rm\s*/g, '\\mathrm ');
        const displayMode = element.classList.contains('math-display');
        
        try {
          element.innerHTML = '';
          window.katex.render(latex, element, {
            displayMode,
            throwOnError: false,
            trust: true,
            strict: false,
            macros: {
              '\\degree': '^{\\circ}'
            }
          });
        } catch (err) {
          console.warn(`KaTeX render error for element ${index}:`, err);
          element.innerHTML = `<span class="text-red-600">$${latex}$</span>`;
        }
      });
      
      // Highlight code blocks
      const codeBlocks = previewDiv.querySelectorAll('pre code');
      if (codeBlocks.length > 0 && window.hljs) {
        codeBlocks.forEach((block) => {
          window.hljs.highlightElement(block);
        });
      }
    } catch (error) {
      console.error('KaTeX rendering error:', error);
    }
  }

  // Unsaved changes tracking
  let hasUnsavedChanges = false;
  let isSaving = false;
  
  // Global error handler for script initialization
  window.addEventListener('error', function(e) {
    console.error('Global error caught:', e.error);
    const container = document.getElementById('monaco-editor-container');
    if (container && !container.querySelector('textarea')) {
      container.innerHTML = `
        <div class="p-4 bg-yellow-50 border border-yellow-200 rounded-lg m-4">
          <p class="text-yellow-800 font-medium">⚠️ Editor initialization issue</p>
          <p class="text-yellow-600 text-sm mt-1">Please check the browser console (F12) for details.</p>
          <p class="text-yellow-600 text-xs mt-2">Error: ${e.message || 'Unknown error'}</p>
        </div>
      `;
    }
  });

  function updateUnsavedIndicator() {
    const bottomIndicator = document.getElementById('unsaved-indicator');
    const headerIndicator = document.getElementById('header-unsaved-indicator');
    
    if (hasUnsavedChanges && !isSaving) {
      bottomIndicator?.classList.remove('hidden');
      bottomIndicator?.classList.add('flex');
      headerIndicator?.classList.remove('hidden');
      headerIndicator?.classList.add('flex');
    } else {
      bottomIndicator?.classList.add('hidden');
      bottomIndicator?.classList.remove('flex');
      headerIndicator?.classList.add('hidden');
      headerIndicator?.classList.remove('flex');
    }
  }

  function checkForChanges() {
    const currentContent = monacoEditor ? monacoEditor.getValue() : (document.getElementById('content')?.value || '');
    const currentTitle = document.getElementById('title')?.value || '';
    const currentOrder = parseInt(document.getElementById('order')?.value || '0');
    
    const contentChanged = currentContent !== savedContent;
    const titleChanged = currentTitle !== savedTitle;
    const orderChanged = currentOrder !== savedOrder;
    
    hasUnsavedChanges = contentChanged || titleChanged || orderChanged;
    updateUnsavedIndicator();
  }
  
  // Initialize original values (from server via define:vars)
  // Variables from define:vars are available as: originalContent, originalTitle, originalOrder
  // Create mutable copies for tracking changes with safe defaults
  let savedContent = (typeof originalContent !== 'undefined') ? originalContent : '';
  let savedTitle = (typeof originalTitle !== 'undefined') ? originalTitle : '';
  let savedOrder = (typeof originalOrder !== 'undefined') ? originalOrder : 0;

  // Warn before leaving with unsaved changes
  window.addEventListener('beforeunload', function(e) {
    if (hasUnsavedChanges && !isSaving) {
      e.preventDefault();
      e.returnValue = 'Anda memiliki perubahan yang belum disimpan. Apakah Anda yakin ingin meninggalkan halaman ini?';
      return e.returnValue;
    }
  });

  // Intercept navigation links
  function interceptNavigation(e) {
    if (hasUnsavedChanges && !isSaving) {
      e.preventDefault();
      if (confirm('Anda memiliki perubahan yang belum disimpan. Apakah Anda yakin ingin meninggalkan halaman ini?')) {
        hasUnsavedChanges = false;
        window.location.href = e.target.href || e.target.closest('a').href;
      }
    }
  }

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', async function() {
    console.log('DOMContentLoaded - Starting initialization...');
    
    try {
      // Initialize Monaco Editor
      console.log('Initializing Monaco Editor...');
      await initMonacoEditor();
      console.log('Monaco Editor initialization complete');
    } catch (error) {
      console.error('Error initializing Monaco Editor:', error);
      // Fallback: show error message in container
      const container = document.getElementById('monaco-editor-container');
      if (container) {
        container.innerHTML = `
          <div class="p-4 bg-red-50 border border-red-200 rounded-lg">
            <p class="text-red-800 font-medium">Error loading editor</p>
            <p class="text-red-600 text-sm mt-1">${error.message}</p>
            <p class="text-red-600 text-xs mt-2">Please refresh the page or check the browser console for details.</p>
          </div>
        `;
      }
    }
    
    // Update size on load
    try {
      updateContentSize();
    } catch (error) {
      console.error('Error updating content size:', error);
    }
    
    // Initial preview update
    try {
      await updatePreview();
    } catch (error) {
      console.error('Error updating preview:', error);
    }
    
    // Preview button functionality
    const previewBtn = document.getElementById('preview-btn');
    if (previewBtn) {
      previewBtn.addEventListener('click', async function() {
        await updatePreview();
      });
    }
    
    // Initialize block insertion
    setupBlockInsertion();

    // Track changes in form fields
    const titleInput = document.getElementById('title');
    const orderSelect = document.getElementById('order');
    
    if (titleInput) {
      titleInput.addEventListener('input', checkForChanges);
      titleInput.addEventListener('change', checkForChanges);
    }
    
    if (orderSelect) {
      orderSelect.addEventListener('change', checkForChanges);
    }

    // Track changes in Monaco Editor
    if (monacoEditor) {
      monacoEditor.onDidChangeModelContent(() => {
        checkForChanges();
      });
    }

    // Intercept navigation links
    const cancelLink = document.getElementById('cancel-link');
    const headerBackLink = document.getElementById('header-back-link');
    
    if (cancelLink) {
      cancelLink.addEventListener('click', interceptNavigation);
    }
    
    if (headerBackLink) {
      headerBackLink.addEventListener('click', interceptNavigation);
    }

    // Form submission with large file handling
    const form = document.getElementById('chapter-form');
    if (form) {
      form.addEventListener('submit', async function(e) {
        e.preventDefault();
        
        if (isSaving) return; // Prevent double submission
        
        const formData = new FormData(form);
        const content = monacoEditor ? monacoEditor.getValue() : formData.get('content');
        
        // Check content size and warn if large
        const contentSize = new Blob([content]).size;
        const sizeMB = (contentSize / 1024 / 1024).toFixed(2);
        
        if (contentSize > 5 * 1024 * 1024) { // > 5MB
          if (!confirm(`Bab ini berukuran ${sizeMB}MB. File besar mungkin membutuhkan waktu lebih lama untuk disimpan dan dimuat. Lanjutkan?`)) {
            return;
          }
        }
        
        const chapterData = {
          title: formData.get('title'),
          order: parseInt(formData.get('order')),
          content: content
        };
        
        // Show loading indicator
        isSaving = true;
        const submitBtn = document.getElementById('save-btn');
        const saveIcon = document.getElementById('save-icon');
        const saveText = document.getElementById('save-text');
        const originalText = saveText?.textContent || 'Simpan Perubahan';
        
        if (submitBtn) {
          submitBtn.disabled = true;
          if (saveIcon) {
            saveIcon.innerHTML = '<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>';
            saveIcon.classList.add('animate-spin');
          }
          if (saveText) {
            saveText.textContent = 'Menyimpan...';
          }
        }
        
        updateUnsavedIndicator();
        
        try {
          console.log('Sending chapter data:', chapterData);
          
          const response = await fetch(`/api/admin/chapters/${chapterId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(chapterData)
          });
          
          console.log('Response status:', response.status);
          
          if (response.ok) {
            const result = await response.json();
            console.log('Success:', result);
            
            // Update saved values
            savedContent = content;
            savedTitle = chapterData.title;
            savedOrder = chapterData.order;
            hasUnsavedChanges = false;
            isSaving = false;
            
            // Show success message
            if (saveText) {
              saveText.textContent = 'Berhasil Disimpan!';
            }
            if (saveIcon) {
              saveIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />';
              saveIcon.classList.remove('animate-spin');
            }
            
            updateUnsavedIndicator();
            
            // Ask user if they want to stay or go back
            setTimeout(() => {
              const stay = confirm('Bab berhasil disimpan! Klik OK untuk tetap di halaman ini, atau Cancel untuk kembali ke editor kursus.');
              if (!stay) {
                window.location.href = `/admin/courses/${courseId}/edit`;
              } else {
                // Reset button
                if (submitBtn) submitBtn.disabled = false;
                if (saveText) saveText.textContent = originalText;
              }
            }, 500);
          } else {
            const errorText = await response.text();
            console.error('Error response:', errorText);
            
            let errorMessage = 'Terjadi kesalahan';
            try {
              const errorData = JSON.parse(errorText);
              errorMessage = errorData.error || errorData.message || errorText;
            } catch (e) {
              errorMessage = errorText || `HTTP ${response.status}: ${response.statusText}`;
            }
            
            alert(`Error memperbarui bab: ${errorMessage}`);
            
            // Reset button
            isSaving = false;
            if (submitBtn) submitBtn.disabled = false;
            if (saveIcon) {
              saveIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />';
              saveIcon.classList.remove('animate-spin');
            }
            if (saveText) saveText.textContent = originalText;
            updateUnsavedIndicator();
          }
        } catch (error) {
          console.error('Chapter update error:', error);
          isSaving = false;
          
          let errorMessage = 'Terjadi kesalahan saat menyimpan';
          if (error.message.includes('431') || error.message.includes('header')) {
            errorMessage = 'Konten terlalu besar. Silakan kurangi ukuran file atau bagi menjadi beberapa bab.';
          } else if (error.message) {
            errorMessage = `Error: ${error.message}`;
          }
          
          alert(errorMessage);
          
          // Reset button
          if (submitBtn) submitBtn.disabled = false;
          if (saveIcon) {
            saveIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />';
            saveIcon.classList.remove('animate-spin');
          }
          if (saveText) saveText.textContent = originalText;
          updateUnsavedIndicator();
        }
      });
    }

    // Delete confirmation
    const deleteBtn = document.getElementById('delete-btn');
    if (deleteBtn) {
      deleteBtn.addEventListener('click', async function() {
        if (hasUnsavedChanges) {
          if (!confirm('Anda memiliki perubahan yang belum disimpan. Hapus bab ini akan menghapus semua perubahan. Lanjutkan?')) {
            return;
          }
        } else {
          if (!confirm('Apakah Anda yakin ingin menghapus bab ini? Tindakan ini tidak dapat dibatalkan.')) {
            return;
          }
        }

        deleteBtn.disabled = true;
        deleteBtn.textContent = 'Menghapus...';

        try {
          const response = await fetch(`/api/admin/chapters/${chapterId}`, {
            method: 'DELETE'
          });
          
          if (response.ok) {
            hasUnsavedChanges = false; // Clear flag before redirect
            window.location.href = `/admin/courses/${courseId}/edit`;
          } else {
            const error = await response.json();
            alert(`Error menghapus bab: ${error.error || 'Terjadi kesalahan'}`);
            deleteBtn.disabled = false;
            deleteBtn.innerHTML = '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg> Hapus Bab';
          }
        } catch (error) {
          console.error('Chapter deletion error:', error);
          alert('Error menghapus bab. Silakan coba lagi.');
          deleteBtn.disabled = false;
          deleteBtn.innerHTML = '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg> Hapus Bab';
        }
      });
    }
  });

</script>

<style>
  #content {
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 14px;
    line-height: 1.5;
  }

  .prose .math-display,
  .prose .math-inline {
    background-color: #f8fafc;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    padding: 8px 12px;
    margin: 8px 0;
    font-family: 'Times New Roman', 'Computer Modern', serif;
  }

  /* Table styles for GFM tables */
  .prose table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
  }
  .prose table th,
  .prose table td {
    border: 1px solid #e2e8f0;
    padding: 0.5rem 0.75rem;
    text-align: left;
  }
  .prose table thead th {
    background-color: #f1f5f9;
    font-weight: 600;
  }

  /* Images */
  .prose img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 0.5rem 0;
    border-radius: 4px;
  }
  
  .prose .math-display {
    display: block;
    text-align: center;
    margin: 16px 0;
    padding: 16px;
    font-size: 1.2em;
  }
  
  .prose .math-inline {
    display: inline;
    font-size: 1em;
    margin: 0 2px;
  }
  
  .math-content {
    position: relative;
  }
  
  .math-raw {
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.8em;
    color: #64748b;
    margin-bottom: 4px;
    opacity: 0.7;
  }
  
  .math-rendered {
    font-size: 1.1em;
    color: #1e293b;
    font-weight: 500;
  }
  
  .frac {
    display: inline-block;
    text-align: center;
    vertical-align: middle;
  }
  
  .frac .numerator {
    display: block;
    border-bottom: 1px solid #1e293b;
    padding-bottom: 2px;
    margin-bottom: 2px;
  }
  
  .frac .denominator {
    display: block;
    padding-top: 2px;
  }
  
  sup, sub {
    font-size: 0.8em;
    font-weight: bold;
  }
  
  sup {
    vertical-align: super;
  }
  
  sub {
    vertical-align: sub;
  }
  
  /* List styles for preview content */
  .prose ul {
    list-style-type: disc;
    padding-left: 1.5rem;
    margin: 1rem 0;
  }
  
  .prose ol {
    list-style-type: decimal;
    padding-left: 1.5rem;
    margin: 1rem 0;
  }
  
  .prose li {
    display: list-item;
    margin: 0.5rem 0;
  }
  
  .prose ul ul {
    list-style-type: circle;
  }
  
  .prose ol ol {
    list-style-type: lower-alpha;
  }
  
  .prose ol ol ol {
    list-style-type: lower-roman;
  }

  /* System-wide Widescreen Mode - Override all max-width constraints */
  html.system-widescreen-mode,
  body.system-widescreen-mode {
    max-width: 100vw !important;
    width: 100% !important;
    overflow-x: hidden !important;
  }

  body.system-widescreen-mode .min-h-screen {
    max-width: 100vw !important;
    width: 100% !important;
  }

  body.system-widescreen-mode .min-h-screen > *,
  body.system-widescreen-mode .min-h-screen > * > * {
    max-width: 100% !important;
  }

  /* Override ALL Tailwind max-width classes */
  body.system-widescreen-mode [class*="max-w"] {
    max-width: 100% !important;
  }

  /* Override mx-auto centering */
  body.system-widescreen-mode [class*="mx-auto"] {
    margin-left: 0 !important;
    margin-right: 0 !important;
  }

  /* Expand form container and all children */
  body.system-widescreen-mode #chapter-form,
  body.system-widescreen-mode #chapter-form > * {
    max-width: 100% !important;
  }

  /* Expand tools section */
  body.system-widescreen-mode #tools-section {
    max-width: 100% !important;
    padding-left: 1rem !important;
    padding-right: 1rem !important;
  }

  /* Header container */
  body.system-widescreen-mode header .max-w-full,
  body.system-widescreen-mode header [class*="max-w"] {
    max-width: 100% !important;
    padding-left: 1rem !important;
    padding-right: 1rem !important;
  }

  /* Force all direct children of min-h-screen to be full width */
  body.system-widescreen-mode .min-h-screen > div {
    max-width: 100% !important;
    width: 100% !important;
  }

  /* Ensure preview panel is always visible and properly positioned */
  body.system-widescreen-mode #chapter-form .flex-1.flex.overflow-hidden > div {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
    max-width: none !important;
  }

  /* When NOT in widescreen mode, ensure normal centered layout */
  body:not(.system-widescreen-mode) #chapter-form {
    max-width: 100%;
  }

  body:not(.system-widescreen-mode) .min-h-screen {
    display: flex;
    flex-direction: column;
  }

  /* Ensure preview panel is visible when widescreen is off */
  body:not(.system-widescreen-mode) #chapter-form .flex-1.flex.overflow-hidden {
    display: flex !important;
    width: 100% !important;
  }

  body:not(.system-widescreen-mode) #chapter-form .flex-1.flex.overflow-hidden > div {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
    flex: 1 1 50% !important;
    min-width: 0 !important;
  }

  /* Ensure preview panel (right side) takes up proper space */
  body:not(.system-widescreen-mode) #chapter-form .flex-1.flex.overflow-hidden > div:last-child {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
    flex: 1 1 50% !important;
  }

  /* Ensure preview content is visible */
  body:not(.system-widescreen-mode) #preview-content {
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
  }
</style>

