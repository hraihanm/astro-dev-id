---
import Layout from '../../../components/Layout.astro';
import Icon from '../../../components/icons/Icon.astro';
import { renderMarkdown } from '../../../lib/latex';
import { getSessionUser } from '../../../lib/auth-guard';
import { prisma } from '../../../lib/db';
import quizSharedStyles from '../../../styles/quiz-shared.css?url';

export const prerender = false;

const { id } = Astro.params;

// Get logged in user
const user = await getSessionUser(Astro.cookies);
let classroomIds: number[] = [];
if (user) {
  const memberships = await prisma.classroomMembership.findMany({
    where: { userId: user.id, status: 'ACTIVE' },
    select: { classroomId: true }
  });
  classroomIds = memberships.map((m) => m.classroomId);
}

// Fetch quiz details directly from database
let quiz: any = null;
let clientQuiz: any = null; // Sanitized version for client (no solutions/answers)
let error = '';
let attemptLimitReached = false;
let userAttemptCount = 0;

try {
  const quizId = parseInt(id || '0');
  
  // Use server-side import to get the quiz
  const { getQuiz } = await import('../../../lib/quizzes');
  const rawQuiz = await getQuiz(quizId, {
    role: user?.role,
    classroomIds
  });
  
  // Check if quiz exists (can be standalone or course quiz)
  if (!rawQuiz) {
    return Astro.redirect(`/quizzes/${id}`);
  } else {
    // Parse questions if it's a string
    quiz = {
      ...rawQuiz,
      questions: typeof rawQuiz.questions === 'string' 
        ? JSON.parse(rawQuiz.questions) 
        : rawQuiz.questions,
      settings: typeof rawQuiz.settings === 'string'
        ? JSON.parse(rawQuiz.settings)
        : rawQuiz.settings
    };
    
    // Count attempts for this user (for display and limits)
    if (user) {
      userAttemptCount = await prisma.quizAttempt.count({
        where: {
          userId: user.id,
          quizId: quizId
        }
      });
    }
    quiz.userAttemptCount = userAttemptCount;
      
    if (quiz.attemptLimit && userAttemptCount >= quiz.attemptLimit) {
        return Astro.redirect(`/quizzes/${id}`);
    }
    
    // Handle essay problem format
    if (quiz.settings?.type === 'essay' && quiz.questions?.type === 'essay-problem-set') {
      // Essay problems have a different structure
      quiz.isEssay = true;
      quiz.problems = quiz.questions.problems || [];
    } else if (Array.isArray(quiz.questions)) {
      quiz.isEssay = false;
    } else {
      // Unknown format
      error = 'Invalid quiz format';
    }

    // Create sanitized version for client - REMOVE solutions and correct answers
    if (quiz && !quiz.isEssay && Array.isArray(quiz.questions)) {
      clientQuiz = {
        id: quiz.id,
        title: quiz.title,
        courseId: quiz.courseId,
        chapterId: quiz.chapterId,
        settings: quiz.settings,
        quizType: quiz.quizType || 'latihan',
        attemptLimit: quiz.attemptLimit,
        scoreReleaseMode: quiz.scoreReleaseMode,
        userAttemptCount,
        userAttemptCount: userAttemptCount,
        isEssay: quiz.isEssay,
        questions: quiz.questions.map((q: any, idx: number) => {
          const sanitized: any = {
          id: q.id || idx + 1,
          type: q.type,
          question: q.question,
            images: q.images || [],
          // SECURITY: Do NOT include correctAnswer or metadata.solution
          };
          
          // Include type-specific fields
          if (q.type === 'fill-in-the-blank') {
            sanitized.questionTemplate = q.questionTemplate || q.question || '';
            sanitized.blanks = (q.blanks || []).map((blank: any) => ({
              index: blank.index,
              // Don't include correctAnswers for security - only structure
              correctAnswers: [], // Empty array - answers are checked server-side
              caseSensitive: blank.caseSensitive || false,
              mathMode: blank.mathMode === true, // Include math mode setting
              tolerance: blank.tolerance !== undefined ? blank.tolerance : 0.0001, // Include tolerance for math mode
              algebraMode: blank.algebraMode !== false // Include algebra mode (default true)
            }));
          } else if (q.type === 'essay') {
            sanitized.maxWords = q.maxWords;
            sanitized.allowFileUpload = q.allowFileUpload || false;
            sanitized.allowedFileTypes = q.allowedFileTypes || [];
          } else {
            // Multiple choice
            sanitized.options = q.options || [];
          }
          
          return sanitized;
        })
      };
    } else {
      clientQuiz = quiz;
    }
  }
} catch (err) {
  error = 'Error loading quiz';
  console.error(err);
}
---

<Layout title={quiz?.title || 'Quiz Not Found'}>
  <link rel="stylesheet" href={quizSharedStyles}>
  <div class="min-h-screen bg-gray-50">
    {error ? (
      <div class="max-w-2xl mx-auto px-4 py-8">
        <div class="bg-white rounded-lg shadow p-8 text-center">
          <div class="text-red-500 text-6xl mb-4">???</div>
          <h2 class="text-2xl font-bold text-gray-900 mb-2">{error}</h2>
          <p class="text-gray-600 mb-4">The quiz you're looking for doesn't exist.</p>
          <a href="/quizzes" class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700">
            <Icon name="arrow-left" class="w-4 h-4" />
            Back to Practice Quizzes
          </a>
        </div>
      </div>
    ) : attemptLimitReached ? (
      <div class="max-w-2xl mx-auto px-4 py-8">
        <div class="bg-white rounded-xl shadow-lg p-8 text-center border border-amber-200">
          <div class="w-20 h-20 mx-auto mb-6 bg-amber-100 rounded-full flex items-center justify-center">
            <svg class="w-10 h-10 text-amber-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
            </svg>
          </div>
          <h2 class="text-2xl font-bold text-gray-900 mb-3">Batas Percobaan Tercapai</h2>
          <p class="text-gray-600 mb-2">Kamu sudah menggunakan semua kesempatan untuk kuis ini.</p>
          <div class="inline-flex items-center gap-2 bg-amber-50 px-4 py-2 rounded-lg text-amber-800 font-medium mb-6">
            <Icon name="pencil" class="w-4 h-4" />
            <span>Percobaan: {userAttemptCount} / {quiz.attemptLimit}</span>
          </div>
          {quiz.quizType === 'tryout' && (
            <div class="bg-slate-50 rounded-lg p-4 mb-6 text-left">
              <h3 class="flex items-center gap-2 font-semibold text-slate-800 mb-2">
                <Icon name="lightbulb" class="w-4 h-4" />
                <span>Tentang Try Out</span>
              </h3>
              <p class="text-sm text-slate-600">
                Kuis tipe Try Out memiliki batas percobaan untuk mensimulasikan kondisi ujian yang sebenarnya. 
                Ini membantu kamu berlatih dengan tekanan waktu dan keterbatasan kesempatan.
              </p>
            </div>
          )}
          <div class="flex flex-col sm:flex-row gap-3 justify-center">
            <a href="/quizzes/history" class="inline-flex items-center justify-center gap-2 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium transition-colors">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
              </svg>
              Lihat Riwayat Hasil
            </a>
            <a href="/quizzes" class="inline-flex items-center justify-center gap-2 px-6 py-3 border border-slate-300 text-slate-700 rounded-lg hover:bg-slate-50 font-medium transition-colors">
              <Icon name="arrow-left" class="w-4 h-4" />
              Kembali ke Daftar Kuis
            </a>
          </div>
        </div>
      </div>
    ) : quiz?.isEssay ? (
      <!-- Essay Problems Display (keep existing) -->
      <div id="quiz-container" class="max-w-4xl mx-auto px-4 py-8">
        <div class="bg-white rounded-lg shadow p-8">
          <div class="mb-6 pb-4 border-b">
            <h1 class="text-3xl font-bold text-gray-900 mb-2">{quiz.title}</h1>
            {quiz.settings?.description && (
              <p class="text-gray-600 mb-4">{quiz.settings.description}</p>
            )}
            <div class="flex items-center space-x-6 text-sm text-gray-600">
              <span>{quiz.problems?.length || 0} essay problems</span>
            </div>
          </div>

          <div class="space-y-8">
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
              <p class="text-blue-800 text-sm inline-flex items-center gap-2">
                <Icon name="pencil" class="w-4 h-4" />
                <span><strong>Soal Essay:</strong> Ini adalah soal essay untuk latihan. Anda dapat membaca dan mengerjakan soal-soal berikut.</span>
              </p>
            </div>
            
            {quiz.problems.map((problem: any, pIndex: number) => (
              <div class="border rounded-lg p-6 bg-gray-50">
                <h3 class="text-xl font-bold text-gray-900 mb-4">
                  Soal {pIndex + 1}: {problem.title}
                </h3>
                
                <div class="prose max-w-none mb-6">
                  <div set:html={problem.problemStatement} class="text-gray-700"></div>
                </div>
                
                {problem.subproblems && problem.subproblems.length > 0 && (
                  <div class="space-y-4 ml-4">
                    {problem.subproblems.map((sub: any, sIndex: number) => (
                      <div class="border-l-4 border-purple-500 pl-4">
                        <h4 class="font-semibold text-gray-900 mb-2">
                          {String.fromCharCode(97 + sIndex)}. {sub.title}
                        </h4>
                        <div class="prose max-w-none">
                          <div set:html={sub.content} class="text-gray-700"></div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            ))}
            
            <div class="mt-8 pt-6 border-t flex justify-between">
              <a
                href="/quizzes"
                class="inline-flex items-center gap-2 px-6 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 text-gray-700"
              >
                <Icon name="arrow-left" class="w-4 h-4" />
                Kembali ke Daftar Kuis
              </a>
            </div>
          </div>
        </div>
      </div>
    ) : (
      <!-- Multiple Choice Quiz with Pagination - Mobile Friendly -->
      <div id="quiz-shell" class="flex flex-col min-h-screen bg-gradient-to-br from-slate-50 to-slate-100">
        <!-- Quiz Title Header - Clean and elegant -->
        <div class="bg-white shadow-sm px-4 sm:px-6 py-3 sm:py-4 border-b border-slate-200">
          <div class="flex items-center justify-between max-w-7xl mx-auto">
            <div class="flex items-center space-x-2 sm:space-x-3 min-w-0">
              <div class="w-8 h-8 sm:w-10 sm:h-10 rounded-lg bg-blue-100 flex items-center justify-center flex-shrink-0">
                <Icon name="pencil" class="w-5 h-5 text-blue-600" />
              </div>
              <div class="min-w-0">
                <h1 class="text-base sm:text-xl font-bold text-slate-900 truncate">{quiz.title}</h1>
                <p class="text-xs sm:text-sm text-slate-500">{quiz.questions?.length || 0} soal</p>
              </div>
            </div>
            <!-- Mobile sidebar toggle -->
            <button id="mobile-sidebar-toggle" class="lg:hidden p-2 rounded-lg hover:bg-slate-100 transition-colors">
              <svg class="w-6 h-6 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
              </svg>
            </button>
          </div>
        </div>

        <!-- Navigation Row - Responsive -->
        <div class="flex flex-col lg:flex-row border-b border-slate-200 bg-white">
          <!-- Navigation Bar Column -->
          <div id="nav-container" class="flex-1 px-4 sm:px-6 py-3 sm:py-4 flex items-center justify-between order-last lg:order-first">
            <!-- Navigation bar will be rendered here by JavaScript -->
          </div>
          
          <!-- Timer - Fixed width to match sidebar -->
          <div class="lg:w-80 lg:border-l border-b lg:border-b-0 border-slate-200 px-4 py-2 sm:py-3 flex items-center justify-center">
            <div id="timer" class="flex items-center space-x-2 sm:space-x-3 bg-slate-50 border border-slate-200 px-3 sm:px-5 py-2 sm:py-2.5 rounded-lg sm:rounded-xl">
              <svg class="h-4 w-4 sm:h-5 sm:w-5 text-slate-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <circle cx="12" cy="12" r="9" stroke-width="1.8" />
                <path stroke-width="1.8" stroke-linecap="round" d="M12 7v5l3 2" />
              </svg>
              <span class="hidden sm:inline text-xs font-semibold text-slate-500 uppercase tracking-wider">Sisa Waktu</span>
              <span id="timer-display" class="text-lg sm:text-xl font-mono font-bold text-slate-800 tabular-nums">--:--:--</span>
            </div>
          </div>
        </div>

        <!-- Main Content Area with Sidebar -->
        <div class="flex flex-1 overflow-hidden relative">
          <!-- Main Quiz Area -->
          <div class="flex-1 flex flex-col overflow-hidden">
            <!-- Question Display Area -->
            <div class="flex-1 overflow-y-auto px-4 sm:px-6 py-4 sm:py-6 scroll-smooth">
              <div id="question-container" class="max-w-4xl mx-auto overflow-visible quiz-content">
                <!-- Questions will be rendered here by JavaScript -->
              </div>
              
              <!-- Mobile bottom padding for fixed footer -->
              <div class="h-24 lg:hidden"></div>
            </div>
          </div>

          <!-- Sidebar - Question Navigator (Desktop) / Slide-over (Mobile) -->
          <div id="sidebar" class="fixed lg:relative inset-y-0 right-0 w-80 bg-white border-l border-slate-200 flex flex-col transform translate-x-full lg:translate-x-0 transition-transform duration-300 ease-in-out z-40 overflow-y-auto">
            
            <!-- Mobile sidebar close button -->
            <div class="lg:hidden flex items-center justify-between p-4 border-b border-slate-200">
              <span class="font-bold text-slate-700">Menu Quiz</span>
              <button id="close-sidebar" class="p-2 rounded-lg hover:bg-slate-100 transition-colors">
                <svg class="w-5 h-5 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
              </button>
            </div>

            <!-- Question Grid & Legend Container -->
            <div class="p-4 sm:p-5">
              <h3 class="font-bold text-slate-700 text-xs mb-4 uppercase tracking-wider flex items-center gap-2">
                <Icon name="clipboard" class="w-4 h-4" />
                <span>Nomor Soal</span>
              </h3>
              <div id="question-grid" class="grid grid-cols-5 gap-2 sm:gap-2.5 overflow-y-auto overflow-x-visible p-1 mb-4 max-h-[360px]">
                <!-- Question numbers will be rendered here - max 50 visible (10 rows), rest scrollable -->
              </div>
              
              <!-- Status Legend - Inline below grid -->
              <div class="bg-slate-50 rounded-lg p-3 sm:p-4 space-y-2">
                <div class="flex items-center justify-between">
                  <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded bg-emerald-100 border-2 border-emerald-400 flex items-center justify-center">
                      <Icon name="check" class="w-2.5 h-2.5 text-emerald-600" strokeWidth={2.5} />
                    </div>
                    <span class="text-slate-600 text-xs font-medium">Sudah dijawab</span>
                  </div>
                  <span id="answered-count" class="font-bold text-emerald-600 text-xs">0</span>
                </div>
                <div class="flex items-center justify-between">
                  <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded bg-amber-100 border-2 border-amber-400 flex items-center justify-center">
                      <Icon name="flag" class="w-2.5 h-2.5 text-amber-600" strokeWidth={2} />
                    </div>
                    <span class="text-slate-600 text-xs font-medium">Ragu-ragu</span>
                  </div>
                  <span id="flagged-count" class="font-bold text-amber-600 text-xs">0</span>
                </div>
                <div class="flex items-center justify-between">
                  <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded bg-slate-100 border-2 border-slate-300 flex items-center justify-center">
                      <div class="w-1.5 h-1.5 rounded-full bg-slate-400"></div>
                    </div>
                    <span class="text-slate-600 text-xs font-medium">Belum dijawab</span>
                  </div>
                  <span id="unanswered-count" class="font-bold text-slate-500 text-xs">0</span>
                </div>
              </div>
            </div>

            <!-- Action Buttons -->
            <div class="p-4 sm:p-5 border-t border-slate-100 space-y-3">
              <button
                id="flag-btn"
                class="w-full flex items-center justify-center gap-2 px-4 py-2.5 bg-white border-2 border-amber-300 text-amber-700 rounded-lg hover:bg-amber-50 hover:border-amber-400 text-sm font-medium transition-all"
              >
                <Icon name="flag" class="w-4 h-4" />
                <span id="flag-text">Ragu-Ragu</span>
              </button>
              
              <!-- Cancel button - only shown for exercises (not exams) -->
              <button
                id="cancel-attempt-btn"
                class="w-full flex items-center justify-center gap-2 px-4 py-2.5 bg-white border-2 border-red-300 text-red-700 rounded-lg hover:bg-red-50 hover:border-red-400 text-sm font-medium transition-all hidden"
              >
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
                Batalkan Percobaan
              </button>
              
              <button
                id="submit-quiz-btn"
                class="w-full flex items-center justify-center gap-2 px-4 py-3 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg font-semibold text-sm transition-all"
              >
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                </svg>
                Selesaikan Ujian
              </button>
            </div>
          </div>
          
          <!-- Mobile sidebar overlay -->
          <div id="sidebar-overlay" class="fixed inset-0 bg-black/50 z-30 hidden lg:hidden"></div>
        </div>
        
        <!-- Mobile Bottom Navigation -->
        <div class="lg:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-slate-200 px-4 py-3 flex items-center justify-between gap-2 z-20">
          <button id="mobile-prev-btn" class="flex-1 inline-flex items-center justify-center gap-2 px-3 py-2 bg-white border border-gray-300 rounded-md text-sm text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed">
            <Icon name="arrow-left" class="w-4 h-4" />
            <span>Sebelumnya</span>
          </button>
          <button id="mobile-flag-btn" class="px-4 py-2 bg-white border border-amber-300 rounded-md text-amber-700 hover:bg-amber-50 inline-flex items-center justify-center">
            <Icon name="flag" class="w-4 h-4" />
          </button>
          <button id="mobile-next-btn" class="flex-1 inline-flex items-center justify-center gap-2 px-3 py-2 bg-white border border-gray-300 rounded-md text-sm text-gray-700 hover:bg-gray-50">
            <span>Selanjutnya</span>
            <Icon name="arrow-right" class="w-4 h-4" />
          </button>
        </div>
      </div>
    )}
  </div>

  <style is:global>
    /* Custom Scrollbar Styling */
    .scroll-smooth::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    .scroll-smooth::-webkit-scrollbar-track {
      background: transparent;
    }

    .scroll-smooth::-webkit-scrollbar-thumb {
      background: #e2e8f0;
      border-radius: 3px;
      transition: background 0.2s;
    }

    .scroll-smooth::-webkit-scrollbar-thumb:hover {
      background: #cbd5e1;
    }

    /* For Firefox */
    .scroll-smooth {
      scrollbar-width: thin;
      scrollbar-color: #e2e8f0 transparent;
    }
    
    /* Hide scrollbar until hover */
    .scroll-smooth::-webkit-scrollbar-thumb {
      background: transparent;
    }
    
    .scroll-smooth:hover::-webkit-scrollbar-thumb {
      background: #e2e8f0;
    }

    /* Anti-cheating: Disable text selection on quiz content */
    .quiz-content {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    /* Allow selection on input fields */
    .quiz-content input,
    .quiz-content textarea {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }

    .math-display {
      margin: 0.5rem 0;
      text-align: center;
    }

    .math-display .katex-display {
      margin: 0;
    }

    .math-inline {
      display: inline;
      vertical-align: baseline;
    }

    .math-inline .katex {
      display: inline;
      vertical-align: baseline;
      font-size: 1em;
    }

    .math-inline .katex-html {
      display: inline;
    }

    /* Ensure KaTeX elements align properly with text */
    .prose .math-inline,
    .prose p .math-inline,
    .option-text .math-inline,
    .option-content .math-inline {
      vertical-align: baseline;
    }

    .math-inline .katex-display {
      margin: 0;
      display: inline;
    }

    .latex-error {
      background-color: #fee;
      border: 1px solid #fcc;
      padding: 0.5rem;
      border-radius: 0.25rem;
      color: #c33;
    }

    .question-number {
      width: 2.25rem;
      height: 2.25rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0.5rem;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.15s ease-in-out;
      font-size: 0.8125rem;
      border: 2px solid transparent;
      position: relative;
      flex-shrink: 0;
    }
    
    @media (min-width: 640px) {
      .question-number {
        width: 2.5rem;
        height: 2.5rem;
        border-radius: 0.625rem;
        font-size: 0.875rem;
      }
    }

    .question-number:hover {
      transform: scale(1.08);
      z-index: 10;
    }
    
    .question-number:active {
      transform: translateY(-1px) scale(1.02);
    }

    /* Answered - Emerald green */
    .question-number.answered {
      background-color: #ecfdf5;
      color: #059669;
      border-color: #6ee7b7;
    }

    /* Flagged (unanswered) - Amber */
    .question-number.flagged {
      background-color: #fffbeb;
      color: #d97706;
      border-color: #fcd34d;
    }

    /* Flagged + Answered - Orange */
    .question-number.flagged-answered {
      background-color: #fff7ed;
      color: #ea580c;
      border-color: #fb923c;
    }

    /* Unanswered - Subtle slate */
    .question-number.unanswered {
      background-color: #f8fafc;
      color: #64748b;
      border-color: #e2e8f0;
    }

    /* Current question - Bold blue */
    .question-number.current {
      background-color: #3b82f6 !important;
      color: white !important;
      font-weight: 700 !important;
      border-color: #3b82f6 !important;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2), 0 4px 6px -1px rgba(59, 130, 246, 0.3) !important;
      transform: scale(1.1) !important;
    }

    .question-number.current:hover {
      transform: scale(1.1) !important;
    }

    .option-label {
      display: flex;
      flex-direction: row;
      align-items: center;
      padding: 0.875rem 1rem;
      border: 2px solid #e2e8f0;
      border-radius: 0.75rem;
      cursor: pointer;
      transition: all 0.2s ease-in-out;
      margin-bottom: 0.625rem;
      background-color: #ffffff;
      position: relative;
      overflow: hidden;
      min-height: 3rem;
    }
    
    @media (min-width: 640px) {
      .option-label {
        padding: 1rem 1.25rem;
        margin-bottom: 0.75rem;
      }
    }
    
    .option-label::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: transparent;
      transition: all 0.2s ease;
    }

    .option-label:hover {
      background-color: #f8fafc;
      border-color: #94a3b8;
    }

    .option-label.selected {
      background: linear-gradient(to right, #eff6ff, #ffffff);
      border-color: #3b82f6;
    }
    
    .option-label.selected::before {
      background: linear-gradient(to bottom, #3b82f6, #2563eb);
    }

    /* Radio/Checkbox Input - Hidden, using option letters instead */
    .option-label input[type="radio"],
    .option-label input[type="checkbox"] {
      display: none;
    }

    /* Option Letter */
    .option-letter {
      flex-shrink: 0;
      width: 1.75rem;
      height: 1.75rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0.375rem;
      background: #f1f5f9;
      color: #64748b;
      font-weight: 600;
      font-size: 0.8125rem;
      margin-right: 0.875rem;
      transition: all 0.2s ease;
    }

    @media (min-width: 640px) {
      .option-letter {
        width: 2rem;
        height: 2rem;
        margin-right: 1rem;
        font-size: 0.875rem;
      }
    }

    .option-label.selected .option-letter {
      background: #3b82f6;
      color: white;
    }

    .option-content {
      flex: 1;
      text-align: left;
      line-height: 1.5;
      color: #334155;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      min-height: 1.5rem;
    }

    .option-content p {
      margin: 0;
    }
    
    .option-content .math-display {
      margin: 0;
      width: 100%;
    }
    
    /* Markdown rendering styles */
    .prose h1, .prose h2, .prose h3, .prose h4, .prose h5, .prose h6 {
      font-weight: 700;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      color: #1e293b;
    }
    
    .prose h3 { font-size: 1.25rem; }
    .prose h4 { font-size: 1.125rem; }
    
    .prose ul, .prose ol {
      margin: 1rem 0;
      padding-left: 1.5rem;
    }
    
    .prose ul { list-style-type: disc; }
    .prose ol { list-style-type: decimal; }
    
    .prose ul ul, .prose ol ol, .prose ul ol, .prose ol ul {
      margin: 0.5rem 0;
    }
    
    .prose ul ul { list-style-type: circle; }
    .prose ul ul ul { list-style-type: square; }
    
    .prose li {
      margin: 0.375rem 0;
      line-height: 1.6;
    }
    
    .prose strong { font-weight: 700; }
    .prose em { font-style: italic; }
    
    .prose code {
      background: #f1f5f9;
      padding: 0.125rem 0.375rem;
      border-radius: 0.25rem;
      font-size: 0.875em;
      font-family: ui-monospace, monospace;
    }
    
    .prose pre {
      background: #1e293b;
      color: #e2e8f0;
      padding: 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      margin: 1rem 0;
    }
    
    .prose pre code {
      background: none;
      padding: 0;
      color: inherit;
    }
    
    .prose blockquote {
      border-left: 4px solid #3b82f6;
      padding-left: 1rem;
      margin: 1rem 0;
      color: #64748b;
      font-style: italic;
    }
    
    .prose hr {
      border: none;
      border-top: 2px solid #e2e8f0;
      margin: 1.5rem 0;
    }
    
    .prose table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }
    
    .prose th, .prose td {
      border: 1px solid #e2e8f0;
      padding: 0.5rem 0.75rem;
      text-align: left;
    }
    
    .prose th {
      background: #f8fafc;
      font-weight: 600;
    }
    
    /* Question card styling */
    .question-card {
      background: #ffffff;
      border-radius: 1.25rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
      border: 1px solid #e2e8f0;
      overflow: hidden;
    }
    
    .question-header {
      background: #f8fafc;
      border-bottom: 1px solid #e2e8f0;
      padding: 1rem 1.5rem;
    }
    
    .question-body {
      padding: 2rem;
    }
    
    .question-text {
      font-size: 1.125rem;
      line-height: 1.8;
      color: #1e293b;
    }

    /* Fill-in-the-blank input styling */
    .fill-blank-wrapper {
      display: inline-block;
      vertical-align: middle;
      margin: 0 0.25rem;
    }

    .fill-blank-input {
      font-family: 'Courier New', 'Monaco', monospace;
      vertical-align: baseline;
    }

    .math-preview-inline {
      display: none;
      margin-top: 0.25rem;
      padding: 0.25rem 0.5rem;
      background-color: #f1f5f9;
      border: 1px solid #cbd5e1;
      border-radius: 0.375rem;
      font-size: 0.75rem;
      min-height: 1.25rem;
    }

    .math-preview-inline .math-inline {
      display: inline-block;
      vertical-align: baseline;
    }

    .math-preview-inline .katex {
      font-size: 0.875rem;
    }

    /* Question text with blanks - ensure inputs are inline but paragraphs are block */
    .question-text-with-blanks {
      line-height: 1.75;
    }

    .question-text-with-blanks p {
      display: block;
      margin: 0.5rem 0;
    }

    .question-text-with-blanks .fill-blank-wrapper {
      display: inline-block;
      vertical-align: middle;
    }

    /* MathLive styling for quiz-taking page */
    .fill-blank-math {
      font-size: 1rem;
      padding: 0.5rem 0.75rem;
      border: 2px solid #60a5fa;
      border-radius: 0.375rem;
      background: white;
      min-height: 2.5rem;
      min-width: 120px;
      display: inline-block;
      vertical-align: middle;
    }

    .fill-blank-math:focus,
    .fill-blank-math:focus-within {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
    }

    /* Ensure MathLive fields align properly with text */
    .question-text-with-blanks math-field {
      vertical-align: baseline;
    }
    
    /* Solution styling */
    .solution-panel {
      background: #f1f5f9;
      border: 2px solid #cbd5e1;
      border-radius: 1rem;
      margin-top: 1.5rem;
      overflow: hidden;
    }
    
    .solution-panel summary {
      padding: 1rem 1.5rem;
      font-weight: 600;
      color: #475569;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: background 0.2s;
    }
    
    .solution-panel summary:hover {
      background: rgba(203, 213, 225, 0.1);
    }
    
    .solution-panel[open] summary {
      border-bottom: 1px solid #cbd5e1;
    }
    
    .solution-content {
      padding: 1.5rem;
      color: #334155;
      line-height: 1.7;
    }
    
    /* Navigation buttons - Exact match with editor */
    .nav-btn {
      padding: 0.5rem 1rem;
      background: white;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      color: #374151;
      font-size: 0.875rem;
      transition: background-color 0.15s ease;
    }
    
    .nav-btn:hover:not(:disabled) {
      background: #f9fafb;
    }
    
    .nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .question-indicator {
      color: #374151;
      font-weight: 500;
      font-size: 0.875rem;
    }
  </style>

  <script>
    // Preload KaTeX CSS/JS immediately at page load (before quiz script)
    (function() {
      // Load KaTeX CSS once if not already loaded
      if (typeof window !== 'undefined' && !document.querySelector('link[href*="katex"]')) {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css';
        document.head.appendChild(link);
      }

      // Preload KaTeX JS immediately if not already loaded
      if (typeof window !== 'undefined' && !(window as any).katex) {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';
        script.async = false; // Load synchronously for faster availability
        document.head.appendChild(script);
      }
      
      // Load MathLive for math input
      if (typeof window !== 'undefined' && !(window as any).MathLive) {
        const mathliveLink = document.createElement('link');
        mathliveLink.rel = 'stylesheet';
        mathliveLink.href = 'https://cdn.jsdelivr.net/npm/mathlive@0.108.2/mathlive-static.css';
        document.head.appendChild(mathliveLink);
        
        const mathliveScript = document.createElement('script');
        mathliveScript.src = 'https://cdn.jsdelivr.net/npm/mathlive@0.108.2/mathlive.min.js';
        mathliveScript.defer = true;
        mathliveScript.onload = function() {
          // Configure MathLive to use correct base URL for sounds
          if ((window as any).MathLive && (window as any).MathLive.MathfieldElement) {
            (window as any).MathLive.MathfieldElement.soundsDirectory = 'https://cdn.jsdelivr.net/npm/mathlive@0.108.2/sounds';
          }
        };
        document.head.appendChild(mathliveScript);
      }
      
      // Load Nerdamer for symbolic math
      if (typeof window !== 'undefined' && !(window as any).nerdamer) {
        const nerdamerScripts = [
          'https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/nerdamer.core.js',
          'https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Algebra.js',
          'https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Calculus.js',
          'https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Solve.js'
        ];
        
        // Load scripts sequentially to ensure dependencies
        function loadScript(index: number) {
          if (index >= nerdamerScripts.length) return;
          
          const script = document.createElement('script');
          script.src = nerdamerScripts[index];
          script.onload = function() {
            // Wait a bit to ensure the script is fully initialized before loading next
            setTimeout(() => loadScript(index + 1), 100);
          };
          script.onerror = function() {
            console.warn('Failed to load Nerdamer script:', nerdamerScripts[index]);
            loadScript(index + 1); // Continue loading other scripts
          };
          document.head.appendChild(script);
        }
        
        loadScript(0);
      }
      
      // Make compareMathExpressions available globally for scoring
      // This is a simplified version that works in the browser
      (window as any).compareMathExpressions = function(userAnswer: string, correctAnswer: string, tolerance: number = 0.0001): boolean {
        if (!userAnswer || !correctAnswer) return false;
        
        const user = userAnswer.trim();
        const correct = correctAnswer.trim();
        
        // Exact string match (case-insensitive for text mode)
        if (user.toLowerCase() === correct.toLowerCase()) {
          return true;
        }
        
        // Try numeric comparison
        const userNum = parseFloat(user);
        const correctNum = parseFloat(correct);
        
        if (!isNaN(userNum) && !isNaN(correctNum)) {
          return Math.abs(userNum - correctNum) < tolerance;
        }
        
        // Try symbolic comparison using nerdamer if available
        if (typeof window !== 'undefined' && (window as any).nerdamer) {
          try {
            const nerdamer = (window as any).nerdamer;
            
            // Normalize expressions
            let userNorm = user;
            let correctNorm = correct;
            
            try {
              const userParsed = nerdamer(user);
              const correctParsed = nerdamer(correct);
              
              userNorm = userParsed.simplify().toString();
              correctNorm = correctParsed.simplify().toString();
              
              if (userNorm === correctNorm) {
                return true;
              }
              
              // Try checking if difference is zero
              const diff = nerdamer(`(${userNorm})-(${correctNorm})`);
              const simplified = diff.simplify();
              const diffValue = simplified.evaluate();
              const diffNum = parseFloat(diffValue.toString());
              
              if (!isNaN(diffNum) && Math.abs(diffNum) < tolerance) {
                return true;
              }
            } catch (e) {
              // Symbolic comparison failed, continue with other methods
            }
          } catch (e) {
            // Nerdamer not available or error
          }
        }
        
        // Handle special cases manually
        // e.g., "2*10^5" = "200000"
        const specialCases = [
          { pattern: /(\d+)\*10\^(\d+)/, handler: (match: RegExpMatchArray) => {
            const base = parseFloat(match[1]);
            const exp = parseFloat(match[2]);
            return (base * Math.pow(10, exp)).toString();
          }},
          { pattern: /(\d+)\/(\d+)/, handler: (match: RegExpMatchArray) => {
            const num = parseFloat(match[1]);
            const den = parseFloat(match[2]);
            if (den !== 0) {
              return (num / den).toString();
            }
            return null;
          }},
        ];
        
        for (const { pattern, handler } of specialCases) {
          const userMatch = user.match(pattern);
          const correctMatch = correct.match(pattern);
          
          if (userMatch && correctMatch) {
            const userConverted = handler(userMatch);
            const correctConverted = handler(correctMatch);
            
            if (userConverted && correctConverted) {
              const userNum = parseFloat(userConverted);
              const correctNum = parseFloat(correctConverted);
              
              if (!isNaN(userNum) && !isNaN(correctNum)) {
                if (Math.abs(userNum - correctNum) < tolerance) {
                  return true;
                }
              }
            }
          }
        }
        
        return false;
      };

      // Create renderLatex function that will be available when quiz script runs
      (window as any).renderLatex = function() {
        if (!(window as any).katex) {
          // KaTeX not loaded yet, wait a bit and try again
          setTimeout(() => {
            if ((window as any).katex) {
              (window as any).renderLatex();
            }
          }, 10);
          return;
        }

        const mathElements = document.querySelectorAll('.math-display, .math-inline');
        mathElements.forEach((element) => {
          // Skip if already rendered (has katex class)
          if (element.querySelector('.katex')) {
            return;
          }

          const latex = element.getAttribute('data-latex') || '';
          if (!latex) return;

          const displayMode = element.classList.contains('math-display');
          
          try {
            // Clear element first to ensure clean render
            element.innerHTML = '';
            (window as any).katex.render(latex, element, {
              displayMode,
              throwOnError: false,
              trust: true,
              macros: {
                '\\degree': '^{\\circ}'
              }
            });
          } catch (err) {
            console.warn('KaTeX render error:', err);
            element.innerHTML = `<span class="latex-error">LaTeX Error</span>`;
          }
        });
      };
    })();
  </script>

  <!-- Load marked.js for markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  
  <script define:vars={{ quiz: clientQuiz, id }}>
    console.log('=== QUIZ SCRIPT STARTED ===');
    console.log('Quiz data:', quiz);
    console.log('Quiz ID:', id);
    
    // #region agent log
    try {
      fetch('http://127.0.0.1:7242/ingest/9b3c54a2-2c4a-417f-b085-4ef9df059af2',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'quizzes/[id]/start.astro:1162',message:'Script started',data:{hasQuiz:!!quiz,quizId:quiz?.id,quizTitle:quiz?.title,questionsLength:quiz?.questions?.length,readyState:document.readyState},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    } catch(e) {
      console.error('Log error:', e);
    }
    // #endregion
    
    // Guard: Check if quiz data is available
    if (!quiz) {
      console.error('ERROR: Quiz data is not available!');
      document.getElementById('question-container')?.insertAdjacentHTML('beforeend', '<div class="p-4 bg-red-50 border border-red-200 rounded-lg"><p class="text-red-700 font-semibold">Error: Quiz data tidak tersedia. Silakan refresh halaman.</p></div>');
      throw new Error('Quiz data is null or undefined');
    }
    
    if (!quiz.questions || !Array.isArray(quiz.questions)) {
      console.error('ERROR: Quiz questions are not available!', quiz);
      document.getElementById('question-container')?.insertAdjacentHTML('beforeend', '<div class="p-4 bg-red-50 border border-red-200 rounded-lg"><p class="text-red-700 font-semibold">Error: Data soal tidak tersedia. Silakan refresh halaman.</p></div>');
      throw new Error('Quiz questions are not available');
    }
    
    // Import unified markdown renderer
    // Note: In a real implementation, this would be bundled, but for now we'll inline the core logic
    // For production, consider bundling markdown-renderer/client.ts
    
    // Simplified client-side renderer using unified core logic
    // This is a temporary solution - ideally we'd bundle the client module
    function renderMarkdown(text) {
      if (!text) return '';
      
      // Load marked if not available
      if (!window.marked) {
        console.warn('marked.js not loaded');
        return text;
      }
      
      // Use the unified renderer pattern
      // For now, we'll use a simplified version that matches the core logic
      // TODO: Bundle markdown-renderer/client.ts for proper reuse
      
      // Normalize newlines
      let processed = text.replace(/\r\n?|\u2028|\u2029/g, '\n');
      
      // Process images with Pandoc-style attributes
      // Pattern: ![](image.png){width=300px class=diagram align=center}
      processed = processed.replace(/!\[([^\]]*)\]\(([^)]+)\)\{([^}]+)\}/g, (match, alt, src, attrs) => {
        // Parse attributes (supports key=value pairs, quoted values, etc.)
        const attrObj = {};
        let current = '';
        let inQuotes = false;
        let quoteChar = '';
        
        // Parse attribute string, handling quoted values
        for (let i = 0; i < attrs.length; i++) {
          const char = attrs[i];
          if ((char === '"' || char === "'") && !inQuotes) {
            inQuotes = true;
            quoteChar = char;
            current += char;
          } else if (char === quoteChar && inQuotes) {
            inQuotes = false;
            quoteChar = '';
            current += char;
          } else if (char === ' ' && !inQuotes) {
            if (current.trim()) {
              const [key, ...valueParts] = current.split('=');
              if (key && valueParts.length > 0) {
                let value = valueParts.join('=').trim();
                if ((value.startsWith('"') && value.endsWith('"')) ||
                    (value.startsWith("'") && value.endsWith("'"))) {
                  value = value.slice(1, -1);
                }
                attrObj[key.toLowerCase().trim()] = value;
              }
              current = '';
            }
          } else {
            current += char;
          }
        }
        
        // Process last token
        if (current.trim()) {
          const [key, ...valueParts] = current.split('=');
          if (key && valueParts.length > 0) {
            let value = valueParts.join('=').trim();
            if ((value.startsWith('"') && value.endsWith('"')) ||
                (value.startsWith("'") && value.endsWith("'"))) {
              value = value.slice(1, -1);
            }
            attrObj[key.toLowerCase().trim()] = value;
          }
        }
        
        // Build style attribute
        const styles = [];
        if (attrObj.width) styles.push(`width: ${escapeHtml(attrObj.width)}`);
        if (attrObj.height) styles.push(`height: ${escapeHtml(attrObj.height)}`);
        if (attrObj.scale) {
          const scale = parseFloat(attrObj.scale);
          if (!isNaN(scale) && scale !== 1) {
            styles.push(`transform: scale(${scale})`);
            if (!attrObj.width && !attrObj.height) {
              styles.push(`max-width: ${Math.round(scale * 100)}%`);
            }
          }
        }
        if (attrObj.align === 'left') {
          styles.push('float: left; margin-right: 1rem');
        } else if (attrObj.align === 'right') {
          styles.push('float: right; margin-left: 1rem');
        } else if (attrObj.align === 'center') {
          styles.push('display: block; margin-left: auto; margin-right: auto');
        }
        if (!styles.some(s => s.includes('max-width'))) styles.push('max-width: 100%');
        if (!attrObj.height && !styles.some(s => s.includes('height'))) styles.push('height: auto');
        if (attrObj.style) styles.push(attrObj.style);
        
        // Build img tag attributes
        const parts = [`src="${escapeHtml(src)}"`];
        if (alt) parts.push(`alt="${escapeHtml(alt)}"`);
        if (styles.length > 0) parts.push(`style="${styles.join('; ')}"`);
        if (attrObj.class) parts.push(`class="${escapeHtml(attrObj.class)}"`);
        if (attrObj.id) parts.push(`id="${escapeHtml(attrObj.id)}"`);
        
        return `<img ${parts.join(' ')} />`;
      });
      
      // Convert display math blocks ($$ ... $$) to placeholders
      processed = processed.replace(/\$\$([\s\S]*?)\$\$/g, (match, latex) => {
        const cleanLatex = (latex || '').trim();
        return `\n<div class="math-display" data-latex="${escapeHtml(cleanLatex)}"></div>\n`;
      });

      // Convert inline math $...$ to placeholders
      processed = processed.replace(/(?<!\$)\$([^$\n]+?)\$(?!\$)/g, (match, latex) => {
        const cleanLatex = (latex || '').trim();
        return `<span class="math-inline" data-latex="${escapeHtml(cleanLatex)}"></span>`;
      });

      // Use marked for full markdown parsing
      try {
        return window.marked.parse(processed);
      } catch (e) {
        console.error('Markdown parsing error:', e);
        return processed;
      }
    }
    
    function escapeHtml(text) {
      if (!text) return '';
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }
    
    // Convert natural math expression to LaTeX (Perseus-style)
    function convertMathToLatex(input) {
      if (!input || typeof input !== 'string') return '';
      
      let result = input.trim();
      
      // Replace * with \cdot for multiplication
      result = result.replace(/(\d+|[a-zA-Z\)])\s*\*\s*(\d+|[a-zA-Z\(])/g, (match, p1, p2) => {
        if (match.includes('**')) return match; // Don't replace **
        return p1 + '\\cdot' + p2;
      });
      
      // Handle ^ for exponents
      result = result.replace(/\^(\d+)/g, '^{$1}');
      result = result.replace(/\^\(([^)]+)\)/g, '^{$1}');
      result = result.replace(/([a-zA-Z])\^(\d+)/g, '$1^{$2}');
      
      // Handle fractions: a/b -> \frac{a}{b}
      result = result.replace(/(\d+|[a-zA-Z]+)\s*\/\s*(\d+|[a-zA-Z]+)/g, (match, num, den) => {
        if (/\d+\/\d+\/\d+/.test(match)) return match; // Don't convert dates
        return '\\frac{' + num + '}{' + den + '}';
      });
      
      // Handle sqrt
      result = result.replace(/sqrt\s*\(([^)]+)\)/gi, '\\sqrt{$1}');
      
      // Handle common functions
      result = result.replace(/\b(sin|cos|tan|log|ln|exp)\s*\(/gi, '\\$1(');
      
      // Handle pi
      result = result.replace(/\bpi\b/gi, '\\pi');
      
      return result;
    }
    
    // Simple LaTeX-only processor (legacy compatibility)
    function processLatex(text) {
      return renderMarkdown(text);
    }

    // Quiz state
    const PROGRESS_KEY = `quiz_progress_${id}`;
    const QUEUE_KEY = `quiz_queue_${id}`;
    const arrowLeftSvg = '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>';
    const arrowRightSvg = '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>';
    const availableFromTs = quiz.availableFrom ? new Date(quiz.availableFrom).getTime() : null;
    const availableUntilTs = quiz.availableUntil ? new Date(quiz.availableUntil).getTime() : null;
    const openDurationSeconds = quiz.openDurationSeconds || 0;
    let currentQuestionIndex = 0;
    let answers = new Array(quiz.questions.length).fill(null);
    let flaggedQuestions = new Set();
    let startTime = Date.now();
    let openStartedAt = Date.now();
    let timerInterval = null;
    let animationFrameId = null;
    const totalTimeLimit = quiz.settings?.timeLimit || 0;
    let quizSubmitted = false;
    let hasStarted = false;
    
    // Track active time spent (not total elapsed time)
    let activeTimeSpent = 0;
    let lastActivityTime = Date.now();

    // Load saved progress
    function loadProgress() {
      try {
        const saved = localStorage.getItem(PROGRESS_KEY);
        if (saved) {
          const progress = JSON.parse(saved);
          // Ensure answers array is properly initialized
          const loadedAnswers = progress.answers || answers;
          // For fill-in-the-blank questions, ensure arrays are properly sized
          if (Array.isArray(loadedAnswers)) {
            loadedAnswers.forEach((answer, qIdx) => {
              const question = quiz.questions[qIdx];
              if (question && question.type === 'fill-in-the-blank' && Array.isArray(answer)) {
                // Ensure the array is large enough for all blank indices
                const blanks = question.blanks || [];
                if (blanks.length > 0) {
                  const maxBlankIndex = Math.max(...blanks.map(b => b.index !== undefined ? b.index : 0));
                  while (answer.length <= maxBlankIndex) {
                    answer.push('');
                  }
                }
              }
            });
          }
          answers = loadedAnswers;
          flaggedQuestions = new Set(progress.flaggedQuestions || []);
          currentQuestionIndex = progress.currentQuestionIndex || 0;
          startTime = progress.startTime || startTime;
          openStartedAt = progress.openStartedAt || openStartedAt;
          hasStarted = progress.hasStarted || false;
          
          // Load active time tracking
          activeTimeSpent = progress.activeTimeSpent || 0;
          lastActivityTime = progress.lastActivityTime || Date.now();
          
          // Restore timer state
          if (quiz.settings?.timeLimit) {
            if (progress.timerEndAt) {
              // Use timestamp-based timer (preferred)
              timerEndAt = progress.timerEndAt;
              const now = Date.now();
              remainingTime = Math.max(0, Math.floor((timerEndAt - now) / 1000));
            } else if (progress.remainingTime !== undefined) {
              // Resume timer even if tab was closed: subtract elapsed since last save
              const elapsedSinceSave = Math.floor((Date.now() - (progress.savedAt || Date.now())) / 1000);
              remainingTime = Math.max(0, progress.remainingTime - elapsedSinceSave);
              timerEndAt = Date.now() + (remainingTime * 1000);
            } else if (progress.startTime) {
              // Calculate from start time (legacy support)
              const elapsed = Math.floor((Date.now() - progress.startTime) / 1000);
              remainingTime = Math.max(0, quiz.settings.timeLimit - elapsed);
              timerEndAt = Date.now() + (remainingTime * 1000);
            }
          }
          
          console.log('Progress loaded:', progress);
          return true;
        }
      } catch (error) {
        console.error('Error loading progress:', error);
      }
      return false;
    }

    // Save progress
    function saveProgress() {
      try {
        const existingRaw = localStorage.getItem(QUEUE_KEY);
        const existing = existingRaw ? JSON.parse(existingRaw) : null;
        
        // Recalculate remainingTime from timerEndAt if available
        let currentRemaining = remainingTime;
        if (timerEndAt) {
          currentRemaining = Math.max(0, Math.floor((timerEndAt - Date.now()) / 1000));
        }
        
        const progress = {
          answers,
          flaggedQuestions: Array.from(flaggedQuestions),
          currentQuestionIndex,
          remainingTime: quiz.settings?.timeLimit ? currentRemaining : undefined,
          timerEndAt: timerEndAt || null,
          startTime: startTime,
          openStartedAt,
          hasStarted,
          activeTimeSpent,
          lastActivityTime,
          savedAt: Date.now()
        };
        localStorage.setItem(PROGRESS_KEY, JSON.stringify(progress));
        
        // Queue entry with timestamp-based timer (Drift Fix)
        const queueEntry = {
          quizId: parseInt(id),
          title: quiz.title,
          quizType: quiz.quizType,
          scoreReleaseMode: quiz.scoreReleaseMode || 'immediate',
          remainingTime: quiz.settings?.timeLimit ? currentRemaining : 0,
          timerEndAt: timerEndAt || null,
          availableUntil: quiz.availableUntil || null,
          url: `/quizzes/${id}`,
          savedAt: Date.now(),
          status: 'active',
          attemptId: existing?.attemptId || null
        };
        
        // Always save active quizzes to queue
        localStorage.setItem(QUEUE_KEY, JSON.stringify(queueEntry));
      } catch (error) {
        console.error('Error saving progress:', error);
      }
    }

    // Update active time spent based on user activity
    function updateActiveTime() {
      const now = Date.now();
      const timeSinceLastActivity = Math.floor((now - lastActivityTime) / 1000);
      
      // Only count time if user has been actively working (within reasonable time frame)
      // This prevents counting long periods of inactivity (e.g., user left browser open)
      if (timeSinceLastActivity <= 300) { // 5 minutes threshold for activity
        activeTimeSpent += timeSinceLastActivity;
      }
      
      lastActivityTime = now;
      return activeTimeSpent;
    }

    // Clear progress
    function clearProgress() {
      try {
        localStorage.removeItem(PROGRESS_KEY);
      } catch (error) {
        console.error('Error clearing progress:', error);
      }
    }

    function enableLeaveConfirm() {
      window.addEventListener('beforeunload', beforeUnloadHandler);
    }

    function disableLeaveConfirm() {
      window.removeEventListener('beforeunload', beforeUnloadHandler);
    }

    function beforeUnloadHandler(event) {
      if (quizSubmitted) return;
      event.preventDefault();
      const message = 'Anda yakin ingin meninggalkan halaman kuis? Progres belum dikirim.';
      event.returnValue = message;
      return message;
    }

    // Helper: format seconds to HH:MM:SS
    function formatTime(totalSeconds) {
      const safe = Math.max(0, Math.floor(totalSeconds));
      const hours = Math.floor(safe / 3600);
      const minutes = Math.floor((safe % 3600) / 60);
      const seconds = safe % 60;
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds
        .toString()
        .padStart(2, '0')}`;
    }

    // Finish confirmation overlay (non-blocking)
    let finishModal = null;
    let finishModalTimerEl = null;
    let finishModalMessageEl = null;
    function ensureFinishModal() {
      if (finishModal) return;
      const overlay = document.createElement('div');
      overlay.id = 'finish-confirm-overlay';
      overlay.className = 'fixed inset-0 z-50 hidden opacity-0 transition-opacity';
      overlay.innerHTML = `
        <div class="absolute inset-0 bg-slate-900/50 backdrop-blur-sm"></div>
        <div class="absolute inset-0 flex items-center justify-center px-4">
          <div class="max-w-md w-full bg-white border border-slate-200 shadow-2xl rounded-2xl p-6 space-y-4">
            <div class="flex items-start gap-3">
              <div class="flex h-10 w-10 items-center justify-center rounded-full bg-amber-50 text-amber-600 border border-amber-100">
                <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" d="M12 9v3m0 4h.01M4.93 4.93a10.5 10.5 0 1114.84 14.84A10.5 10.5 0 014.93 4.93z" />
                </svg>
              </div>
              <div class="space-y-1">
                <p class="text-sm font-semibold text-slate-900">Kirim jawaban sekarang?</p>
                <p id="finish-modal-message" class="text-sm text-slate-600"></p>
                <p class="text-xs font-semibold text-amber-700 inline-flex items-center gap-2 bg-amber-50 px-2.5 py-1 rounded-full border border-amber-100">
                  <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" d="M12 8v4l2 2m5-2a7 7 0 11-14 0 7 7 0 0114 0z" />
                  </svg>
                  Sisa waktu: <span id="finish-modal-timer"></span>
                </p>
              </div>
            </div>
            <div class="flex items-center justify-end gap-3">
              <button id="finish-modal-cancel" type="button" class="px-4 py-2 rounded-lg border border-slate-200 text-slate-700 hover:bg-slate-50">Kembali</button>
              <button id="finish-modal-confirm" type="button" class="px-4 py-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700 shadow-sm">Kirim</button>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(overlay);
      finishModal = overlay;
      finishModalTimerEl = overlay.querySelector('#finish-modal-timer');
      finishModalMessageEl = overlay.querySelector('#finish-modal-message');
      const cancelBtn = overlay.querySelector('#finish-modal-cancel');
      const confirmBtn = overlay.querySelector('#finish-modal-confirm');
      cancelBtn?.addEventListener('click', hideFinishModal);
      confirmBtn?.addEventListener('click', () => {
        hideFinishModal();
        submitQuiz('manual');
      });
    }

    function showFinishModal(unansweredCount) {
      ensureFinishModal();
      if (finishModalMessageEl) {
        finishModalMessageEl.textContent =
          unansweredCount > 0
            ? `Anda memiliki ${unansweredCount} soal yang belum dijawab.`
            : 'Semua soal sudah terjawab. Kirim sekarang?';
      }
      updateFinishModalTimer();
      if (finishModal) {
        finishModal.classList.remove('hidden');
        requestAnimationFrame(() => finishModal?.classList.remove('opacity-0'));
      }
    }

    function hideFinishModal() {
      if (!finishModal) return;
      finishModal.classList.add('opacity-0');
      setTimeout(() => finishModal?.classList.add('hidden'), 150);
    }

    function updateFinishModalTimer() {
      if (finishModalTimerEl) {
        finishModalTimerEl.textContent = formatTime(remainingTime);
      }
    }

    // Initialize timer variables
    let remainingTime = quiz.settings?.timeLimit || 0;
    let timerEndAt = null; // Timestamp when timer should reach zero
    
    // Load progress first
    const hasProgress = loadProgress();

    // If no saved progress, use full time limit
    if (!hasProgress && quiz.settings?.timeLimit) {
      remainingTime = quiz.settings.timeLimit;
      timerEndAt = Date.now() + (remainingTime * 1000);
    } else if (hasProgress && quiz.settings?.timeLimit) {
      // Restore timerEndAt from saved progress or calculate from remainingTime
      const saved = JSON.parse(localStorage.getItem(PROGRESS_KEY) || '{}');
      if (saved.timerEndAt) {
        timerEndAt = saved.timerEndAt;
      } else if (remainingTime > 0) {
        timerEndAt = Date.now() + (remainingTime * 1000);
      }
    }

    // Apply open duration window (per-open)
    if (openDurationSeconds > 0) {
      if (!hasProgress) {
        openStartedAt = Date.now();
      }
      const elapsedSinceOpen = Math.floor((Date.now() - openStartedAt) / 1000);
      const openRemaining = Math.max(0, openDurationSeconds - elapsedSinceOpen);
      const timeLimitRemaining = remainingTime;
      remainingTime = timeLimitRemaining ? Math.min(timeLimitRemaining, openRemaining) : openRemaining;
      
      // Adjust timerEndAt to respect the earlier of time limit or open duration
      if (timerEndAt && openDurationSeconds > 0) {
        const openEndAt = openStartedAt + (openDurationSeconds * 1000);
        timerEndAt = Math.min(timerEndAt, openEndAt);
      } else if (openDurationSeconds > 0 && !timerEndAt) {
        timerEndAt = openStartedAt + (openRemaining * 1000);
      }
    }

    function renderLockedState(title, message) {
      const root = document.querySelector('.min-h-screen');
      if (!root) return;
      root.innerHTML = `
        <div class="min-h-screen bg-slate-50 flex items-center justify-center px-4 py-12">
          <div class="max-w-lg w-full bg-white border border-slate-200 shadow-sm rounded-2xl p-8 text-center space-y-4">
            <div class="mx-auto flex h-16 w-16 items-center justify-center rounded-full bg-amber-50 text-amber-600">
              <svg class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" d="M12 9v4l2.5 1.5" />
                <circle cx="12" cy="12" r="9" stroke-width="1.8" />
              </svg>
            </div>
            <h2 class="text-xl font-bold text-slate-900">${title}</h2>
            <p class="text-sm text-slate-600">${message}</p>
            <a href="/quizzes" class="inline-flex items-center justify-center gap-2 px-4 py-2 rounded-lg border border-slate-300 text-slate-700 hover:bg-slate-50 text-sm font-semibold">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
              </svg>
              Kembali ke daftar kuis
            </a>
          </div>
        </div>
      `;
    }

    // Timer initialization function (to be called after DOM is ready)
    function initializeTimer() {
      // Initialize timer if time limit exists
      if (quiz.settings?.timeLimit) {
        // Ensure timerEndAt is set
        if (!timerEndAt && remainingTime > 0) {
          timerEndAt = Date.now() + (remainingTime * 1000);
        }
        
        // If already expired while away, submit immediately
        if (timerEndAt && Date.now() >= timerEndAt) {
          remainingTime = 0;
          submitQuiz('time_up');
          return;
        }
        
        // Update display immediately
        const updateTimerDisplay = () => {
          // Calculate remaining time from timestamp for accuracy
          if (timerEndAt) {
            const now = Date.now();
            remainingTime = Math.max(0, Math.floor((timerEndAt - now) / 1000));
          }
          
          const timerDisplay = document.getElementById('timer-display');
          const timerWrapper = document.getElementById('timer');
          if (timerDisplay) {
            timerDisplay.textContent = formatTime(remainingTime);
          }
          if (timerWrapper && totalTimeLimit > 0) {
            const critical = remainingTime <= 60 || remainingTime <= Math.ceil(totalTimeLimit * 0.1);
            timerWrapper.classList.toggle('bg-rose-50', critical);
            timerWrapper.classList.toggle('border-rose-200', critical);
            timerWrapper.classList.toggle('bg-slate-50', !critical);
            timerWrapper.classList.toggle('border-slate-200', !critical);
            timerDisplay?.classList.toggle('text-rose-700', critical);
            timerDisplay?.classList.toggle('text-slate-800', !critical);
          }
          updateFinishModalTimer();
        };
        
        updateTimerDisplay();

        // Use requestAnimationFrame for smoother updates, fallback to setInterval
        let lastSaveTime = Date.now();
        let localAnimationFrameId = null;
        
        const tick = () => {
          if (!timerEndAt) {
            timerInterval = setInterval(tick, 1000);
            return;
          }
          
          const now = Date.now();
          
          // Update active time periodically (every minute)
          if (now - lastSaveTime >= 60000) {
            updateActiveTime();
            saveProgress();
            lastSaveTime = now;
          }
          
          // Check if expired
          if (now >= timerEndAt) {
            remainingTime = 0;
            updateTimerDisplay();
            if (localAnimationFrameId && typeof cancelAnimationFrame !== 'undefined') {
              cancelAnimationFrame(localAnimationFrameId);
            }
            if (timerInterval) {
              clearInterval(timerInterval);
              timerInterval = null;
            }
            submitQuiz('time_up');
            return;
          }
          
          // Update display every frame for smoothness
          updateTimerDisplay();
          
          // Save progress every ~10 seconds
          if (now - lastSaveTime >= 10000) {
            saveProgress();
            lastSaveTime = now;
          }
          
          // Use requestAnimationFrame for smooth updates (typically ~60fps)
          // This ensures the timer updates smoothly even if the interval is delayed
          if (typeof requestAnimationFrame !== 'undefined') {
            localAnimationFrameId = requestAnimationFrame(tick);
            animationFrameId = localAnimationFrameId; // Store in outer scope for cleanup
          } else {
            // Fallback to setInterval if requestAnimationFrame not available
            timerInterval = setInterval(tick, 100);
          }
        };
        
        // Start with requestAnimationFrame for smooth updates
        if (typeof requestAnimationFrame !== 'undefined') {
          localAnimationFrameId = requestAnimationFrame(tick);
          animationFrameId = localAnimationFrameId;
        } else {
          timerInterval = setInterval(tick, 1000);
        }
      } else {
        const timerElement = document.getElementById('timer');
        if (timerElement) {
          timerElement.style.display = 'none';
        }
      }
    }

    // Render question grid
    function renderQuestionGrid() {
      console.log('renderQuestionGrid called');
      
      // Helper function to check if a question is answered
      function isQuestionAnswered(index) {
        const answer = answers[index];
        const question = quiz.questions[index];
        
        if (question?.type === 'fill-in-the-blank') {
          return Array.isArray(answer) && answer.some(a => a && a.trim() !== '');
        } else if (question?.type === 'essay') {
          return answer && typeof answer === 'string' && answer.trim() !== '';
        } else {
          return answer !== null;
        }
      }
      const grid = document.getElementById('question-grid');
      
      if (!grid) {
        console.error('question-grid element not found!');
        return;
      }
      
      grid.innerHTML = '';
      
      quiz.questions.forEach((_, index) => {
        const btn = document.createElement('button');
        btn.textContent = index + 1;
        
        // Build class list
        const classes = ['question-number'];
        
        const isFlagged = flaggedQuestions.has(index);
        const isAnswered = isQuestionAnswered(index);
        
        // Add status class (current takes precedence)
        if (index === currentQuestionIndex) {
          classes.push('current');
        } else if (isFlagged && isAnswered) {
          // Flagged AND answered - darker orange
          classes.push('flagged-answered');
        } else if (isFlagged) {
          // Flagged but NOT answered - lighter orange/yellow
          classes.push('flagged');
        } else if (isAnswered) {
          // Answered only - green
          classes.push('answered');
        } else {
          // Not answered - gray
          classes.push('unanswered');
        }
        
        btn.className = classes.join(' ');
        btn.onclick = () => goToQuestion(index);
        grid.appendChild(btn);
      });

      updateCounts();
    }

    // Update status counts
    function updateCounts() {
      let answered = 0;
      let flaggedCount = 0;
      let unanswered = 0;

      answers.forEach((answer, index) => {
        const question = quiz.questions[index];
        const isFlagged = flaggedQuestions.has(index);
        
        // Check if answered based on question type
        let isAnswered = false;
        if (question?.type === 'fill-in-the-blank') {
          // For fill-in-the-blank, check if array has any non-empty answers
          isAnswered = Array.isArray(answer) && answer.some(a => a && a.trim() !== '');
        } else if (question?.type === 'essay') {
          // For essay, check if string is non-empty or object has answer/files
          if (typeof answer === 'string') {
            isAnswered = answer.trim() !== '';
          } else if (answer && typeof answer === 'object') {
            isAnswered = (answer.answer && answer.answer.trim() !== '') || (Array.isArray(answer.files) && answer.files.length > 0);
          }
        } else {
          // For multiple choice, check if not null
          isAnswered = answer !== null;
        }

        if (isFlagged) {
          // Flagged should be counted as ragu-ragu (even if answered)
          flaggedCount++;
        }

        if (isAnswered) {
          // Answered counts regardless of flag state
          answered++;
        }

        if (!isAnswered) {
          // Only unanswered when no answer (flagged unanswered stays unanswered too)
          unanswered++;
        }
      });

      const answeredEl = document.getElementById('answered-count');
      const flaggedEl = document.getElementById('flagged-count');
      const unansweredEl = document.getElementById('unanswered-count');
      
      if (answeredEl) answeredEl.textContent = answered;
      if (flaggedEl) flaggedEl.textContent = flaggedCount;
      if (unansweredEl) unansweredEl.textContent = unanswered;
    }
    
    // Alias for compatibility
    const updateStats = updateCounts;

    // File upload handler function (defined before renderQuestion so it's available)
    async function handleFileUpload(file, questionIndex, uploadedFilesContainer) {
      // Validate file type
      const question = quiz.questions[questionIndex];
      
      // Check if file upload is enabled
      if (!question.allowFileUpload) {
        alert('Unggah file tidak diaktifkan untuk soal ini.');
        return;
      }
      
      // Handle both string format (from editor: 'all', 'images', 'pdf') and array format
      let allowedTypes = question.allowedFileTypes || [];
      if (typeof allowedTypes === 'string') {
        // Convert string format to array format for easier checking
        if (allowedTypes === 'all') {
          allowedTypes = ['images', 'pdf', 'text'];
        } else if (allowedTypes === 'images') {
          allowedTypes = ['images'];
        } else if (allowedTypes === 'pdf') {
          allowedTypes = ['pdf'];
        } else {
          allowedTypes = [];
        }
      }
      
      // If no file types are specified, allow all by default
      if (allowedTypes.length === 0) {
        console.warn('No allowedFileTypes specified, allowing all file types');
        allowedTypes = ['images', 'pdf', 'text']; // Default to all
      }
      
      const isImage = /\.(jpg|jpeg|png|gif|webp|svg)$/i.test(file.name);
      const isPDF = /\.pdf$/i.test(file.name);
      const isText = /\.txt$/i.test(file.name);
      
      const hasImages = allowedTypes.includes('images') || allowedTypes.includes('image');
      const hasPDF = allowedTypes.includes('pdf');
      const hasText = allowedTypes.includes('text');
      
      // If no specific types are configured, allow all
      const allowAll = allowedTypes.length === 0;
      
      // Build allowed file types list for error message
      const allowedList = [];
      if (allowAll || hasImages) allowedList.push('Gambar (JPG, PNG, GIF, WebP, SVG)');
      if (allowAll || hasPDF) allowedList.push('PDF');
      if (allowAll || hasText) allowedList.push('Teks (TXT)');
      
      // Check if file type is allowed
      // If allowAll is true, allow any file type
      // Otherwise, check if the file type matches one of the allowed types
      const isAllowed = allowAll || (isImage && hasImages) || (isPDF && hasPDF) || (isText && hasText);
      
      console.log('File upload validation:', {
        fileName: file.name,
        isImage,
        isPDF,
        isText,
        allowedTypes,
        allowAll,
        hasImages,
        hasPDF,
        hasText,
        isAllowed
      });
      
      if (!isAllowed) {
        const allowedTypesStr = allowedList.length > 0 
          ? allowedList.join(', ') 
          : 'Tidak ada jenis file yang diizinkan. Silakan hubungi administrator.';
        alert(`Jenis file tidak diizinkan.\n\nFile yang diizinkan: ${allowedTypesStr}\n\nFile yang Anda coba unggah: ${file.name}`);
        return;
      }
      
      // Validate file size
      const maxSize = isPDF ? 20 * 1024 * 1024 : 10 * 1024 * 1024;
      if (file.size > maxSize) {
        alert(`File terlalu besar. Ukuran maksimum: ${(maxSize / 1024 / 1024).toFixed(0)}MB`);
        return;
      }
      
      // Create form data
      const formData = new FormData();
      formData.append('file', file);
      formData.append('quizId', id);
      formData.append('questionIndex', questionIndex.toString());
      
      // Create unique ID for this upload
      const uploadId = `upload-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      // Show progress bar immediately
      if (uploadedFilesContainer) {
        const progressHtml = `
          <div class="essay-upload-progress" data-upload-id="${uploadId}">
            <div class="flex items-center gap-3 p-2 bg-blue-50 rounded border border-blue-200">
              <div class="flex-1 min-w-0">
                <div class="text-sm font-medium text-blue-700 truncate">Mengunggah: ${escapeHtml(file.name)}</div>
                <div class="w-full bg-blue-200 rounded-full h-2 mt-1">
                  <div class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%" data-progress-bar="${uploadId}"></div>
                </div>
                <div class="text-xs text-blue-600 mt-1" data-progress-text="${uploadId}">0%</div>
              </div>
            </div>
          </div>
        `;
        uploadedFilesContainer.insertAdjacentHTML('beforeend', progressHtml);
      }
      
      // Use XMLHttpRequest for progress tracking
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        
        // Track upload progress
        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            const percentComplete = Math.round((e.loaded / e.total) * 100);
            const progressBar = document.querySelector(`[data-progress-bar="${uploadId}"]`);
            const progressText = document.querySelector(`[data-progress-text="${uploadId}"]`);
            
            if (progressBar) {
              progressBar.style.width = `${percentComplete}%`;
            }
            if (progressText) {
              progressText.textContent = `${percentComplete}%`;
            }
          }
        });
        
        // Handle successful upload
        xhr.addEventListener('load', () => {
          if (xhr.status >= 200 && xhr.status < 300) {
            try {
              const result = JSON.parse(xhr.responseText);
              
              // Remove progress bar
              const progressElement = document.querySelector(`[data-upload-id="${uploadId}"]`);
              if (progressElement) {
                progressElement.remove();
              }
              
              // Check if API returned files array
              if (result.files && Array.isArray(result.files) && result.files.length > 0) {
                const uploadedFile = result.files[0];
                
                // Initialize answer structure if needed
                if (typeof answers[questionIndex] === 'string') {
                  answers[questionIndex] = {
                    answer: answers[questionIndex],
                    files: []
                  };
                } else if (!answers[questionIndex] || typeof answers[questionIndex] !== 'object') {
                  answers[questionIndex] = {
                    answer: '',
                    files: []
                  };
                }
                
                // Add file to answers
                if (!answers[questionIndex].files) {
                  answers[questionIndex].files = [];
                }
                
                // Store file with correct filename (use API response or fallback to original file.name)
                answers[questionIndex].files.push({
                  url: uploadedFile.url,
                  filename: uploadedFile.filename || file.name,
                  name: file.name, // Store original filename as fallback
                  size: uploadedFile.size || file.size,
                  type: uploadedFile.type || file.type
                });
                
                // Save progress
                saveProgress();
                renderQuestion();
                renderQuestionGrid();
                updateStats();
                
                resolve(uploadedFile);
              } else {
                throw new Error('Invalid response format from server');
              }
            } catch (error) {
              console.error('File upload error:', error);
              // Show error state
              const progressElement = document.querySelector(`[data-upload-id="${uploadId}"]`);
              if (progressElement) {
                progressElement.innerHTML = `
                  <div class="flex items-center gap-3 p-2 bg-red-50 rounded border border-red-200">
                    <svg class="w-5 h-5 text-red-600 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                    <div class="text-sm font-medium text-red-700">Gagal: ${escapeHtml(error.message || 'Terjadi kesalahan')}</div>
                  </div>
                `;
              }
              reject(error);
            }
          } else {
            // Handle HTTP error
            let errorMessage = 'Upload gagal';
            try {
              const error = JSON.parse(xhr.responseText);
              errorMessage = error.error || errorMessage;
            } catch (e) {
              errorMessage = `HTTP ${xhr.status}: ${xhr.statusText}`;
            }
            
            // Show error state
            const progressElement = document.querySelector(`[data-upload-id="${uploadId}"]`);
            if (progressElement) {
              progressElement.innerHTML = `
                <div class="flex items-center gap-3 p-2 bg-red-50 rounded border border-red-200">
                  <svg class="w-5 h-5 text-red-600 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                  </svg>
                  <div class="text-sm font-medium text-red-700">Gagal: ${escapeHtml(errorMessage)}</div>
                </div>
              `;
            }
            reject(new Error(errorMessage));
          }
        });
        
        // Handle network errors
        xhr.addEventListener('error', () => {
          const progressElement = document.querySelector(`[data-upload-id="${uploadId}"]`);
          if (progressElement) {
            progressElement.innerHTML = `
              <div class="flex items-center gap-3 p-2 bg-red-50 rounded border border-red-200">
                <svg class="w-5 h-5 text-red-600 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
                <div class="text-sm font-medium text-red-700">Gagal: Koneksi terputus</div>
              </div>
            `;
          }
          reject(new Error('Network error'));
        });
        
        // Send request
        xhr.open('POST', '/api/quiz/essay/upload');
        xhr.send(formData);
      });
    }

    // Render current question
    function renderQuestion() {
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/9b3c54a2-2c4a-417f-b085-4ef9df059af2',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'quizzes/[id]/start.astro:1899',message:'renderQuestion called',data:{currentQuestionIndex,hasQuiz:!!quiz,questionsLength:quiz?.questions?.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
      
      console.log('renderQuestion called, currentQuestionIndex:', currentQuestionIndex);
      
      const question = quiz.questions[currentQuestionIndex];
      const container = document.getElementById('question-container');
      const navContainer = document.getElementById('nav-container');
      
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/9b3c54a2-2c4a-417f-b085-4ef9df059af2',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'quizzes/[id]/start.astro:1905',message:'After getting question and containers',data:{hasQuestion:!!question,questionType:question?.type,hasContainer:!!container,hasNavContainer:!!navContainer},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
      
      if (!container) {
        console.error('question-container not found!');
        return;
      }
      
      if (!navContainer) {
        console.error('nav-container not found!');
        return;
      }
      
      console.log('Both containers found, rendering...');
      
      const isComplex = question.type === 'complex-multiple-choice' || question.type === 'complex';
      const inputType = isComplex ? 'checkbox' : 'radio';
      
      // Handle different question types
      let optionsHtml = '';
      let fillInBlanksHtml = '';
      let essayHtml = '';
      let questionHtml = '';
      
      if (question.type === 'fill-in-the-blank') {
        // Render fill-in-the-blank inputs
        const template = question.questionTemplate || question.question || '';
        const blanks = question.blanks || [];
        const userAnswers = answers[currentQuestionIndex] || [];
        const userAnswersArray = Array.isArray(userAnswers) ? userAnswers : [];
        
        if (!template) {
          console.error('Fill-in-the-blank template is empty for question:', currentQuestionIndex);
          questionHtml = '<p class="text-red-500">Error: Question template is missing</p>';
          fillInBlanksHtml = '';
        } else {
          // Extract all placeholders from template (e.g., {0}, {1}, etc.)
          const placeholderRegex = /\{(\d+)\}/g;
          const foundPlaceholders = new Set();
          let match;
          // Reset regex lastIndex
          placeholderRegex.lastIndex = 0;
          while ((match = placeholderRegex.exec(template)) !== null) {
            foundPlaceholders.add(parseInt(match[1]));
          }
          
          // Sort blanks by index to ensure correct order
          const sortedBlanks = [...blanks].sort((a, b) => a.index - b.index);
          
          // If no blanks defined but placeholders exist, create blanks for them
          const blanksToUse = sortedBlanks.length > 0 
            ? sortedBlanks 
            : Array.from(foundPlaceholders).sort((a, b) => a - b).map((index) => ({ 
                index, 
                correctAnswers: []
              }));
          
          // Process markdown/LaTeX normally - don't mess with the rendering
          // Markdown will handle newlines correctly (double newlines = paragraphs)
          let processedHtml = processLatex(template);
          
          // Fallback: if processedHtml is still empty, use the template directly
          if (!processedHtml || !processedHtml.trim()) {
            console.warn('processedHtml is empty, using template directly:', template);
            processedHtml = `<p>${escapeHtml(template)}</p>`;
          }
          
          // Now replace placeholders in the HTML with input fields
          // We need to handle placeholders that might be inside <p> tags or other HTML
          blanksToUse.forEach((blank, idx) => {
            const placeholder = `{${blank.index}}`;
            // Use blank.index to retrieve the answer, not array index
            // This ensures that blank {3} maps to answers[3], not answers[idx]
            const userAnswer = userAnswersArray[blank.index] !== undefined 
              ? userAnswersArray[blank.index] 
              : '';
            
            // Check if math mode is enabled for this specific blank
            const isMathMode = blank.mathMode === true;
            
            let inputField = '';
            
            if (isMathMode) {
              // Math mode: Use MathLive
              inputField = `<span class="fill-blank-wrapper inline-block align-middle">
                <math-field
                  class="fill-blank-input fill-blank-math inline-block min-w-[120px] px-3 py-2 mx-1 border-2 border-blue-400 rounded-md text-base focus:border-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-200 bg-white"
                  data-blank-index="${blank.index}"
                  data-blank-array-index="${idx}"
                  data-question-index="${currentQuestionIndex}"
                  placeholder="Jawaban"
                >${escapeHtml(userAnswer)}</math-field>
              </span>`;
            } else {
              // Text mode: Use regular input
              inputField = `<span class="fill-blank-wrapper inline-block align-middle">
                <input 
                  type="text" 
                  class="fill-blank-input fill-blank-text inline-block min-w-[120px] px-3 py-2 mx-1 border-2 border-blue-400 rounded-md text-base font-mono focus:border-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-200 bg-white" 
                  data-blank-index="${blank.index}"
                  data-blank-array-index="${idx}"
                  data-question-index="${currentQuestionIndex}"
                  value="${escapeHtml(userAnswer)}"
                  placeholder="Jawaban"
                  autocomplete="off"
                  spellcheck="false"
                />
              </span>`;
            }
            
            // Replace all occurrences of the placeholder in the HTML
            // Use a regex that matches {0} even if it's inside HTML tags
            const placeholderRegex = new RegExp(`\\{${blank.index}\\}`, 'g');
            processedHtml = processedHtml.replace(placeholderRegex, inputField);
          });
          
          questionHtml = processedHtml;
        }
        
        // Clean up any empty paragraphs that might have been created
        questionHtml = questionHtml.replace(/<p>\s*<\/p>\s*/g, '');
        questionHtml = questionHtml.replace(/\n\s*\n\s*\n/g, '\n\n'); // Clean up excessive newlines
        
        // For fill-in-the-blank, the question text already contains the inputs
        fillInBlanksHtml = '';
      } else if (question.type === 'essay') {
        // Process question text with LaTeX
        questionHtml = processLatex(question.question || '');
        
        // Render essay textarea with file upload support
        let currentAnswer = answers[currentQuestionIndex];
        let answerText = '';
        let answerFiles = [];
        
        // Handle both old format (string) and new format (object)
        if (typeof currentAnswer === 'string') {
          answerText = currentAnswer;
        } else if (currentAnswer && typeof currentAnswer === 'object') {
          answerText = currentAnswer.answer || '';
          answerFiles = Array.isArray(currentAnswer.files) ? currentAnswer.files : [];
        }
        
        const maxWords = question.maxWords || '';
        const allowFileUpload = question.allowFileUpload || false;
        // Handle both string format (from editor) and array format
        let allowedFileTypes = question.allowedFileTypes || [];
        if (typeof allowedFileTypes === 'string') {
          if (allowedFileTypes === 'all') {
            allowedFileTypes = ['images', 'pdf', 'text'];
          } else if (allowedFileTypes === 'images') {
            allowedFileTypes = ['images'];
          } else if (allowedFileTypes === 'pdf') {
            allowedFileTypes = ['pdf'];
          } else {
            allowedFileTypes = [];
          }
        }
        const hasImages = allowedFileTypes.includes('images') || allowedFileTypes.includes('image');
        const hasPDF = allowedFileTypes.includes('pdf');
        const hasText = allowedFileTypes.includes('text');
        
        essayHtml = `
          <div class="essay-container space-y-4">
            <textarea
              class="essay-input w-full px-4 py-3 border-2 border-gray-300 rounded-md text-base focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-200 resize-y"
              rows="8"
              data-question-index="${currentQuestionIndex}"
              placeholder="Tulis jawaban Anda di sini..."
            >${escapeHtml(answerText)}</textarea>
            ${maxWords ? `<div class="text-sm text-gray-500">Maksimum ${maxWords} kata</div>` : ''}
            
            ${allowFileUpload ? `
              <div class="essay-file-upload-section mt-4 space-y-3">
                <div class="text-sm font-medium text-gray-700">Unggah File:</div>
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-4 hover:border-blue-400 transition-colors essay-file-dropzone" data-question-index="${currentQuestionIndex}">
                  <div class="text-center">
                    <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                      <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                    <div class="mt-2 text-sm text-gray-600">
                      <span class="font-medium text-blue-600 hover:text-blue-500 cursor-pointer essay-file-upload-btn">Klik untuk mengunggah</span> atau seret dan lepas file di sini
                    </div>
                    <div class="mt-1 text-xs text-gray-500">
                      ${hasImages ? 'Gambar (JPG, PNG, GIF, WebP, SVG)' : ''}${hasImages && hasPDF ? ', ' : ''}${hasPDF ? 'PDF' : ''}${(hasImages || hasPDF) && hasText ? ', ' : ''}${hasText ? 'Teks' : ''}
                    </div>
                    <input type="file" class="essay-file-input hidden" data-question-index="${currentQuestionIndex}" ${hasImages && hasPDF ? '' : hasImages ? 'accept="image/*"' : hasPDF ? 'accept=".pdf"' : hasText ? 'accept=".txt"' : ''} multiple>
                  </div>
                </div>
                <div class="essay-uploaded-files space-y-2" data-question-index="${currentQuestionIndex}">
                  ${answerFiles.map((file, fileIndex) => {
                    // Prioritize filename, then name, then fallback to 'file'
                    const fileName = file.filename || file.name || 'file';
                    const fileUrl = file.url || '';
                    const isImage = /\.(jpg|jpeg|png|gif|webp|svg)$/i.test(fileName);
                    return `
                      <div class="flex items-center gap-3 p-2 bg-gray-50 rounded border border-gray-200" data-file-index="${fileIndex}">
                        ${isImage && fileUrl ? `<img src="${fileUrl}" alt="${escapeHtml(fileName)}" class="w-12 h-12 object-cover rounded">` : '<div class="w-12 h-12 bg-gray-200 rounded flex items-center justify-center"><svg class="w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg></div>'}
                        <div class="flex-1 min-w-0">
                          <div class="text-sm font-medium text-gray-700 truncate" title="${escapeHtml(fileName)}">${escapeHtml(fileName)}</div>
                          ${file.size ? `<div class="text-xs text-gray-500">${(file.size / 1024).toFixed(1)} KB</div>` : ''}
                        </div>
                        <button type="button" class="essay-file-remove text-red-600 hover:text-red-800 p-1" data-file-index="${fileIndex}" data-question-index="${currentQuestionIndex}">
                          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                          </svg>
                        </button>
                      </div>
                    `;
                  }).join('')}
                </div>
              </div>
            ` : ''}
          </div>
        `;
      } else {
        // Multiple choice questions or default
      // Process question text with LaTeX
        questionHtml = processLatex(question.question || '');
      
        const options = question.options || [];
        optionsHtml = options.map((option, optIndex) => {
        const optionHtml = processLatex(option || '');
        const isSelected = isAnswerSelected(currentQuestionIndex, optIndex + 1);
        const optionLetter = String.fromCharCode(65 + optIndex); // A, B, C, D...
        
        return `
          <label class="option-label ${isSelected ? 'selected' : ''}" data-option="${optIndex + 1}">
            <input
              type="${inputType}"
              name="question-${currentQuestionIndex}"
              value="${optIndex + 1}"
              ${isSelected ? 'checked' : ''}
              onclick="handleOptionClick(${currentQuestionIndex}, ${optIndex + 1}, this)"
            />
            <span class="option-letter">${optionLetter}</span>
            <div class="option-content">${optionHtml}</div>
          </label>
        `;
      }).join('');
      }
      
      // NOTE: Solutions are NOT sent to client for security
      // They are only shown on the results page after quiz submission
      
      // Render navigation bar directly into nav-container
      navContainer.innerHTML = `
        <button
          type="button"
          id="prev-btn-main"
          class="inline-flex items-center gap-2 px-4 py-2 bg-white border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
          ${currentQuestionIndex === 0 ? 'disabled' : ''}
        >
          ${arrowLeftSvg}
          <span>Sebelumnya</span>
        </button>
        
        <span class="text-gray-700 font-medium">
          Soal ${currentQuestionIndex + 1} dari ${quiz.questions.length}
        </span>
        
        <button
          type="button"
          id="next-btn-main"
          class="inline-flex items-center gap-2 px-4 py-2 bg-white border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <span>${currentQuestionIndex === quiz.questions.length - 1 ? 'Selesai' : 'Selanjutnya'}</span>
          ${arrowRightSvg}
        </button>
      `;

      // Render question content (no navigation bar inside)
      container.innerHTML = `
        <div class="question-card">
          <div class="question-header">
            <div class="flex items-center justify-between gap-2 flex-wrap">
              <span class="text-sm font-semibold text-slate-500 uppercase tracking-wider">Pertanyaan</span>
              ${isComplex ? `
                <span class="inline-flex items-center justify-center gap-1 px-2.5 py-1 rounded-lg text-xs font-medium bg-blue-100 text-blue-700 border border-blue-200 whitespace-nowrap flex-shrink-0">
                  <span class="hidden sm:inline">Pilihan Ganda Kompleks</span>
                  <span class="sm:hidden">Kompleks</span>
                </span>
              ` : question.type === 'multiple-choice' ? `
                <span class="inline-flex items-center justify-center gap-1 px-2.5 py-1 rounded-lg text-xs font-medium bg-blue-100 text-blue-700 border border-blue-200 whitespace-nowrap flex-shrink-0">
                  <span class="hidden sm:inline">Pilihan Tunggal</span>
                  <span class="sm:hidden">Tunggal</span>
                </span>
              ` : question.type === 'fill-in-the-blank' ? `
                <span class="inline-flex items-center justify-center gap-1 px-2.5 py-1 rounded-lg text-xs font-medium bg-orange-100 text-orange-700 border border-orange-200 whitespace-nowrap flex-shrink-0">
                  <span class="hidden sm:inline">Isian Singkat</span>
                  <span class="sm:hidden">Isian</span>
                </span>
              ` : question.type === 'essay' ? `
                <span class="inline-flex items-center justify-center gap-1 px-2.5 py-1 rounded-lg text-xs font-medium bg-green-100 text-green-700 border border-green-200 whitespace-nowrap flex-shrink-0">
                  <span class="hidden sm:inline">Esai</span>
                  <span class="sm:hidden">Esai</span>
                </span>
              ` : ''}
            </div>
          </div>
          
          <div class="question-body">
            ${question.type === 'fill-in-the-blank' ? `
              <div class="question-text-with-blanks prose max-w-none mb-8">
                ${questionHtml}
              </div>
            ` : `
            <div class="question-text prose max-w-none mb-8">
              ${questionHtml}
            </div>
            `}

            ${question.images && question.images.length > 0 ? `
              <div class="mb-8 grid grid-cols-1 sm:grid-cols-2 gap-4">
                ${question.images.map(img => `
                  <img src="${img}" alt="Question illustration" class="rounded-xl border border-slate-200 shadow-sm hover:shadow-md transition-shadow" />
                `).join('')}
              </div>
            ` : ''}

            ${optionsHtml ? `
            <div class="space-y-1">
              ${optionsHtml}
            </div>
            ` : ''}
            ${fillInBlanksHtml}
            ${essayHtml}

            <!-- Solution is hidden during quiz session, shown on results page -->
          </div>
        </div>
      `;

      // Add event handlers for navigation buttons
      document.getElementById('prev-btn-main').onclick = () => {
        if (currentQuestionIndex > 0) {
          goToQuestion(currentQuestionIndex - 1);
        }
      };

      document.getElementById('next-btn-main').onclick = () => {
        if (currentQuestionIndex < quiz.questions.length - 1) {
          goToQuestion(currentQuestionIndex + 1);
        } else {
          const unanswered = answers.filter(a => a === null).length;
          showFinishModal(unanswered);
        }
      };

      // Update flag button
      const flagBtn = document.getElementById('flag-btn');
      const flagText = document.getElementById('flag-text');
      if (flaggedQuestions.has(currentQuestionIndex)) {
        flagBtn.classList.add('bg-amber-100', 'border-amber-400');
        flagBtn.classList.remove('bg-white');
        flagText.textContent = '??? Ditandai';
      } else {
        flagBtn.classList.remove('bg-amber-100', 'border-amber-400');
        flagBtn.classList.add('bg-white');
        flagText.textContent = 'Ragu-Ragu';
      }

      // Render LaTeX immediately after content is set
      // Use requestAnimationFrame to ensure DOM is ready
      requestAnimationFrame(() => {
        renderLatex();
      });
      
      // Setup event listeners for fill-in-the-blank inputs
      if (question.type === 'fill-in-the-blank') {
        const blanks = question.blanks || [];
        
        // Handle MathLive fields (math mode) - check per blank
        container.querySelectorAll('.fill-blank-math').forEach((mathField) => {
          const questionIndex = parseInt(mathField.dataset.questionIndex);
          const blankIndex = parseInt(mathField.dataset.blankIndex);
          const blankArrayIndex = parseInt(mathField.dataset.blankArrayIndex);
          
          // Initialize answer array if needed
          // Use the maximum blank index + 1 to ensure all indices are covered
          // This handles cases where blanks might have indices like [0, 1, 2, 3] but array was initialized with wrong size
          const maxBlankIndex = blanks.length > 0 
            ? Math.max(...blanks.map(b => b.index || 0), blankIndex || 0)
            : blankIndex || 0;
          const requiredArraySize = maxBlankIndex + 1;
          
          if (!Array.isArray(answers[questionIndex])) {
            answers[questionIndex] = new Array(requiredArraySize).fill('');
          }
          
          // Ensure array is the right size - expand if needed
          while (answers[questionIndex].length < requiredArraySize) {
            answers[questionIndex].push('');
          }
          
          // Set initial value if exists (wait for MathLive to be ready)
          const existingAnswer = answers[questionIndex][blankIndex];
          if (existingAnswer) {
            function setInitialValue() {
              if (typeof window !== 'undefined' && window.MathLive && mathField.setValue) {
                try {
                  mathField.setValue(existingAnswer);
                } catch (e) {
                  console.warn('Error setting MathLive initial value:', e);
                }
              } else {
                // Retry after a short delay if MathLive isn't ready yet
                setTimeout(setInitialValue, 100);
              }
            }
            setInitialValue();
          }
          
          // Listen for input changes
          mathField.addEventListener('input', () => {
            updateActiveTime();
            let value = '';
            try {
              // Try to get value as LaTeX first, then convert to natural form if needed
              if (mathField.getValue) {
                const latexValue = mathField.getValue('latex') || '';
                // For now, store LaTeX - we can convert it back to natural form if needed
                // Or use the LaTeX directly for comparison
                value = latexValue;
              } else if (mathField.value) {
                value = mathField.value;
              } else {
                value = mathField.textContent || mathField.innerText || '';
              }
            } catch (e) {
              console.warn('Error getting MathLive value:', e);
              value = mathField.textContent || mathField.innerText || '';
            }
            
            // Update the answer for this blank
            answers[questionIndex][blankIndex] = value;
            
            // Save progress
            saveProgress();
            renderQuestionGrid();
            updateStats();
          });
        });
        
        // Handle text inputs (text mode)
        container.querySelectorAll('.fill-blank-text').forEach(input => {
          const questionIndex = parseInt(input.dataset.questionIndex);
          const blankArrayIndex = parseInt(input.dataset.blankArrayIndex);
          const blankIndex = parseInt(input.dataset.blankIndex);
          
          // Initialize answer array if needed
          if (!Array.isArray(answers[questionIndex])) {
            answers[questionIndex] = [];
          }
          
          // Calculate required array size based on all blank indices
          const maxBlankIndex = blanks.length > 0 
            ? Math.max(...blanks.map(b => (b.index !== undefined && b.index !== null) ? b.index : 0), blankIndex || 0)
            : blankIndex || 0;
          const requiredArraySize = maxBlankIndex + 1;
          
          // Ensure array is the right size - expand if needed
          while (answers[questionIndex].length < requiredArraySize) {
            answers[questionIndex].push('');
          }
          
          input.addEventListener('input', () => {
            updateActiveTime();
            
            // Update the answer for this blank using blank.index (not array index)
            answers[questionIndex][blankIndex] = input.value.trim();
            
            // Save progress
            saveProgress();
            renderQuestionGrid();
            updateStats();
          });
          
          // Copy LaTeX version when copying from input
          input.addEventListener('copy', (e) => {
            const start = input.selectionStart;
            const end = input.selectionEnd;
            if (start !== null && end !== null && start !== end) {
              const selection = input.value.substring(start, end);
              if (selection) {
                const latex = convertMathToLatex(selection);
                if (latex !== selection) {
                  e.clipboardData.setData('text/plain', latex);
                  e.preventDefault();
                }
              }
            }
          });
        });
      }
      
      // Setup event listeners for essay inputs
      if (question.type === 'essay') {
        const essayInput = container.querySelector('.essay-input');
        if (essayInput) {
          essayInput.addEventListener('input', () => {
            updateActiveTime();
            const questionIndex = parseInt(essayInput.dataset.questionIndex);
            
            // Initialize answer structure if needed
            if (typeof answers[questionIndex] === 'string') {
              answers[questionIndex] = {
                answer: answers[questionIndex],
                files: []
              };
            } else if (!answers[questionIndex] || typeof answers[questionIndex] !== 'object') {
              answers[questionIndex] = {
                answer: '',
                files: []
              };
            }
            
            answers[questionIndex].answer = essayInput.value;
            
            // Save progress
            saveProgress();
            renderQuestionGrid();
            updateStats();
          });
        }
        
        // Setup file upload handlers if file upload is enabled
        if (question.allowFileUpload) {
          const fileInput = container.querySelector('.essay-file-input');
          const uploadBtn = container.querySelector('.essay-file-upload-btn');
          const dropzone = container.querySelector('.essay-file-dropzone');
          const uploadedFilesContainer = container.querySelector('.essay-uploaded-files');
          const questionIndex = currentQuestionIndex;
          
          // Initialize answer structure if needed
          if (typeof answers[questionIndex] === 'string') {
            answers[questionIndex] = {
              answer: answers[questionIndex],
              files: []
            };
          } else if (!answers[questionIndex] || typeof answers[questionIndex] !== 'object') {
            answers[questionIndex] = {
              answer: '',
              files: []
            };
          }
          
          if (!Array.isArray(answers[questionIndex].files)) {
            answers[questionIndex].files = [];
          }
          
          // File input change handler
          if (fileInput) {
            fileInput.addEventListener('change', async function(e) {
              const files = e.target.files;
              if (!files || files.length === 0) return;
              
              for (let i = 0; i < files.length; i++) {
                const file = files[i];
                await handleFileUpload(file, questionIndex, uploadedFilesContainer);
              }
              
              // Reset input
              e.target.value = '';
            });
          }
          
          // Upload button click handler
          if (uploadBtn) {
            uploadBtn.addEventListener('click', () => {
              if (fileInput) fileInput.click();
            });
          }
          
          // Drag and drop handlers
          if (dropzone) {
            dropzone.addEventListener('dragover', (e) => {
              e.preventDefault();
              dropzone.classList.add('border-blue-500', 'bg-blue-50');
            });
            
            dropzone.addEventListener('dragleave', () => {
              dropzone.classList.remove('border-blue-500', 'bg-blue-50');
            });
            
            dropzone.addEventListener('drop', async (e) => {
              e.preventDefault();
              dropzone.classList.remove('border-blue-500', 'bg-blue-50');
              
              const files = e.dataTransfer.files;
              if (!files || files.length === 0) return;
              
              for (let i = 0; i < files.length; i++) {
                const file = files[i];
                await handleFileUpload(file, questionIndex, uploadedFilesContainer);
              }
            });
          }
          
          // Remove file handlers
          if (uploadedFilesContainer) {
            uploadedFilesContainer.addEventListener('click', function(e) {
              const removeBtn = e.target.closest('.essay-file-remove');
              if (removeBtn) {
                const fileIndex = parseInt(removeBtn.dataset.fileIndex);
                const qIndex = parseInt(removeBtn.dataset.questionIndex);
                
                if (answers[qIndex] && Array.isArray(answers[qIndex].files)) {
                  answers[qIndex].files.splice(fileIndex, 1);
                  
                  // Save progress
                  saveProgress();
                  renderQuestion();
                  renderQuestionGrid();
                  updateStats();
                }
              }
            });
          }
        }
      }
    }

    // Check if answer is selected
    function isAnswerSelected(questionIndex, optionValue) {
      const answer = answers[questionIndex];
      if (answer === null || answer === undefined) return false;
      // For fill-in-the-blank and essay, answers are arrays/strings, not option values
      const question = quiz.questions[questionIndex];
      if (question && (question.type === 'fill-in-the-blank' || question.type === 'essay')) {
        // For these types, check if answer exists (non-empty)
        if (Array.isArray(answer)) {
          return answer.some(a => a && a.trim() !== '');
        }
        if (question.type === 'essay' && answer && typeof answer === 'object') {
          // New essay structure: { answer: string, files: [...] }
          return (answer.answer && answer.answer.trim() !== '') || (Array.isArray(answer.files) && answer.files.length > 0);
        }
        return answer && typeof answer === 'string' && answer.trim() !== '';
      }
      // For multiple choice questions
      if (Array.isArray(answer)) {
        return answer.includes(optionValue);
      }
      return answer === optionValue;
    }

    // Handle option click (supports deselect for single choice)
    window.handleOptionClick = function(questionIndex, optionValue, inputEl) {
      // Update active time on user interaction
      updateActiveTime();
      
      const inputType = inputEl.type;
      if (inputType === 'checkbox') {
        // Complex multiple choice
        if (!Array.isArray(answers[questionIndex])) {
          answers[questionIndex] = [];
        }
        const idx = answers[questionIndex].indexOf(optionValue);
        if (idx > -1) {
          answers[questionIndex].splice(idx, 1);
        } else {
          answers[questionIndex].push(optionValue);
        }
        if (answers[questionIndex].length === 0) {
          answers[questionIndex] = null;
        }
      } else {
        // Single choice with deselect support
        const alreadySelected = answers[questionIndex] === optionValue;
        answers[questionIndex] = alreadySelected ? null : optionValue;
        // Reflect deselect on the input
        inputEl.checked = !alreadySelected;
      }

      // Update UI
      renderQuestionGrid();
      updateStats();
      
      // Update option styling
      document.querySelectorAll('.option-label').forEach(label => {
        const option = parseInt(label.dataset.option);
        if (isAnswerSelected(questionIndex, option)) {
          label.classList.add('selected');
        } else {
          label.classList.remove('selected');
        }
      });

      // Save progress
      saveProgress();
    };

    // Navigation functions
    function goToQuestion(index) {
      // Update active time on navigation
      updateActiveTime();
      
      const clampedIndex = Math.max(0, Math.min(index, quiz.questions.length - 1));
      currentQuestionIndex = clampedIndex;
      renderQuestion();
      renderQuestionGrid();
      // Scroll main area to top
      const mainArea = document.querySelector('.flex-1.overflow-y-auto');
      if (mainArea) {
        mainArea.scrollTo({ top: 0, behavior: 'smooth' });
      }
      // Save progress
      saveProgress();
    }

    // Flag button handler
    document.getElementById('flag-btn').onclick = () => {
      // Update active time on user interaction
      updateActiveTime();
      
      if (flaggedQuestions.has(currentQuestionIndex)) {
        flaggedQuestions.delete(currentQuestionIndex);
      } else {
        flaggedQuestions.add(currentQuestionIndex);
      }
      renderQuestion();
      renderQuestionGrid();
      updateStats();
      // Save progress
      saveProgress();
    };

    // Submit quiz
    document.getElementById('submit-quiz-btn').onclick = () => {
      const unanswered = answers.map((answer, index) => {
        const question = quiz.questions[index];
        if (question?.type === 'fill-in-the-blank') {
          // Check if array has any non-empty answers
          return !Array.isArray(answer) || !answer.some(a => a && a.trim() !== '');
        } else if (question?.type === 'essay') {
          // Check if string is non-empty or object has answer/files
          if (typeof answer === 'string') {
            return !answer || answer.trim() === '';
          } else if (answer && typeof answer === 'object') {
            return !((answer.answer && answer.answer.trim() !== '') || (Array.isArray(answer.files) && answer.files.length > 0));
          }
          return true; // No answer
        } else {
          // Multiple choice
          return answer === null;
        }
      }).filter(Boolean).length;
      showFinishModal(unanswered);
    };

    // Cancel attempt function (only for exercises)
    async function cancelAttempt() {
      if (quiz.quizType === 'tryout' || quiz.quizType === 'exam') {
        // Should not be visible for exams, but double-check
        return;
      }

      const confirmed = window.confirm('Apakah Anda yakin ingin membatalkan percobaan ini? Semua progress akan hilang.');
      if (!confirmed) {
        return;
      }

      // Stop timer
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      if (typeof cancelAnimationFrame !== 'undefined' && animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }

      // Disable leave confirmation
      disableLeaveConfirm();

      // Clear progress and queue
      clearProgress();
      try {
        localStorage.removeItem(QUEUE_KEY);
      } catch (error) {
        console.error('Error clearing queue:', error);
      }

      // Redirect to quiz landing page
      window.location.href = `/quizzes/${id}`;
    }

    // Cancel button handler (will be set up in initializeQuiz)

    async function submitQuiz(endReason = 'manual') {
      quizSubmitted = true;
      disableLeaveConfirm();

      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      if (typeof cancelAnimationFrame !== 'undefined' && animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Update active time before submission
      updateActiveTime();
      
      const timeSpent = activeTimeSpent;
      
      try {
        const response = await fetch('/api/quiz/submit', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            quizId: parseInt(id),
            answers: answers.map((answer, index) => {
              const question = quiz.questions[index];
              // For fill-in-the-blank, answer is already an array
              // For essay, answer is a string
              // For multiple choice, answer is a number or array of numbers
              if (question?.type === 'fill-in-the-blank') {
                return {
                  questionId: index,
                  answer: Array.isArray(answer) ? answer : []
                };
              } else if (question?.type === 'essay') {
                // Handle both old format (string) and new format (object with files)
                if (typeof answer === 'string') {
                  return {
                    questionId: index,
                    type: 'essay',
                    answer: answer ? [answer] : []
                  };
                } else if (answer && typeof answer === 'object') {
                  // New format: { answer: string, files: [...] }
                  return {
                    questionId: index,
                    type: 'essay',
                    answer: answer // Store the object structure
                  };
                } else {
                  return {
                    questionId: index,
                    type: 'essay',
                    answer: []
                  };
                }
              } else {
                return {
              questionId: index,
              answer: answer === null ? [] : (Array.isArray(answer) ? answer : [answer])
                };
              }
            }),
            flaggedQuestions: Array.from(flaggedQuestions),
            timeSpent,
            endReason,
            sessionStartedAt: openStartedAt
          })
        });
        
        const result = await response.json();
        
        if (response.ok) {
          // If release is delayed, keep a pending entry
          // Explicitly check for admin release mode
          const isManualRelease = quiz.scoreReleaseMode === 'admin';
          const delayedRelease = isManualRelease || (quiz.scoreReleaseMode && quiz.scoreReleaseMode !== 'immediate');
          
          if (delayedRelease) {
            const pendingEntry = {
              quizId: parseInt(id),
              title: quiz.title,
              quizType: quiz.quizType,
              status: 'pending_result',
              scoreReleaseMode: quiz.scoreReleaseMode,
              attemptId: result.attemptId,
              remainingTime: 0,
              availableUntil: quiz.availableUntil || null,
              url: `/quizzes/${id}/review/${result.attemptId}`,
              savedAt: Date.now(),
              seen: false
            };
            localStorage.setItem(QUEUE_KEY, JSON.stringify(pendingEntry));
          } else {
            // immediate release: store a recent entry for header mini history
            const releasedEntry = {
              quizId: parseInt(id),
              title: quiz.title,
              quizType: quiz.quizType,
              status: 'released',
              scoreReleaseMode: 'immediate',
              attemptId: result.attemptId,
              percentage: result.percentage ?? null,
              remainingTime: 0,
              availableUntil: quiz.availableUntil || null,
              url: `/quizzes/${id}/review/${result.attemptId}`,
              savedAt: Date.now(),
              completedAt: Date.now(),
              seen: false
            };
            localStorage.setItem(QUEUE_KEY, JSON.stringify(releasedEntry));
          }
          // Clear saved progress (keep queue for pending/released)
          clearProgress();
          window.location.href = `/quizzes/${id}/results?score=${result.percentage || 0}`;
        } else {
          alert('Error submitting quiz: ' + result.error);
        }
      } catch (error) {
        quizSubmitted = false;
        enableLeaveConfirm();
        alert('Error submitting quiz. Please try again.');
        console.error(error);
      }
    }

    // Initialize quiz
    function initializeQuiz() {
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/9b3c54a2-2c4a-417f-b085-4ef9df059af2',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'quizzes/[id]/start.astro:2894',message:'initializeQuiz called',data:{readyState:document.readyState,hasQuiz:!!quiz},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
      
      console.log('Initializing quiz... readyState:', document.readyState);
      
      // Double-check that all required elements exist
      const requiredElements = [
        'question-container',
        'nav-container',
        'question-grid',
        'answered-count',
        'flagged-count',
        'unanswered-count',
        'flag-btn',
        'submit-quiz-btn'
      ];
      
      const missingElements = requiredElements.filter(id => !document.getElementById(id));
      
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/9b3c54a2-2c4a-417f-b085-4ef9df059af2',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'quizzes/[id]/start.astro:2909',message:'Element check',data:{missingElements:missingElements.length,missing:missingElements},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
      
      if (missingElements.length > 0) {
        console.error('Missing elements:', missingElements);
        console.log('Retrying in 50ms...');
        setTimeout(initializeQuiz, 50);
        return;
      }
      
      console.log('All elements found, initializing...');
      
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/9b3c54a2-2c4a-417f-b085-4ef9df059af2',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'quizzes/[id]/start.astro:2918',message:'All elements found, proceeding',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion

      // Availability checks
      const nowTs = Date.now();
      if (availableFromTs && nowTs < availableFromTs) {
        renderLockedState('Kuis belum dibuka', `Kuis dapat diakses mulai ${new Date(availableFromTs).toLocaleString('id-ID')}`);
        return;
      }
      if (availableUntilTs && nowTs > availableUntilTs) {
        renderLockedState('Kuis sudah ditutup', `Batas waktu akses berakhir pada ${new Date(availableUntilTs).toLocaleString('id-ID')}`);
        return;
      }
      if (openDurationSeconds > 0) {
        const elapsedSinceOpen = Math.floor((Date.now() - openStartedAt) / 1000);
        const openRemaining = openDurationSeconds - elapsedSinceOpen;
        if (openRemaining <= 0) {
          renderLockedState('Waktu sesi habis', 'Sesi kuis ini sudah berakhir. Silakan lihat hasil Anda.');
          return;
        }
        // Adjust remainingTime to also respect session window
        remainingTime = remainingTime ? Math.min(remainingTime, openRemaining) : openRemaining;
      }
      
      // Initialize timer first
      initializeTimer();
      
      // Show/hide cancel button based on quiz type (only for exercises)
      const cancelBtn = document.getElementById('cancel-attempt-btn');
      if (cancelBtn) {
        const isExercise = quiz.quizType !== 'tryout' && quiz.quizType !== 'exam';
        if (isExercise) {
          cancelBtn.classList.remove('hidden');
          cancelBtn.onclick = cancelAttempt;
        } else {
          cancelBtn.classList.add('hidden');
        }
      }
      
      // Render UI immediately (don't wait for KaTeX)
      console.log('Rendering question grid...');
      renderQuestionGrid();
      console.log('Updating stats...');
      updateStats();
      console.log('Rendering question...');
      renderQuestion();
      
      // LaTeX will be rendered by renderQuestion() via requestAnimationFrame
      console.log('Quiz initialized successfully');
      enableLeaveConfirm();
    }

    // Wait for DOM to be fully ready
    function startInitialization() {
      console.log('startInitialization called, readyState:', document.readyState);
      
      if (document.readyState === 'loading') {
        console.log('Waiting for DOMContentLoaded...');
        document.addEventListener('DOMContentLoaded', () => {
          console.log('DOMContentLoaded fired');
          // Use a small delay to ensure all elements are painted
          setTimeout(initializeQuiz, 10);
        });
      } else {
        console.log('DOM already ready, initializing...');
        // Use a small delay to ensure all elements are painted
        setTimeout(initializeQuiz, 10);
      }
    }
    
    // Initialize quiz on page load
    // Check if we have saved progress, otherwise start fresh
    if (!hasProgress) {
      hasStarted = true;
      startTime = Date.now();
      openStartedAt = Date.now();
      activeTimeSpent = 0;
      lastActivityTime = Date.now();
      saveProgress();
    }
    
    // Start initialization immediately
    startInitialization();
    
    // Mobile sidebar toggle
    const sidebar = document.getElementById('sidebar');
    const sidebarOverlay = document.getElementById('sidebar-overlay');
    const mobileSidebarToggle = document.getElementById('mobile-sidebar-toggle');
    const closeSidebar = document.getElementById('close-sidebar');
    
    function openSidebar() {
      sidebar?.classList.remove('translate-x-full');
      sidebarOverlay?.classList.remove('hidden');
      document.body.style.overflow = 'hidden';
    }
    
    function closeSidebarFn() {
      sidebar?.classList.add('translate-x-full');
      sidebarOverlay?.classList.add('hidden');
      document.body.style.overflow = '';
    }
    
    mobileSidebarToggle?.addEventListener('click', openSidebar);
    closeSidebar?.addEventListener('click', closeSidebarFn);
    sidebarOverlay?.addEventListener('click', closeSidebarFn);
    
    // Mobile bottom navigation
    const mobilePrevBtn = document.getElementById('mobile-prev-btn');
    const mobileNextBtn = document.getElementById('mobile-next-btn');
    const mobileFlagBtn = document.getElementById('mobile-flag-btn');
    
    mobilePrevBtn?.addEventListener('click', () => {
      if (currentQuestionIndex > 0) {
        goToQuestion(currentQuestionIndex - 1);
      }
    });
    
    mobileNextBtn?.addEventListener('click', () => {
      if (currentQuestionIndex < quiz.questions.length - 1) {
        goToQuestion(currentQuestionIndex + 1);
      } else {
        const unanswered = answers.filter(a => a === null).length;
        showFinishModal(unanswered);
      }
    });
    
    mobileFlagBtn?.addEventListener('click', () => {
      if (flaggedQuestions.has(currentQuestionIndex)) {
        flaggedQuestions.delete(currentQuestionIndex);
      } else {
        flaggedQuestions.add(currentQuestionIndex);
      }
      renderQuestion();
      renderQuestionGrid();
      updateStats();
      saveProgress();
    });
    
    // Update mobile buttons state
    function updateMobileNav() {
      if (mobilePrevBtn) {
        mobilePrevBtn.disabled = currentQuestionIndex === 0;
      }
      if (mobileNextBtn) {
        const labelSpan = mobileNextBtn.querySelector('span');
        if (labelSpan) {
          labelSpan.textContent = currentQuestionIndex === quiz.questions.length - 1 ? 'Selesai' : 'Next';
        }
      }
    }
    
    // Call updateMobileNav in goToQuestion
    const originalGoToQuestion = goToQuestion;
    goToQuestion = function(index) {
      originalGoToQuestion(index);
      updateMobileNav();
    };

    // ============================================
    // ANTI-CHEATING MEASURES
    // ============================================
    
    // Track page visibility for accurate time tracking
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        // User returned to the tab - update activity timestamp
        lastActivityTime = Date.now();
      }
    });
    
    // Disable right-click on quiz content
    document.getElementById('question-container')?.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      return false;
    });

    // Disable common keyboard shortcuts for DevTools/View Source
    document.addEventListener('keydown', (e) => {
      // Disable F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
      if (
        e.key === 'F12' ||
        (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'i' || e.key === 'J' || e.key === 'j')) ||
        (e.ctrlKey && (e.key === 'U' || e.key === 'u'))
      ) {
        e.preventDefault();
        return false;
      }
    });

    // Detect if DevTools is open (basic detection)
    let devToolsWarningShown = false;
    const devToolsDetector = setInterval(() => {
      const widthThreshold = window.outerWidth - window.innerWidth > 160;
      const heightThreshold = window.outerHeight - window.innerHeight > 160;
      
      if ((widthThreshold || heightThreshold) && !devToolsWarningShown) {
        devToolsWarningShown = true;
        console.clear();
        console.log('%c?????? PERINGATAN!', 'color: red; font-size: 24px; font-weight: bold;');
        console.log('%cMembuka DevTools selama ujian dapat dianggap sebagai kecurangan dan akan dicatat.', 'color: red; font-size: 14px;');
        console.log('%cOpening DevTools during the exam may be considered cheating and will be logged.', 'color: red; font-size: 14px;');
      }
    }, 1000);

    // Clear interval when leaving page
    window.addEventListener('beforeunload', () => {
      clearInterval(devToolsDetector);
    });

    // Disable drag on images
    document.querySelectorAll('img').forEach(img => {
      img.addEventListener('dragstart', (e) => e.preventDefault());
    });
  </script>
</Layout>
